{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/images/jenius.jpeg","path":"images/jenius.jpeg","modified":1,"renderable":0},{"_id":"source/images/object.jpeg","path":"images/object.jpeg","modified":1,"renderable":0},{"_id":"source/images/namehiding.png","path":"images/namehiding.png","modified":1,"renderable":0},{"_id":"source/images/result.jpeg","path":"images/result.jpeg","modified":1,"renderable":0},{"_id":"source/images/shouji.png","path":"images/shouji.png","modified":1,"renderable":0},{"_id":"source/images/v.jpg","path":"images/v.jpg","modified":1,"renderable":0},{"_id":"source/images/x.jpg","path":"images/x.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/404.html","path":"404.html","modified":1,"renderable":1},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/waterfall.png","path":"images/waterfall.png","modified":1,"renderable":0},{"_id":"source/images/xieafterupdate.png","path":"images/xieafterupdate.png","modified":1,"renderable":0},{"_id":"source/images/C++/const3.png","path":"images/C++/const3.png","modified":1,"renderable":0},{"_id":"source/images/C++/const2.png","path":"images/C++/const2.png","modified":1,"renderable":0},{"_id":"source/images/C++/const4.png","path":"images/C++/const4.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态9.png","path":"images/C++/多态9.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R1.png","path":"images/algorithm/D&R1.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R2.png","path":"images/algorithm/D&R2.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R3.png","path":"images/algorithm/D&R3.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash1.png","path":"images/algorithm/hash1.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash2.png","path":"images/algorithm/hash2.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash3.png","path":"images/algorithm/hash3.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash6.png","path":"images/algorithm/hash6.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash5.png","path":"images/algorithm/hash5.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash8.png","path":"images/algorithm/hash8.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/lyf.png","path":"images/algorithm/lyf.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive2.png","path":"images/algorithm/recursive2.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive3.png","path":"images/algorithm/recursive3.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive4.png","path":"images/algorithm/recursive4.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive5.png","path":"images/algorithm/recursive5.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive6.png","path":"images/algorithm/recursive6.png","modified":1,"renderable":0},{"_id":"source/images/guanliao.png","path":"images/guanliao.png","modified":1,"renderable":0},{"_id":"source/images/python/quesheng.jpeg","path":"images/python/quesheng.jpeg","modified":1,"renderable":0},{"_id":"source/images/python/ssh1.png","path":"images/python/ssh1.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh2.png","path":"images/python/ssh2.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh3.png","path":"images/python/ssh3.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh4.png","path":"images/python/ssh4.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh7.png","path":"images/python/ssh7.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh8.png","path":"images/python/ssh8.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/images/C++/inline2.png","path":"images/C++/inline2.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态5.png","path":"images/C++/多态5.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/1.png","path":"images/algorithm/1.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R4.png","path":"images/algorithm/D&R4.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R7.png","path":"images/algorithm/D&R7.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash4.png","path":"images/algorithm/hash4.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive1.png","path":"images/algorithm/recursive1.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive7.png","path":"images/algorithm/recursive7.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive8.png","path":"images/algorithm/recursive8.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh6.png","path":"images/python/ssh6.png","modified":1,"renderable":0},{"_id":"source/images/C++/const1.png","path":"images/C++/const1.png","modified":1,"renderable":0},{"_id":"source/images/C++/inline1.png","path":"images/C++/inline1.png","modified":1,"renderable":0},{"_id":"source/images/C++/reference2.png","path":"images/C++/reference2.png","modified":1,"renderable":0},{"_id":"source/images/C++/reference3.png","path":"images/C++/reference3.png","modified":1,"renderable":0},{"_id":"source/images/C++/reference4.png","path":"images/C++/reference4.png","modified":1,"renderable":0},{"_id":"source/images/C++/static1.png","path":"images/C++/static1.png","modified":1,"renderable":0},{"_id":"source/images/C++/static3.png","path":"images/C++/static3.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态2.png","path":"images/C++/多态2.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态3.png","path":"images/C++/多态3.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态4.png","path":"images/C++/多态4.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态6.png","path":"images/C++/多态6.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态7.png","path":"images/C++/多态7.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态8.png","path":"images/C++/多态8.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/3.png","path":"images/algorithm/3.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R5.png","path":"images/algorithm/D&R5.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/hash7.png","path":"images/algorithm/hash7.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/recursive9.png","path":"images/algorithm/recursive9.png","modified":1,"renderable":0},{"_id":"source/images/python/ssh5.png","path":"images/python/ssh5.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/C++/copy1.png","path":"images/C++/copy1.png","modified":1,"renderable":0},{"_id":"source/images/C++/reference1.png","path":"images/C++/reference1.png","modified":1,"renderable":0},{"_id":"source/images/C++/static2.png","path":"images/C++/static2.png","modified":1,"renderable":0},{"_id":"source/images/C++/static4.png","path":"images/C++/static4.png","modified":1,"renderable":0},{"_id":"source/images/C++/static5.png","path":"images/C++/static5.png","modified":1,"renderable":0},{"_id":"source/images/C++/多态1.png","path":"images/C++/多态1.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/2.png","path":"images/algorithm/2.png","modified":1,"renderable":0},{"_id":"source/images/algorithm/D&R6.png","path":"images/algorithm/D&R6.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"source/images/algorithm/4.png","path":"images/algorithm/4.png","modified":1,"renderable":0},{"_id":"source/images/soft classify.png","path":"images/soft classify.png","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/hacker.jpg","path":"images/hacker.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"a5991bb3598c5d934bd97e3bc4ed14b71ebf1e62","modified":1519381117000},{"_id":"source/CNAME","hash":"4f750f9803f8b00b70f313f29448179491ee0681","modified":1519381117000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1519381118000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1519381118000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1519381118000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1519381118000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1519381118000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1519381118000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1519381118000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1519381118000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1519381118000},{"_id":"themes/next/_config.yml","hash":"6576f34441ed131e07b8968ddc4d10027fcfb333","modified":1519381118000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1519381118000},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1519381118000},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1519381118000},{"_id":"source/favicon.ico","hash":"c020c0be2d7627f2356b32659f32be6febcc2620","modified":1519381117000},{"_id":"source/404/404.html","hash":"f4336795df3e13a0784cb66ca1ac7c4dff3951e2","modified":1519381117000},{"_id":"source/404/index.html","hash":"8f8924aec628b7416f7797fbd673f713a0dfd8a6","modified":1519381117000},{"_id":"source/404/index.md","hash":"83ea702bd687a395d488dd75b8d4e9e4449161a4","modified":1519381117000},{"_id":"source/_posts/C语言链表.md","hash":"44007990c5f5528785686c26f4ecfbc384793b2a","modified":1519381117000},{"_id":"source/_posts/hacker.md","hash":"1f60f4c4f46f67a76377e5b40af32d1f0a9ce2d0","modified":1519381117000},{"_id":"source/_posts/文章测试.md","hash":"f3b155b37e45ad251769af6c971dc39aa24dbdf9","modified":1519381117000},{"_id":"source/_posts/构造之法第2章.md","hash":"72c3423cac664b35c7c95da1e7c12f608c06326d","modified":1519381117000},{"_id":"source/_posts/构造之法第5章.md","hash":"d709dc3bf60203e85fa9703dfac0e99770906a93","modified":1519381117000},{"_id":"source/_posts/测试驱动开发.md","hash":"0842e012c265048950f442666e67fa47562eed24","modified":1519381117000},{"_id":"source/_posts/读构建之法体会.md","hash":"f999e762e8c077ab5310aa0c68ceca9c24323a77","modified":1519381117000},{"_id":"source/images/jenius.jpeg","hash":"5d39dc47580954bfe3100f5de942eedb51b4dffe","modified":1519381118000},{"_id":"source/images/object.jpeg","hash":"bf33da4cebb20a2a70b53953bb62cd18dcedc2e5","modified":1519381118000},{"_id":"source/images/namehiding.png","hash":"48ded6110de9e272b1a9a4655753d1caee8cfc92","modified":1519381118000},{"_id":"source/images/result.jpeg","hash":"875b39ee99e86cb703179e940d040c99f4e7cd2f","modified":1519381118000},{"_id":"source/images/shouji.png","hash":"1e23085cc0cb451657ed5a9498e22bc4f1a16590","modified":1519381118000},{"_id":"source/images/v.jpg","hash":"e55e0db620b6f13f9b9bf1345cfb160e6bc7cb36","modified":1519381118000},{"_id":"source/images/x.jpg","hash":"62f2395f13310d950a0c182f04702693bf8fde2c","modified":1519381118000},{"_id":"source/title/index.md","hash":"18bf91f6a902164a72928497a5f2618c059fe562","modified":1519381118000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1519381118000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1519381118000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1519381118000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1519381118000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1519381118000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1519381118000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1519381118000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1519381118000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1519381118000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1519381118000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1519381118000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1519381118000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1519381118000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1519381118000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1519381118000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1519381118000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1519381118000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1519381118000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1519381118000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1519381118000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1519381118000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1519381118000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1519381118000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1519381118000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1519381118000},{"_id":"themes/next/source/404.html","hash":"a5991bb3598c5d934bd97e3bc4ed14b71ebf1e62","modified":1519381118000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1519381118000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1519381118000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1519381118000},{"_id":"source/images/avatar.jpg","hash":"f405e9b933f8528a205d7aa3a0a90c864b2b0927","modified":1519381118000},{"_id":"source/images/waterfall.png","hash":"e8d4535dad777ba3d54acbff743eda0d38d5510e","modified":1519381118000},{"_id":"source/images/xieafterupdate.png","hash":"c6e44c0821dcbaa2d16757bcbde34b2415938dcb","modified":1519381118000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"source/_posts/C++/C++内联函数.md","hash":"475a9c8a5fe85af708070e80e46b777359f5a95e","modified":1519381117000},{"_id":"source/_posts/C++/Const.md","hash":"f5863e9bf2c8b01688f45fd87101f83dde785ecc","modified":1519381117000},{"_id":"source/_posts/C++/inherit.md","hash":"3d3e4775b2fbb362df8a470f1176e582aa492d63","modified":1519381117000},{"_id":"source/_posts/C++/namehiding.png","hash":"48ded6110de9e272b1a9a4655753d1caee8cfc92","modified":1519381117000},{"_id":"source/_posts/C++/reference.md","hash":"92708de7ef98d2524644651a382f6aca885e531f","modified":1519381117000},{"_id":"source/_posts/C++/多态.md","hash":"7946d8d225b5922f69ec6d82f196f961682f9f59","modified":1519381117000},{"_id":"source/_posts/C++/拷贝构造函数.md","hash":"a01525d0622c9557e7978ab7aea25263b49d6ef8","modified":1519381117000},{"_id":"source/_posts/C++/静态对象.md","hash":"04a987e2f949a4c940b3281a512a6db14607cb04","modified":1519381117000},{"_id":"source/_posts/algorithm/快速排序.md","hash":"b116687d6e888c519843f63500832cadb3e81414","modified":1519381117000},{"_id":"source/_posts/algorithm/散列表.md","hash":"e1aeb3a838a20a4a612191ee4285ec3ee70d15f7","modified":1519381117000},{"_id":"source/_posts/algorithm/算法.md","hash":"6dc2296a577d63edb95dca47cd2ef081b0a82311","modified":1519381117000},{"_id":"source/_posts/algorithm/选择排序.md","hash":"0b69fbd0c50e8d102f786730f0c8d335d1dac38f","modified":1519381117000},{"_id":"source/_posts/algorithm/递归.md","hash":"9de43e44a7f09161b94dedc8c89454d1fa1790d1","modified":1519381117000},{"_id":"source/_posts/java/第二章创建和销毁对象.md","hash":"5df7a37b7950f0eb4cabfead39a5d731e645dc0d","modified":1519381117000},{"_id":"source/_posts/python/SSHClient.md","hash":"fb85711e67a81ed2e7a4e8cce38c09a4d3cb9c7a","modified":1519381117000},{"_id":"source/_posts/python/inherit.md","hash":"55eefd258523696d766b75e2e95aefbe2c326fb5","modified":1519381117000},{"_id":"source/_posts/python/result.jpeg","hash":"875b39ee99e86cb703179e940d040c99f4e7cd2f","modified":1519381117000},{"_id":"source/_posts/python/ssh1.png","hash":"9618f989bb280fa847d0896c355d4149d702af6d","modified":1519381117000},{"_id":"source/_posts/python/ssh2.png","hash":"4ad24129fa8b71077e75dd8e196f6f7a1b71cf37","modified":1519381117000},{"_id":"source/images/C++/const3.png","hash":"0eeb36ca4fd815cd88d90635523ef92b0b9c62c5","modified":1519381117000},{"_id":"source/images/C++/const2.png","hash":"e2dcce255919227a3248de5f443b97d72a9c96b6","modified":1519381117000},{"_id":"source/images/C++/const4.png","hash":"219d0e0e08f0174eb0b41bfe97567b34be1713a2","modified":1519381117000},{"_id":"source/images/C++/多态9.png","hash":"2361a3624048ab3f00ab1922176d2543c2afd28d","modified":1519381118000},{"_id":"source/images/algorithm/D&R1.png","hash":"50b2b0b7437e2eb37a38a284f4093defd12db0ca","modified":1519381118000},{"_id":"source/images/algorithm/D&R2.png","hash":"3fa1497d7522414b6841d45c754bee3458289047","modified":1519381118000},{"_id":"source/images/algorithm/D&R3.png","hash":"1aaf17c63573dcf128a9d42e61c86658e1d83a19","modified":1519381118000},{"_id":"source/images/algorithm/hash1.png","hash":"4e4d7c39fc207d18c3c0bb0762ca948d1a9fe0cd","modified":1519381118000},{"_id":"source/images/algorithm/hash2.png","hash":"387e8096cfdaeb8bb2795387d9421bd62264d4eb","modified":1519381118000},{"_id":"source/images/algorithm/hash3.png","hash":"9b1b44b6071b140e4413cbeeeaff53fd3e5cc48b","modified":1519381118000},{"_id":"source/images/algorithm/hash6.png","hash":"199856bb0e9e90a26f4efeab33e8eabbbb328245","modified":1519381118000},{"_id":"source/images/algorithm/hash5.png","hash":"8037f827b10d9e55110c284d422447ac1ab25fda","modified":1519381118000},{"_id":"source/images/algorithm/hash8.png","hash":"60432e4e650fe90ee30a00c60a13c308d508f071","modified":1519381118000},{"_id":"source/images/algorithm/lyf.png","hash":"787d1f32b38aa3c95fdabf2b8cf769d58924d4bf","modified":1519381118000},{"_id":"source/images/algorithm/recursive2.png","hash":"d176bca37955172a2e06306f2eabede44461bee6","modified":1519381118000},{"_id":"source/images/algorithm/recursive3.png","hash":"10e78967e83b9a2ddddefefe8c8db5807e755311","modified":1519381118000},{"_id":"source/images/algorithm/recursive4.png","hash":"6009f0714c04a41e536f6b1d70591acdf2f3dacc","modified":1519381118000},{"_id":"source/images/algorithm/recursive5.png","hash":"cc3f4e5d2f1a2fbac83efe1112cb055117ab19b3","modified":1519381118000},{"_id":"source/images/algorithm/recursive6.png","hash":"6ce36309795ab99c4b252b06cb11387b6f959891","modified":1519381118000},{"_id":"source/images/guanliao.png","hash":"1f5ce00fbb4a29458c3f5355af306954de56942f","modified":1519381118000},{"_id":"source/images/python/quesheng.jpeg","hash":"6f8d1879f4cbf9703e3817a8458e6b655d1bb840","modified":1519381118000},{"_id":"source/images/python/ssh1.png","hash":"9618f989bb280fa847d0896c355d4149d702af6d","modified":1519381118000},{"_id":"source/images/python/ssh2.png","hash":"4ad24129fa8b71077e75dd8e196f6f7a1b71cf37","modified":1519381118000},{"_id":"source/images/python/ssh3.png","hash":"aa08426da30f93f0303116372be45fd13e36e0e8","modified":1519381118000},{"_id":"source/images/python/ssh4.png","hash":"9ed297ca96e9790c91b6cf74a509d8482c515ca9","modified":1519381118000},{"_id":"source/images/python/ssh7.png","hash":"f9190bc4f99f7a8d6e4d343f5f951db75cd8e411","modified":1519381118000},{"_id":"source/images/python/ssh8.png","hash":"01a7ac96333a658e9421d19c0756c606c36cd734","modified":1519381118000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519381118000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519381118000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1519381118000},{"_id":"themes/next/layout/_macro/post.swig","hash":"2c2efe44ea013030f3ce5da7bfdeddb74489eb6e","modified":1519381118000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1519381118000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1519381118000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1519381118000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1519381118000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1519381118000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1519381118000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1519381118000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1519381118000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1519381118000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1519381118000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1519381118000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1519381118000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1519381118000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1519381118000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1519381118000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1519381118000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1519381118000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1519381118000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1519381118000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1519381118000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1519381118000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1519381118000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1519381118000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1519381118000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1519381118000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1519381118000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1519381118000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1519381118000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1519381118000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1519381118000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1519381118000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519381118000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519381118000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1519381118000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1519381118000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1519381118000},{"_id":"source/images/C++/inline2.png","hash":"aef983dda57441b039c1a3c8cb9e7d9ca904d4e5","modified":1519381117000},{"_id":"source/images/C++/多态5.png","hash":"3f02ab9d3172a3257badfd70bc279275f0fcfccb","modified":1519381118000},{"_id":"source/images/algorithm/1.png","hash":"dfccaaf4224068c4142780eaa4b28ddb5e5d58ca","modified":1519381118000},{"_id":"source/images/algorithm/D&R4.png","hash":"80242b381be986db06d1724c544a023887017164","modified":1519381118000},{"_id":"source/images/algorithm/D&R7.png","hash":"b0d67c11008a8de14ff5aded42806c0478c0e70a","modified":1519381118000},{"_id":"source/images/algorithm/hash4.png","hash":"90a762587c2028853e91c760a40c36df49ed3350","modified":1519381118000},{"_id":"source/images/algorithm/recursive1.png","hash":"19c3d9ddf40fa5add682b18b6a1e436e04011e76","modified":1519381118000},{"_id":"source/images/algorithm/recursive7.png","hash":"91d0bd94a0b6d5b35b030f0403c9f918fe8c4db0","modified":1519381118000},{"_id":"source/images/algorithm/recursive8.png","hash":"17a223c8ca7f9dc6450385003204a954716ea381","modified":1519381118000},{"_id":"source/images/python/ssh6.png","hash":"2f2ebaa816f01303eb8fff6e0fcf58d21db642af","modified":1519381118000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519381118000},{"_id":"source/images/C++/const1.png","hash":"78e924e66a6f3fd341918e5c702590d1d71524ab","modified":1519381117000},{"_id":"source/images/C++/inline1.png","hash":"1a3602cd513946bceacb9bc4da86afefc0830500","modified":1519381117000},{"_id":"source/images/C++/reference2.png","hash":"eff32104847ef48a81bc95d653f5066f9a90caf6","modified":1519381117000},{"_id":"source/images/C++/reference3.png","hash":"117f240cd05ee9b69f9afe79b846b0efebde825c","modified":1519381117000},{"_id":"source/images/C++/reference4.png","hash":"e7bba72d8fc53dd1e38e73bf4c863eafee0fd0cc","modified":1519381117000},{"_id":"source/images/C++/static1.png","hash":"21998ae0caf07a32051d3657ab0f32dd5bef2d7b","modified":1519381117000},{"_id":"source/images/C++/static3.png","hash":"a85211369bd5a4a195604cb388f0ad310f88aadd","modified":1519381118000},{"_id":"source/images/C++/多态2.png","hash":"dae19ef07d2912ae0360e923e02fdbdcfeaa4afc","modified":1519381118000},{"_id":"source/images/C++/多态3.png","hash":"ef711878526a1169c40bf6602f449fbb648baf35","modified":1519381118000},{"_id":"source/images/C++/多态4.png","hash":"c45392bf7c4c6182e8c7b2ea4f6cb52f22e41365","modified":1519381118000},{"_id":"source/images/C++/多态6.png","hash":"420d1c3194b870acb3760cc16bae099c14648dc7","modified":1519381118000},{"_id":"source/images/C++/多态7.png","hash":"1b2da798192d846771db2a635b7aab6e8122fca0","modified":1519381118000},{"_id":"source/images/C++/多态8.png","hash":"f6fda41bb70738ccf049aafd37cf9d4a57b1d1f9","modified":1519381118000},{"_id":"source/images/algorithm/3.png","hash":"4b182809763b9e39463b80b1ab2f838e427d9024","modified":1519381118000},{"_id":"source/images/algorithm/D&R5.png","hash":"f38c111ff8a68a11ecb0df19a65aa9209d1ad772","modified":1519381118000},{"_id":"source/images/algorithm/hash7.png","hash":"9fa9a8d184a9b1bcd216605efc40a10decb1b77e","modified":1519381118000},{"_id":"source/images/algorithm/recursive9.png","hash":"05a6bcc89bc3856b601fecab5fcd5956d7fb7c64","modified":1519381118000},{"_id":"source/images/python/ssh5.png","hash":"674b024dcc3c270885f0c92a47ec6156aab17ae6","modified":1519381118000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1519381118000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1519381118000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1519381118000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1519381118000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1519381118000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1519381118000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1519381118000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1519381118000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1519381118000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1519381118000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1519381118000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1519381118000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1519381118000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1519381118000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1519381118000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1519381118000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1519381118000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1519381118000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1519381118000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1519381118000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1519381118000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1519381118000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1519381118000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1519381118000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1519381118000},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1519381118000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1519381118000},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1519381118000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1519381118000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1519381118000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1519381118000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1519381118000},{"_id":"source/images/C++/copy1.png","hash":"a83f8a8291d31d7bd395e0dec956e714f0efa781","modified":1519381117000},{"_id":"source/images/C++/reference1.png","hash":"351c074b747fc4526c5c31969df19dbb0fc4a83b","modified":1519381117000},{"_id":"source/images/C++/static2.png","hash":"ed1eb1884b2d3e88f4b9fea347ee5030bb96d1df","modified":1519381118000},{"_id":"source/images/C++/static4.png","hash":"a6b55303daf96f30b4b79e8d63bcde770e9fc7ea","modified":1519381118000},{"_id":"source/images/C++/static5.png","hash":"51463202507bc2e5cbef6a3280b91b812491b8d1","modified":1519381118000},{"_id":"source/images/C++/多态1.png","hash":"5c2ac2e7d49ae61ca1fd4c15de0944060cedfa55","modified":1519381118000},{"_id":"source/images/algorithm/2.png","hash":"2cefd18489f275d8242ec917a91d1cc528d7a715","modified":1519381118000},{"_id":"source/images/algorithm/D&R6.png","hash":"66c3ac22a699f2691c4b34cb5743d714a0ce01b5","modified":1519381118000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519381118000},{"_id":"source/images/algorithm/4.png","hash":"a78e6a5ff755eff2b1de46c532d9d6c962bb1730","modified":1519381118000},{"_id":"source/images/soft classify.png","hash":"46784769e7a09b50fe30ed0c165dc7bc92ab49f3","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1519381118000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1519381118000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1519381118000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1519381118000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1519381118000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1519381118000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1519381118000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1519381118000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519381118000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1519381118000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1519381118000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1519381118000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1519381118000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1519381118000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1519381118000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1519381118000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1519381118000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1519381118000},{"_id":"source/images/hacker.jpg","hash":"67e14331553e3c11a0979004072378aa8fa15ed1","modified":1519381118000},{"_id":"public/404.html","hash":"e1dec277a00ce236bcea2f323430a275b6cd7b60","modified":1519381251786},{"_id":"public/404/index.html","hash":"19ecced2ce2969b5ea3febe6fd982177ccaa1d44","modified":1519381251839},{"_id":"public/404/404.html","hash":"51eb02d57ac2a251958c70af37f1d2179fef2eb4","modified":1519381251839},{"_id":"public/title/index.html","hash":"10f0241b874d93191a9e207f8b4f1fc2423f87b2","modified":1519381251839},{"_id":"public/2017/04/06/hacker/index.html","hash":"89029c3211b90671a1a471de13f53befa4f28174","modified":1519381251839},{"_id":"public/2017/03/20/构造之法第2章/index.html","hash":"6ea519c7f30055e8c332e2a21656f684e971d72c","modified":1519381251839},{"_id":"public/2017/03/19/文章测试/index.html","hash":"bec1afbbcac6fb52768d348de265b67401e7496d","modified":1519381251839},{"_id":"public/archives/index.html","hash":"823165faf94f0771486f96b46fefc5c0ced6fb0f","modified":1519381251839},{"_id":"public/archives/page/2/index.html","hash":"b23bc7f6cbbf747b8d44d84584e9bcce00d2404b","modified":1519381251839},{"_id":"public/archives/page/3/index.html","hash":"ee17b33caff007277b08fe68793717876af84a69","modified":1519381251839},{"_id":"public/archives/2017/index.html","hash":"246971e6cf032d9ffcc11f64d3bff9b965d23204","modified":1519381251839},{"_id":"public/archives/2017/page/2/index.html","hash":"06735885862b198490af779881bc64a7d5b06c59","modified":1519381251839},{"_id":"public/archives/2017/page/3/index.html","hash":"2bcea4ab4fe015143f7c8efdd51fab60eeb3ba50","modified":1519381251839},{"_id":"public/archives/2017/03/index.html","hash":"e5b02170d4a62eb511b699e90ff50aa14af2679c","modified":1519381251839},{"_id":"public/archives/2017/04/index.html","hash":"8a356f74993e2c7a2e9ecbfade3cc94287cdb89f","modified":1519381251840},{"_id":"public/archives/2017/05/index.html","hash":"8891fcb2f0b1d0021b502eca4172859079f08086","modified":1519381251840},{"_id":"public/archives/2018/index.html","hash":"c1f313baf971a22674e7bab48843e6ef758dc08b","modified":1519381251840},{"_id":"public/archives/2018/01/index.html","hash":"59d4e46f1af6360c18b46e5be4c5ff976367210f","modified":1519381251840},{"_id":"public/categories/C/index.html","hash":"dde8ea249762f2735b3dc9a347fc6f12a5d91c91","modified":1519381251840},{"_id":"public/categories/算法/index.html","hash":"4ee02dcccbd854d4c96d38baab7777cbc56172ed","modified":1519381251840},{"_id":"public/categories/Java/index.html","hash":"1104258dba28ad4cec35f1db86f22973dbfc5a03","modified":1519381251840},{"_id":"public/categories/python/index.html","hash":"3ce46bca529f349a4bcfdc0ef4312b1b31d14a0c","modified":1519381251840},{"_id":"public/2018/01/15/java/第二章创建和销毁对象/index.html","hash":"88fb763b889eb70bac3e15b17e268395ee0ee04f","modified":1519381251840},{"_id":"public/2017/05/31/C++/静态对象/index.html","hash":"1cf654e86c262d556b667c850e58e6acfb240dce","modified":1519381251840},{"_id":"public/2017/05/25/algorithm/散列表/index.html","hash":"e542377a7589e682e06f8f2fd48b5844fde4b57f","modified":1519381251840},{"_id":"public/2017/05/22/C++/拷贝构造函数/index.html","hash":"839b58038c467afb18b99a26da0bb1204e45c5d5","modified":1519381251840},{"_id":"public/2017/05/17/algorithm/快速排序/index.html","hash":"93c0c39a2049d0e17fe5ede35e5d86c7f34570d5","modified":1519381251840},{"_id":"public/2017/05/15/algorithm/递归/index.html","hash":"fcc07500ad960ea1a7de47b8e90489ec62950bab","modified":1519381251840},{"_id":"public/2017/05/09/C++/多态/index.html","hash":"a16778853a8e60d026cdbbe4178a54add6847a9e","modified":1519381251840},{"_id":"public/2017/05/09/C++/reference/index.html","hash":"8a63a56a310f2aad66224dc60f0246d8704f0430","modified":1519381251840},{"_id":"public/2017/05/05/algorithm/选择排序/index.html","hash":"2047dfd7a924f6d72360c794268b284cb15296dd","modified":1519381251840},{"_id":"public/2017/05/05/C++/Const/index.html","hash":"c5a47d5e8f81f5be4360a4de757f1aad87fd1c7e","modified":1519381251840},{"_id":"public/2017/05/01/algorithm/算法/index.html","hash":"3099c5d39898d711a2d1a0898c1b7e667c036688","modified":1519381251840},{"_id":"public/2017/04/25/C++/C++内联函数/index.html","hash":"c01e428d968c21b7b57fa82d0e1653fff8cd65e4","modified":1519381251840},{"_id":"public/2017/04/24/python/SSHClient/index.html","hash":"cf007ae3cbb3d582dc09f746c78dbd17bf69f720","modified":1519381251841},{"_id":"public/2017/04/23/C++/inherit/index.html","hash":"e301b8a7561ea39b26b80184d8eb2f65d51bfde1","modified":1519381251841},{"_id":"public/2017/04/21/python/inherit/index.html","hash":"529ef568dadc5766930c072807e2bf1eb75c439d","modified":1519381251841},{"_id":"public/2017/04/10/测试驱动开发/index.html","hash":"4d3fe548a08b144bb48d687164d623619b7d8701","modified":1519381251842},{"_id":"public/2017/03/24/C语言链表/index.html","hash":"7413c35f3be89bc6435acca6ce85f2b15f9786ea","modified":1519381251842},{"_id":"public/2017/03/20/构造之法第5章/index.html","hash":"7bd04614b724d9c8ca4110143f7b7754070d4574","modified":1519381251842},{"_id":"public/2017/03/19/读构建之法体会/index.html","hash":"d3c7c6a0642a904cb4ed2d1a9b9b1d248cd04c8c","modified":1519381251842},{"_id":"public/index.html","hash":"59f41b1ae1f8afaa37cfc0e35a0f5bf4e92cdaeb","modified":1519381251842},{"_id":"public/page/2/index.html","hash":"da524863488a94b12837698a46112dc2115666c7","modified":1519381251842},{"_id":"public/page/3/index.html","hash":"fdda4e2a54c44721d4cdce8a2a27e0d420a2550c","modified":1519381251842},{"_id":"public/CNAME","hash":"4f750f9803f8b00b70f313f29448179491ee0681","modified":1519381251842},{"_id":"public/images/jenius.jpeg","hash":"5d39dc47580954bfe3100f5de942eedb51b4dffe","modified":1519381251842},{"_id":"public/images/object.jpeg","hash":"bf33da4cebb20a2a70b53953bb62cd18dcedc2e5","modified":1519381251842},{"_id":"public/images/result.jpeg","hash":"875b39ee99e86cb703179e940d040c99f4e7cd2f","modified":1519381251842},{"_id":"public/images/namehiding.png","hash":"48ded6110de9e272b1a9a4655753d1caee8cfc92","modified":1519381251842},{"_id":"public/images/v.jpg","hash":"e55e0db620b6f13f9b9bf1345cfb160e6bc7cb36","modified":1519381251842},{"_id":"public/images/x.jpg","hash":"62f2395f13310d950a0c182f04702693bf8fde2c","modified":1519381251842},{"_id":"public/images/shouji.png","hash":"1e23085cc0cb451657ed5a9498e22bc4f1a16590","modified":1519381251842},{"_id":"public/images/C++/const3.png","hash":"0eeb36ca4fd815cd88d90635523ef92b0b9c62c5","modified":1519381251842},{"_id":"public/images/C++/const2.png","hash":"e2dcce255919227a3248de5f443b97d72a9c96b6","modified":1519381251842},{"_id":"public/images/C++/const4.png","hash":"219d0e0e08f0174eb0b41bfe97567b34be1713a2","modified":1519381251842},{"_id":"public/images/C++/多态9.png","hash":"2361a3624048ab3f00ab1922176d2543c2afd28d","modified":1519381251842},{"_id":"public/images/algorithm/D&R1.png","hash":"50b2b0b7437e2eb37a38a284f4093defd12db0ca","modified":1519381251843},{"_id":"public/images/algorithm/D&R2.png","hash":"3fa1497d7522414b6841d45c754bee3458289047","modified":1519381251843},{"_id":"public/images/algorithm/D&R3.png","hash":"1aaf17c63573dcf128a9d42e61c86658e1d83a19","modified":1519381251843},{"_id":"public/images/algorithm/hash1.png","hash":"4e4d7c39fc207d18c3c0bb0762ca948d1a9fe0cd","modified":1519381251843},{"_id":"public/images/algorithm/hash2.png","hash":"387e8096cfdaeb8bb2795387d9421bd62264d4eb","modified":1519381251843},{"_id":"public/images/algorithm/hash3.png","hash":"9b1b44b6071b140e4413cbeeeaff53fd3e5cc48b","modified":1519381251843},{"_id":"public/images/algorithm/hash6.png","hash":"199856bb0e9e90a26f4efeab33e8eabbbb328245","modified":1519381251843},{"_id":"public/images/algorithm/hash5.png","hash":"8037f827b10d9e55110c284d422447ac1ab25fda","modified":1519381251843},{"_id":"public/images/algorithm/hash8.png","hash":"60432e4e650fe90ee30a00c60a13c308d508f071","modified":1519381251843},{"_id":"public/images/algorithm/lyf.png","hash":"787d1f32b38aa3c95fdabf2b8cf769d58924d4bf","modified":1519381251843},{"_id":"public/images/algorithm/recursive2.png","hash":"d176bca37955172a2e06306f2eabede44461bee6","modified":1519381251843},{"_id":"public/images/algorithm/recursive3.png","hash":"10e78967e83b9a2ddddefefe8c8db5807e755311","modified":1519381251843},{"_id":"public/images/algorithm/recursive4.png","hash":"6009f0714c04a41e536f6b1d70591acdf2f3dacc","modified":1519381251843},{"_id":"public/images/algorithm/recursive5.png","hash":"cc3f4e5d2f1a2fbac83efe1112cb055117ab19b3","modified":1519381251843},{"_id":"public/images/algorithm/recursive6.png","hash":"6ce36309795ab99c4b252b06cb11387b6f959891","modified":1519381251843},{"_id":"public/images/python/quesheng.jpeg","hash":"6f8d1879f4cbf9703e3817a8458e6b655d1bb840","modified":1519381251843},{"_id":"public/images/python/ssh1.png","hash":"9618f989bb280fa847d0896c355d4149d702af6d","modified":1519381251843},{"_id":"public/images/python/ssh2.png","hash":"4ad24129fa8b71077e75dd8e196f6f7a1b71cf37","modified":1519381251843},{"_id":"public/images/python/ssh4.png","hash":"9ed297ca96e9790c91b6cf74a509d8482c515ca9","modified":1519381251843},{"_id":"public/images/python/ssh7.png","hash":"f9190bc4f99f7a8d6e4d343f5f951db75cd8e411","modified":1519381251843},{"_id":"public/images/python/ssh3.png","hash":"aa08426da30f93f0303116372be45fd13e36e0e8","modified":1519381251843},{"_id":"public/images/python/ssh8.png","hash":"01a7ac96333a658e9421d19c0756c606c36cd734","modified":1519381251843},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1519381251843},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1519381251844},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1519381251844},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1519381251844},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1519381251844},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1519381251844},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1519381251844},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1519381251844},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519381251844},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1519381251844},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519381251844},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1519381251844},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1519381251844},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1519381251844},{"_id":"public/favicon.ico","hash":"c020c0be2d7627f2356b32659f32be6febcc2620","modified":1519381252723},{"_id":"public/images/avatar.jpg","hash":"f405e9b933f8528a205d7aa3a0a90c864b2b0927","modified":1519381252723},{"_id":"public/images/waterfall.png","hash":"e8d4535dad777ba3d54acbff743eda0d38d5510e","modified":1519381252724},{"_id":"public/images/xieafterupdate.png","hash":"c6e44c0821dcbaa2d16757bcbde34b2415938dcb","modified":1519381252725},{"_id":"public/images/C++/inline2.png","hash":"aef983dda57441b039c1a3c8cb9e7d9ca904d4e5","modified":1519381252725},{"_id":"public/images/C++/多态5.png","hash":"3f02ab9d3172a3257badfd70bc279275f0fcfccb","modified":1519381252725},{"_id":"public/images/algorithm/1.png","hash":"dfccaaf4224068c4142780eaa4b28ddb5e5d58ca","modified":1519381252725},{"_id":"public/images/algorithm/D&R4.png","hash":"80242b381be986db06d1724c544a023887017164","modified":1519381252725},{"_id":"public/images/algorithm/D&R7.png","hash":"b0d67c11008a8de14ff5aded42806c0478c0e70a","modified":1519381252725},{"_id":"public/images/algorithm/hash4.png","hash":"90a762587c2028853e91c760a40c36df49ed3350","modified":1519381252725},{"_id":"public/images/algorithm/recursive1.png","hash":"19c3d9ddf40fa5add682b18b6a1e436e04011e76","modified":1519381252725},{"_id":"public/images/algorithm/recursive7.png","hash":"91d0bd94a0b6d5b35b030f0403c9f918fe8c4db0","modified":1519381252725},{"_id":"public/images/algorithm/recursive8.png","hash":"17a223c8ca7f9dc6450385003204a954716ea381","modified":1519381252725},{"_id":"public/images/python/ssh6.png","hash":"2f2ebaa816f01303eb8fff6e0fcf58d21db642af","modified":1519381252725},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1519381252725},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1519381252725},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1519381252725},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1519381252726},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1519381252726},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1519381252726},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1519381252726},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1519381252726},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1519381252726},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1519381252726},{"_id":"public/css/main.css","hash":"54bce7dd9dc3b639747c00b408617650a1ee68a7","modified":1519381252760},{"_id":"public/images/guanliao.png","hash":"1f5ce00fbb4a29458c3f5355af306954de56942f","modified":1519381252760},{"_id":"public/images/C++/const1.png","hash":"78e924e66a6f3fd341918e5c702590d1d71524ab","modified":1519381252776},{"_id":"public/images/C++/inline1.png","hash":"1a3602cd513946bceacb9bc4da86afefc0830500","modified":1519381252776},{"_id":"public/images/C++/reference2.png","hash":"eff32104847ef48a81bc95d653f5066f9a90caf6","modified":1519381252776},{"_id":"public/images/C++/reference3.png","hash":"117f240cd05ee9b69f9afe79b846b0efebde825c","modified":1519381252776},{"_id":"public/images/C++/static1.png","hash":"21998ae0caf07a32051d3657ab0f32dd5bef2d7b","modified":1519381252776},{"_id":"public/images/C++/reference4.png","hash":"e7bba72d8fc53dd1e38e73bf4c863eafee0fd0cc","modified":1519381252776},{"_id":"public/images/C++/static3.png","hash":"a85211369bd5a4a195604cb388f0ad310f88aadd","modified":1519381252776},{"_id":"public/images/C++/多态2.png","hash":"dae19ef07d2912ae0360e923e02fdbdcfeaa4afc","modified":1519381252776},{"_id":"public/images/C++/多态3.png","hash":"ef711878526a1169c40bf6602f449fbb648baf35","modified":1519381252776},{"_id":"public/images/C++/多态4.png","hash":"c45392bf7c4c6182e8c7b2ea4f6cb52f22e41365","modified":1519381252776},{"_id":"public/images/C++/多态6.png","hash":"420d1c3194b870acb3760cc16bae099c14648dc7","modified":1519381252776},{"_id":"public/images/C++/多态7.png","hash":"1b2da798192d846771db2a635b7aab6e8122fca0","modified":1519381252777},{"_id":"public/images/C++/多态8.png","hash":"f6fda41bb70738ccf049aafd37cf9d4a57b1d1f9","modified":1519381252777},{"_id":"public/images/algorithm/3.png","hash":"4b182809763b9e39463b80b1ab2f838e427d9024","modified":1519381252777},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1519381252777},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1519381252778},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1519381252778},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1519381252779},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1519381252789},{"_id":"public/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1519381252789},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1519381252789},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1519381252789},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1519381252789},{"_id":"public/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1519381252789},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1519381252790},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1519381252790},{"_id":"public/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1519381252790},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1519381252790},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1519381252790},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1519381252790},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1519381252790},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1519381252790},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1519381252790},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1519381252790},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1519381252790},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1519381252790},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1519381252790},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1519381252790},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1519381252790},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1519381252790},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1519381252790},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1519381252790},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1519381252790},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1519381252790},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1519381252790},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1519381252790},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1519381252791},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1519381252791},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1519381252791},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1519381252791},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1519381252791},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519381252791},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1519381252791},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519381252791},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1519381252791},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1519381252791},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1519381252791},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1519381252791},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1519381252791},{"_id":"public/images/algorithm/D&R5.png","hash":"f38c111ff8a68a11ecb0df19a65aa9209d1ad772","modified":1519381252791},{"_id":"public/images/algorithm/hash7.png","hash":"9fa9a8d184a9b1bcd216605efc40a10decb1b77e","modified":1519381252791},{"_id":"public/images/algorithm/recursive9.png","hash":"05a6bcc89bc3856b601fecab5fcd5956d7fb7c64","modified":1519381252792},{"_id":"public/images/python/ssh5.png","hash":"674b024dcc3c270885f0c92a47ec6156aab17ae6","modified":1519381252792},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1519381252792},{"_id":"public/images/C++/static2.png","hash":"ed1eb1884b2d3e88f4b9fea347ee5030bb96d1df","modified":1519381252805},{"_id":"public/images/C++/reference1.png","hash":"351c074b747fc4526c5c31969df19dbb0fc4a83b","modified":1519381252805},{"_id":"public/images/C++/copy1.png","hash":"a83f8a8291d31d7bd395e0dec956e714f0efa781","modified":1519381252806},{"_id":"public/images/C++/static4.png","hash":"a6b55303daf96f30b4b79e8d63bcde770e9fc7ea","modified":1519381252806},{"_id":"public/images/C++/static5.png","hash":"51463202507bc2e5cbef6a3280b91b812491b8d1","modified":1519381252809},{"_id":"public/images/C++/多态1.png","hash":"5c2ac2e7d49ae61ca1fd4c15de0944060cedfa55","modified":1519381252809},{"_id":"public/images/algorithm/2.png","hash":"2cefd18489f275d8242ec917a91d1cc528d7a715","modified":1519381252810},{"_id":"public/images/algorithm/D&R6.png","hash":"66c3ac22a699f2691c4b34cb5743d714a0ce01b5","modified":1519381252810},{"_id":"public/images/algorithm/4.png","hash":"a78e6a5ff755eff2b1de46c532d9d6c962bb1730","modified":1519381252825},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1519381252830},{"_id":"public/images/soft classify.png","hash":"46784769e7a09b50fe30ed0c165dc7bc92ab49f3","modified":1519381252839},{"_id":"public/images/hacker.jpg","hash":"67e14331553e3c11a0979004072378aa8fa15ed1","modified":1519381252884}],"Category":[{"name":"C++","_id":"cjdzsd6sa000ehhu2rwlyu2qa"},{"name":"算法","_id":"cjdzsd6sy000rhhu2axb5q3d3"},{"name":"Java","_id":"cjdzsd6t90017hhu23dm978o9"},{"name":"python","_id":"cjdzsd6tb001ahhu2zmzslagk"}],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","date":"2018-02-23T10:18:37.000Z","updated":"2018-02-23T10:18:37.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjdzsd6ji0000hhu29bfoaqai","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>\n"},{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Canvas 仿黑客帝国 404 界面</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            overflow: hidden;\n        }\n        #canvas {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <script>\n        function RainBy404(elc, str, size){\n            if(typeof elc == \"string\") elc = document.querySelector(elc);\n\n            // 动画函数\n            var fastAnimation = function (fn) {\n                return requestAnimationFrame ||\n                        webkitRequestAnimationFrame ||\n                        mozRequestAnimationFrame ||\n                        function (callback) {\n                            setTimeout(callback, 1000 / 60);\n                        };\n            }();\n\n            // 文字像素化\n            function str2matrix(str, w, h){\n                var matrix = [];\n                for(var i = 0; i < w; i++){\n                    matrix[i] = [];\n                    for(var j = 0; j < h; j++){\n                        matrix[i][j] = 0;\n                    }\n                }\n\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = w;\n                canvas.height = h;\n                var context = canvas.getContext(\"2d\"),\n                    fontSize = w * 0.3 / str.length,\n                    imgData = [];\n\n                context.fillStyle = \"white\";\n                context.fillRect(0, 0, w, h);\n\n                context.fillStyle = \"black\";\n                context.font = fontSize + \"px Calibri\";\n                context.textBaseline = \"middle\";\n                context.fillText(str, (w - context.measureText(str).width) / 2, h / 2);\n\n                try {\n                    imgData = context.getImageData(0 ,0, w, h).data;\n                } catch(e){\n\n                }\n\n                for(var i = 0; i < imgData.length; i+=4){\n                    r = imgData[i];\n                    g = imgData[i+1];\n                    b = imgData[i+2];\n                    gray = r*0.2126 + g*0.7152 + b*0.0722; //RGB转YUV\n\n                    matrix[parseInt(i / 4 % w)][parseInt(i / 4 / w)] = gray < 250 ? 1 : 0;\n                }\n\n                return matrix;\n            }\n\n            // 定义水滴对象\n            function Drop(str, x, y, rows){\n                this.i = 0;\n                this.s = Math.random()*10+\"\";\n                this.x = x || 0;\n                this.y = y || 0;\n                this.rows = rows;\n            }\n            Drop.prototype = {\n                constructor: Drop,\n\n                getChar: function(){\n                    return this.s.charAt(this.i % this.s.length);\n                },\n\n                reset: function(){\n                    this.i = 0;\n                    this.y = 0;\n                },\n\n                drop: function(){\n                    this.i++;\n                    this.y++;\n                    if(this.y > this.rows && Math.random() > 0.975) this.reset();\n                }\n            }\n\n            // 初始化参数\n            var cols = Math.round(elc.width / size);\n            var rows = Math.round(elc.height / size);\n            var drops = [];\n            var matrix = null;\n            var context = elc.getContext(\"2d\");\n\n            function draw(){\n                // 画布覆盖\n                context.fillStyle = \"rgba(0,0,0,0.05)\";\n                context.fillRect(0, 0, elc.width, elc.height);\n\n                // 水滴描绘\n                drops.forEach(function(drop){\n                    context.fillStyle = (matrix && matrix[drop.x][drop.y]) ? \"red\" : \"rgb(0, 97, 14)\";\n                    context.font = size + \"px Calibri\";\n                    context.fillText(drop.getChar(), drop.x * size, drop.y * size);\n                    drop.drop();\n                })\n\n                // 重复绘制\n                fastAnimation(draw);\n            }\n\n            function start(){\n                // 生成水滴\n                for(var i = 0; i < cols; i++){\n                    var drop = new Drop(str, i, 0, rows);\n                    drops.push(drop);\n                }\n\n                // 生成像素信息\n                matrix = str2matrix(str, cols, rows);\n\n                // 画布覆盖\n                context.fillStyle = \"black\";\n                context.fillRect(0, 0, elc.width, elc.height);\n                // 重复绘制\n                draw();\n            }\n\n            return {\n                start: start\n            }\n        }\n\n        var canvas = document.querySelector(\"#canvas\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        var rain = new RainBy404(canvas, \"404\", 12);\n        rain.start();\n    </script>\n</body>\n</html>\n","source":"404/index.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Canvas 仿黑客帝国 404 界面</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            overflow: hidden;\n        }\n        #canvas {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <script>\n        function RainBy404(elc, str, size){\n            if(typeof elc == \"string\") elc = document.querySelector(elc);\n\n            // 动画函数\n            var fastAnimation = function (fn) {\n                return requestAnimationFrame ||\n                        webkitRequestAnimationFrame ||\n                        mozRequestAnimationFrame ||\n                        function (callback) {\n                            setTimeout(callback, 1000 / 60);\n                        };\n            }();\n\n            // 文字像素化\n            function str2matrix(str, w, h){\n                var matrix = [];\n                for(var i = 0; i < w; i++){\n                    matrix[i] = [];\n                    for(var j = 0; j < h; j++){\n                        matrix[i][j] = 0;\n                    }\n                }\n\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = w;\n                canvas.height = h;\n                var context = canvas.getContext(\"2d\"),\n                    fontSize = w * 0.3 / str.length,\n                    imgData = [];\n\n                context.fillStyle = \"white\";\n                context.fillRect(0, 0, w, h);\n\n                context.fillStyle = \"black\";\n                context.font = fontSize + \"px Calibri\";\n                context.textBaseline = \"middle\";\n                context.fillText(str, (w - context.measureText(str).width) / 2, h / 2);\n\n                try {\n                    imgData = context.getImageData(0 ,0, w, h).data;\n                } catch(e){\n\n                }\n\n                for(var i = 0; i < imgData.length; i+=4){\n                    r = imgData[i];\n                    g = imgData[i+1];\n                    b = imgData[i+2];\n                    gray = r*0.2126 + g*0.7152 + b*0.0722; //RGB转YUV\n\n                    matrix[parseInt(i / 4 % w)][parseInt(i / 4 / w)] = gray < 250 ? 1 : 0;\n                }\n\n                return matrix;\n            }\n\n            // 定义水滴对象\n            function Drop(str, x, y, rows){\n                this.i = 0;\n                this.s = Math.random()*10+\"\";\n                this.x = x || 0;\n                this.y = y || 0;\n                this.rows = rows;\n            }\n            Drop.prototype = {\n                constructor: Drop,\n\n                getChar: function(){\n                    return this.s.charAt(this.i % this.s.length);\n                },\n\n                reset: function(){\n                    this.i = 0;\n                    this.y = 0;\n                },\n\n                drop: function(){\n                    this.i++;\n                    this.y++;\n                    if(this.y > this.rows && Math.random() > 0.975) this.reset();\n                }\n            }\n\n            // 初始化参数\n            var cols = Math.round(elc.width / size);\n            var rows = Math.round(elc.height / size);\n            var drops = [];\n            var matrix = null;\n            var context = elc.getContext(\"2d\");\n\n            function draw(){\n                // 画布覆盖\n                context.fillStyle = \"rgba(0,0,0,0.05)\";\n                context.fillRect(0, 0, elc.width, elc.height);\n\n                // 水滴描绘\n                drops.forEach(function(drop){\n                    context.fillStyle = (matrix && matrix[drop.x][drop.y]) ? \"red\" : \"rgb(0, 97, 14)\";\n                    context.font = size + \"px Calibri\";\n                    context.fillText(drop.getChar(), drop.x * size, drop.y * size);\n                    drop.drop();\n                })\n\n                // 重复绘制\n                fastAnimation(draw);\n            }\n\n            function start(){\n                // 生成水滴\n                for(var i = 0; i < cols; i++){\n                    var drop = new Drop(str, i, 0, rows);\n                    drops.push(drop);\n                }\n\n                // 生成像素信息\n                matrix = str2matrix(str, cols, rows);\n\n                // 画布覆盖\n                context.fillStyle = \"black\";\n                context.fillRect(0, 0, elc.width, elc.height);\n                // 重复绘制\n                draw();\n            }\n\n            return {\n                start: start\n            }\n        }\n\n        var canvas = document.querySelector(\"#canvas\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        var rain = new RainBy404(canvas, \"404\", 12);\n        rain.start();\n    </script>\n</body>\n</html>\n","date":"2018-02-23T10:18:37.000Z","updated":"2018-02-23T10:18:37.000Z","path":"404/index.html","title":"","comments":1,"layout":"page","_id":"cjdzsd6pc0001hhu2bvklkqsb","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Canvas 仿黑客帝国 404 界面</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            overflow: hidden;\n        }\n        #canvas {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <script>\n        function RainBy404(elc, str, size){\n            if(typeof elc == \"string\") elc = document.querySelector(elc);\n\n            // 动画函数\n            var fastAnimation = function (fn) {\n                return requestAnimationFrame ||\n                        webkitRequestAnimationFrame ||\n                        mozRequestAnimationFrame ||\n                        function (callback) {\n                            setTimeout(callback, 1000 / 60);\n                        };\n            }();\n\n            // 文字像素化\n            function str2matrix(str, w, h){\n                var matrix = [];\n                for(var i = 0; i < w; i++){\n                    matrix[i] = [];\n                    for(var j = 0; j < h; j++){\n                        matrix[i][j] = 0;\n                    }\n                }\n\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = w;\n                canvas.height = h;\n                var context = canvas.getContext(\"2d\"),\n                    fontSize = w * 0.3 / str.length,\n                    imgData = [];\n\n                context.fillStyle = \"white\";\n                context.fillRect(0, 0, w, h);\n\n                context.fillStyle = \"black\";\n                context.font = fontSize + \"px Calibri\";\n                context.textBaseline = \"middle\";\n                context.fillText(str, (w - context.measureText(str).width) / 2, h / 2);\n\n                try {\n                    imgData = context.getImageData(0 ,0, w, h).data;\n                } catch(e){\n\n                }\n\n                for(var i = 0; i < imgData.length; i+=4){\n                    r = imgData[i];\n                    g = imgData[i+1];\n                    b = imgData[i+2];\n                    gray = r*0.2126 + g*0.7152 + b*0.0722; //RGB转YUV\n\n                    matrix[parseInt(i / 4 % w)][parseInt(i / 4 / w)] = gray < 250 ? 1 : 0;\n                }\n\n                return matrix;\n            }\n\n            // 定义水滴对象\n            function Drop(str, x, y, rows){\n                this.i = 0;\n                this.s = Math.random()*10+\"\";\n                this.x = x || 0;\n                this.y = y || 0;\n                this.rows = rows;\n            }\n            Drop.prototype = {\n                constructor: Drop,\n\n                getChar: function(){\n                    return this.s.charAt(this.i % this.s.length);\n                },\n\n                reset: function(){\n                    this.i = 0;\n                    this.y = 0;\n                },\n\n                drop: function(){\n                    this.i++;\n                    this.y++;\n                    if(this.y > this.rows && Math.random() > 0.975) this.reset();\n                }\n            }\n\n            // 初始化参数\n            var cols = Math.round(elc.width / size);\n            var rows = Math.round(elc.height / size);\n            var drops = [];\n            var matrix = null;\n            var context = elc.getContext(\"2d\");\n\n            function draw(){\n                // 画布覆盖\n                context.fillStyle = \"rgba(0,0,0,0.05)\";\n                context.fillRect(0, 0, elc.width, elc.height);\n\n                // 水滴描绘\n                drops.forEach(function(drop){\n                    context.fillStyle = (matrix && matrix[drop.x][drop.y]) ? \"red\" : \"rgb(0, 97, 14)\";\n                    context.font = size + \"px Calibri\";\n                    context.fillText(drop.getChar(), drop.x * size, drop.y * size);\n                    drop.drop();\n                })\n\n                // 重复绘制\n                fastAnimation(draw);\n            }\n\n            function start(){\n                // 生成水滴\n                for(var i = 0; i < cols; i++){\n                    var drop = new Drop(str, i, 0, rows);\n                    drops.push(drop);\n                }\n\n                // 生成像素信息\n                matrix = str2matrix(str, cols, rows);\n\n                // 画布覆盖\n                context.fillStyle = \"black\";\n                context.fillRect(0, 0, elc.width, elc.height);\n                // 重复绘制\n                draw();\n            }\n\n            return {\n                start: start\n            }\n        }\n\n        var canvas = document.querySelector(\"#canvas\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        var rain = new RainBy404(canvas, \"404\", 12);\n        rain.start();\n    </script>\n</body>\n</html>\n","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Canvas 仿黑客帝国 404 界面</title>\n    <style>\n        html, body {\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            overflow: hidden;\n        }\n        #canvas {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n<body>\n    <canvas id=\"canvas\"></canvas>\n    <script>\n        function RainBy404(elc, str, size){\n            if(typeof elc == \"string\") elc = document.querySelector(elc);\n\n            // 动画函数\n            var fastAnimation = function (fn) {\n                return requestAnimationFrame ||\n                        webkitRequestAnimationFrame ||\n                        mozRequestAnimationFrame ||\n                        function (callback) {\n                            setTimeout(callback, 1000 / 60);\n                        };\n            }();\n\n            // 文字像素化\n            function str2matrix(str, w, h){\n                var matrix = [];\n                for(var i = 0; i < w; i++){\n                    matrix[i] = [];\n                    for(var j = 0; j < h; j++){\n                        matrix[i][j] = 0;\n                    }\n                }\n\n                var canvas = document.createElement(\"canvas\");\n                canvas.width = w;\n                canvas.height = h;\n                var context = canvas.getContext(\"2d\"),\n                    fontSize = w * 0.3 / str.length,\n                    imgData = [];\n\n                context.fillStyle = \"white\";\n                context.fillRect(0, 0, w, h);\n\n                context.fillStyle = \"black\";\n                context.font = fontSize + \"px Calibri\";\n                context.textBaseline = \"middle\";\n                context.fillText(str, (w - context.measureText(str).width) / 2, h / 2);\n\n                try {\n                    imgData = context.getImageData(0 ,0, w, h).data;\n                } catch(e){\n\n                }\n\n                for(var i = 0; i < imgData.length; i+=4){\n                    r = imgData[i];\n                    g = imgData[i+1];\n                    b = imgData[i+2];\n                    gray = r*0.2126 + g*0.7152 + b*0.0722; //RGB转YUV\n\n                    matrix[parseInt(i / 4 % w)][parseInt(i / 4 / w)] = gray < 250 ? 1 : 0;\n                }\n\n                return matrix;\n            }\n\n            // 定义水滴对象\n            function Drop(str, x, y, rows){\n                this.i = 0;\n                this.s = Math.random()*10+\"\";\n                this.x = x || 0;\n                this.y = y || 0;\n                this.rows = rows;\n            }\n            Drop.prototype = {\n                constructor: Drop,\n\n                getChar: function(){\n                    return this.s.charAt(this.i % this.s.length);\n                },\n\n                reset: function(){\n                    this.i = 0;\n                    this.y = 0;\n                },\n\n                drop: function(){\n                    this.i++;\n                    this.y++;\n                    if(this.y > this.rows && Math.random() > 0.975) this.reset();\n                }\n            }\n\n            // 初始化参数\n            var cols = Math.round(elc.width / size);\n            var rows = Math.round(elc.height / size);\n            var drops = [];\n            var matrix = null;\n            var context = elc.getContext(\"2d\");\n\n            function draw(){\n                // 画布覆盖\n                context.fillStyle = \"rgba(0,0,0,0.05)\";\n                context.fillRect(0, 0, elc.width, elc.height);\n\n                // 水滴描绘\n                drops.forEach(function(drop){\n                    context.fillStyle = (matrix && matrix[drop.x][drop.y]) ? \"red\" : \"rgb(0, 97, 14)\";\n                    context.font = size + \"px Calibri\";\n                    context.fillText(drop.getChar(), drop.x * size, drop.y * size);\n                    drop.drop();\n                })\n\n                // 重复绘制\n                fastAnimation(draw);\n            }\n\n            function start(){\n                // 生成水滴\n                for(var i = 0; i < cols; i++){\n                    var drop = new Drop(str, i, 0, rows);\n                    drops.push(drop);\n                }\n\n                // 生成像素信息\n                matrix = str2matrix(str, cols, rows);\n\n                // 画布覆盖\n                context.fillStyle = \"black\";\n                context.fillRect(0, 0, elc.width, elc.height);\n                // 重复绘制\n                draw();\n            }\n\n            return {\n                start: start\n            }\n        }\n\n        var canvas = document.querySelector(\"#canvas\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        var rain = new RainBy404(canvas, \"404\", 12);\n        rain.start();\n    </script>\n</body>\n</html>\n"},{"_content":"<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>\n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n","source":"404/404.html","raw":"<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>\n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n","date":"2018-02-23T10:18:37.000Z","updated":"2018-02-23T10:18:37.000Z","path":"404/404.html","title":"","comments":1,"layout":"page","_id":"cjdzsd6pj0003hhu2g4bqzi8j","content":"<html>\n    <head>\n         <meta charset=\"UTF-8\">\n         <title>404</title>\n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n","excerpt":"","more":"<html>\n    <head>\n         <meta charset=\"UTF-8\" />\n         <title>404</title>\n    </head>\n    <body>\n         <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n"},{"title":"404","date":"2017-03-21T05:21:56.000Z","toc":false,"comments":0,"_content":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2017-03-21 13:21:56\ntoc: false\ncomments: false\npermalink: /404\n---\n<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n","updated":"2018-02-23T10:18:37.000Z","path":"/404.html","layout":"page","_id":"cjdzsd6po0005hhu2jy7ywgbt","content":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n","excerpt":"","more":"<script type=\"text/javascript\" src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n"},{"title":"title","date":"2017-03-18T01:48:38.000Z","_content":"# hello","source":"title/index.md","raw":"---\ntitle: title\ndate: 2017-03-18 09:48:38\n---\n# hello","updated":"2018-02-23T10:18:38.000Z","path":"title/index.html","comments":1,"layout":"page","_id":"cjdzsd6pr0007hhu2en69j2re","content":"<h1 id=\"hello\"><a href=\"#hello\" class=\"headerlink\" title=\"hello\"></a>hello</h1>","excerpt":"","more":"<h1 id=\"hello\"><a href=\"#hello\" class=\"headerlink\" title=\"hello\"></a>hello</h1>"}],"Post":[{"title":"C语言链表","date":"2017-03-24T10:06:43.000Z","_content":"## 链表\n## 代码 linked-list.c\n``` c\n#include \"node.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// typedef struct _node{\n// \tint value;\n// \tstruct _node *next;\n// }Node;\n\ntypedef struct _list{ // 没有做尾指针\n\tNode *head;\n\tNode *tail;\n} List;\n\n\nvoid add(List *list, int number);\nvoid add2(List *list, int number);\n\nint main(int argc, char const *argv[])\n{\n\tList list;\n\tlist.head = list.tail = NULL;\n\tint number;\n\tdo{\n\t\tscanf(\"%d\",&number);\n\t\tif(number != -1){\n\t\t\tadd2(&list,number);\n\t\t}\n\t}while(number != -1);\n\tfor (Node *q = list.head;q;q=q->next){\n\t\tprintf(\"%d\",q->value);\n\t}\n\treturn 0;\n}\n\nvoid add(List *list, int number){\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tNode *last = list->head;\n\tif(last){\n\t\twhile(last->next){\n\t\t\tlast = last->next;\n\t\t}\n\t\tlast->next = p;\n\t}else{\n\t\tlist->head = p;\n\t}\n\n\n}\n\nvoid add2(List *list, int number){  // 哎，早画图早解决了服了\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tif(list->tail){\n\t\t(list->tail)->next = p;\n\t\tlist->tail = (list->tail)->next;\n\n\t}else{\n\t\tlist->head = list->tail = p;\n\n\t}\n\n}\n```\n这是实现了基本的创建链表功能，有两个版本第一个版本(函数add())与第二个版本(add2())相比，第二个版本是具有为指针的每一次不用从头遍历到尾节点。\n##删除加寻找\n``` c\n#include \"node.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// typedef struct _node{\n// \tint value;\n// \tstruct _node *next;\n// }Node;\n\ntypedef struct _list{ // 没有为检点的版本\n\tNode *head;\n\tNode *tail;\n} List;\n\n// typedef struct _list{\n// \tNode *head;\n// \tNode *tail;\n// } List;\n\n\n\nvoid add(List *list, int number);\nvoid add2(List *list, int number);\nvoid print(List *list);\nvoid queryAndDelete(List *list, int number);\n\nint main(int argc, char const *argv[])\n{\n\tList list;\n\tlist.head = list.tail = NULL;\n\tint number;\n\tdo{\n\t\tscanf(\"%d\",&number);\n\t\tif(number != -1){\n\t\t\tadd2(&list,number);\n\t\t}\n\t}while(number != -1);\n\tprint(&list);\n\tscanf(\"%d\",&number);\n\tqueryAndDelete(&list,number);\n\tprint(&list);\n\treturn 0;\n}\n\nvoid add(List *list, int number){\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tNode *last = list->head;\n\tif(last){\n\t\twhile(last->next){\n\t\t\tlast = last->next;\n\t\t}\n\t\tlast->next = p;\n\t}else{\n\t\tlist->head = p;\n\t}\n\n\n}\n\nvoid add2(List *list, int number){  // 哎，早画图早解决了服了\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tif(list->tail){\n\t\t(list->tail)->next = p;\n\t\tlist->tail = (list->tail)->next;\n\n\t}else{\n\t\tlist->head = list->tail = p;\n\n\t}\n\n}\n\nvoid print(List *list){\n\tfor (Node *q = list->head;q;q=q->next){\n\t\tprintf(\"%d\\t\",q->value);\n\t}\n\tprintf(\"\\n\");\n}\nvoid queryAndDelete(List *list,int number){\n\tint isFound = 0;\n\tNode *p = NULL;\n\tfor ( Node *q = list->head;q;p = q,q=q->next){\n\t\tif(q->value == number){\n\t\t\tisFound = 1;\n\t\t\tif(q){\n\t\t\t\tp->next = q->next;\n\t\t\t}else{\n\t\t\t\t(list->head)->next = q->next;\n\t\t\t}\n\t\t\tfree(q);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(isFound){\n\t\tprintf(\"找到了\\n\");\n\t}\n}\n\n```\n","source":"_posts/C语言链表.md","raw":"---\ntitle: C语言链表\ndate: 2017-03-24 18:06:43\ntags:\n---\n## 链表\n## 代码 linked-list.c\n``` c\n#include \"node.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// typedef struct _node{\n// \tint value;\n// \tstruct _node *next;\n// }Node;\n\ntypedef struct _list{ // 没有做尾指针\n\tNode *head;\n\tNode *tail;\n} List;\n\n\nvoid add(List *list, int number);\nvoid add2(List *list, int number);\n\nint main(int argc, char const *argv[])\n{\n\tList list;\n\tlist.head = list.tail = NULL;\n\tint number;\n\tdo{\n\t\tscanf(\"%d\",&number);\n\t\tif(number != -1){\n\t\t\tadd2(&list,number);\n\t\t}\n\t}while(number != -1);\n\tfor (Node *q = list.head;q;q=q->next){\n\t\tprintf(\"%d\",q->value);\n\t}\n\treturn 0;\n}\n\nvoid add(List *list, int number){\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tNode *last = list->head;\n\tif(last){\n\t\twhile(last->next){\n\t\t\tlast = last->next;\n\t\t}\n\t\tlast->next = p;\n\t}else{\n\t\tlist->head = p;\n\t}\n\n\n}\n\nvoid add2(List *list, int number){  // 哎，早画图早解决了服了\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tif(list->tail){\n\t\t(list->tail)->next = p;\n\t\tlist->tail = (list->tail)->next;\n\n\t}else{\n\t\tlist->head = list->tail = p;\n\n\t}\n\n}\n```\n这是实现了基本的创建链表功能，有两个版本第一个版本(函数add())与第二个版本(add2())相比，第二个版本是具有为指针的每一次不用从头遍历到尾节点。\n##删除加寻找\n``` c\n#include \"node.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n// typedef struct _node{\n// \tint value;\n// \tstruct _node *next;\n// }Node;\n\ntypedef struct _list{ // 没有为检点的版本\n\tNode *head;\n\tNode *tail;\n} List;\n\n// typedef struct _list{\n// \tNode *head;\n// \tNode *tail;\n// } List;\n\n\n\nvoid add(List *list, int number);\nvoid add2(List *list, int number);\nvoid print(List *list);\nvoid queryAndDelete(List *list, int number);\n\nint main(int argc, char const *argv[])\n{\n\tList list;\n\tlist.head = list.tail = NULL;\n\tint number;\n\tdo{\n\t\tscanf(\"%d\",&number);\n\t\tif(number != -1){\n\t\t\tadd2(&list,number);\n\t\t}\n\t}while(number != -1);\n\tprint(&list);\n\tscanf(\"%d\",&number);\n\tqueryAndDelete(&list,number);\n\tprint(&list);\n\treturn 0;\n}\n\nvoid add(List *list, int number){\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tNode *last = list->head;\n\tif(last){\n\t\twhile(last->next){\n\t\t\tlast = last->next;\n\t\t}\n\t\tlast->next = p;\n\t}else{\n\t\tlist->head = p;\n\t}\n\n\n}\n\nvoid add2(List *list, int number){  // 哎，早画图早解决了服了\n\t// add to linked-list\n\tNode *p = (Node*)malloc(sizeof(Node));\n\tp->value = number;\n\tp->next = NULL;\n\t// find last node\n\tif(list->tail){\n\t\t(list->tail)->next = p;\n\t\tlist->tail = (list->tail)->next;\n\n\t}else{\n\t\tlist->head = list->tail = p;\n\n\t}\n\n}\n\nvoid print(List *list){\n\tfor (Node *q = list->head;q;q=q->next){\n\t\tprintf(\"%d\\t\",q->value);\n\t}\n\tprintf(\"\\n\");\n}\nvoid queryAndDelete(List *list,int number){\n\tint isFound = 0;\n\tNode *p = NULL;\n\tfor ( Node *q = list->head;q;p = q,q=q->next){\n\t\tif(q->value == number){\n\t\t\tisFound = 1;\n\t\t\tif(q){\n\t\t\t\tp->next = q->next;\n\t\t\t}else{\n\t\t\t\t(list->head)->next = q->next;\n\t\t\t}\n\t\t\tfree(q);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(isFound){\n\t\tprintf(\"找到了\\n\");\n\t}\n}\n\n```\n","slug":"C语言链表","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6pe0002hhu2ejau8zyq","content":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h2 id=\"代码-linked-list-c\"><a href=\"#代码-linked-list-c\" class=\"headerlink\" title=\"代码 linked-list.c\"></a>代码 linked-list.c</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"node.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _node&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tint value;</span></div><div class=\"line\"><span class=\"comment\">// \tstruct _node *next;</span></div><div class=\"line\"><span class=\"comment\">// &#125;Node;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _list&#123; <span class=\"comment\">// 没有做尾指针</span></div><div class=\"line\">\tNode *head;</div><div class=\"line\">\tNode *tail;</div><div class=\"line\">&#125; List;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tList <span class=\"built_in\">list</span>;</div><div class=\"line\">\t<span class=\"built_in\">list</span>.head = <span class=\"built_in\">list</span>.tail = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number;</div><div class=\"line\">\t<span class=\"keyword\">do</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(number != <span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\t\tadd2(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;<span class=\"keyword\">while</span>(number != <span class=\"number\">-1</span>);</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Node *q = <span class=\"built_in\">list</span>.head;q;q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,q-&gt;value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\tNode *last = <span class=\"built_in\">list</span>-&gt;head;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(last)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span>(last-&gt;next)&#123;</div><div class=\"line\">\t\t\tlast = last-&gt;next;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlast-&gt;next = p;</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = p;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;  <span class=\"comment\">// 哎，早画图早解决了服了</span></div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;tail)&#123;</div><div class=\"line\">\t\t(<span class=\"built_in\">list</span>-&gt;tail)-&gt;next = p;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;tail = (<span class=\"built_in\">list</span>-&gt;tail)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = p;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是实现了基本的创建链表功能，有两个版本第一个版本(函数add())与第二个版本(add2())相比，第二个版本是具有为指针的每一次不用从头遍历到尾节点。</p>\n<p>##删除加寻找<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"node.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _node&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tint value;</span></div><div class=\"line\"><span class=\"comment\">// \tstruct _node *next;</span></div><div class=\"line\"><span class=\"comment\">// &#125;Node;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _list&#123; <span class=\"comment\">// 没有为检点的版本</span></div><div class=\"line\">\tNode *head;</div><div class=\"line\">\tNode *tail;</div><div class=\"line\">&#125; List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _list&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tNode *head;</span></div><div class=\"line\"><span class=\"comment\">// \tNode *tail;</span></div><div class=\"line\"><span class=\"comment\">// &#125; List;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(List *<span class=\"built_in\">list</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryAndDelete</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tList <span class=\"built_in\">list</span>;</div><div class=\"line\">\t<span class=\"built_in\">list</span>.head = <span class=\"built_in\">list</span>.tail = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number;</div><div class=\"line\">\t<span class=\"keyword\">do</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(number != <span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\t\tadd2(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;<span class=\"keyword\">while</span>(number != <span class=\"number\">-1</span>);</div><div class=\"line\">\tprint(&amp;<span class=\"built_in\">list</span>);</div><div class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\tqueryAndDelete(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\tprint(&amp;<span class=\"built_in\">list</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\tNode *last = <span class=\"built_in\">list</span>-&gt;head;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(last)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span>(last-&gt;next)&#123;</div><div class=\"line\">\t\t\tlast = last-&gt;next;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlast-&gt;next = p;</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = p;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;  <span class=\"comment\">// 哎，早画图早解决了服了</span></div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;tail)&#123;</div><div class=\"line\">\t\t(<span class=\"built_in\">list</span>-&gt;tail)-&gt;next = p;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;tail = (<span class=\"built_in\">list</span>-&gt;tail)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = p;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(List *<span class=\"built_in\">list</span>)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Node *q = <span class=\"built_in\">list</span>-&gt;head;q;q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>,q-&gt;value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryAndDelete</span><span class=\"params\">(List *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> isFound = <span class=\"number\">0</span>;</div><div class=\"line\">\tNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> ( Node *q = <span class=\"built_in\">list</span>-&gt;head;q;p = q,q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;value == number)&#123;</div><div class=\"line\">\t\t\tisFound = <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(q)&#123;</div><div class=\"line\">\t\t\t\tp-&gt;next = q-&gt;next;</div><div class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t\t(<span class=\"built_in\">list</span>-&gt;head)-&gt;next = q-&gt;next;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"built_in\">free</span>(q);</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(isFound)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"找到了\\n\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><h2 id=\"代码-linked-list-c\"><a href=\"#代码-linked-list-c\" class=\"headerlink\" title=\"代码 linked-list.c\"></a>代码 linked-list.c</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"node.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _node&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tint value;</span></div><div class=\"line\"><span class=\"comment\">// \tstruct _node *next;</span></div><div class=\"line\"><span class=\"comment\">// &#125;Node;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _list&#123; <span class=\"comment\">// 没有做尾指针</span></div><div class=\"line\">\tNode *head;</div><div class=\"line\">\tNode *tail;</div><div class=\"line\">&#125; List;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tList <span class=\"built_in\">list</span>;</div><div class=\"line\">\t<span class=\"built_in\">list</span>.head = <span class=\"built_in\">list</span>.tail = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number;</div><div class=\"line\">\t<span class=\"keyword\">do</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(number != <span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\t\tadd2(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;<span class=\"keyword\">while</span>(number != <span class=\"number\">-1</span>);</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Node *q = <span class=\"built_in\">list</span>.head;q;q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>,q-&gt;value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\tNode *last = <span class=\"built_in\">list</span>-&gt;head;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(last)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span>(last-&gt;next)&#123;</div><div class=\"line\">\t\t\tlast = last-&gt;next;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlast-&gt;next = p;</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = p;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;  <span class=\"comment\">// 哎，早画图早解决了服了</span></div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;tail)&#123;</div><div class=\"line\">\t\t(<span class=\"built_in\">list</span>-&gt;tail)-&gt;next = p;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;tail = (<span class=\"built_in\">list</span>-&gt;tail)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = p;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这是实现了基本的创建链表功能，有两个版本第一个版本(函数add())与第二个版本(add2())相比，第二个版本是具有为指针的每一次不用从头遍历到尾节点。</p>\n<p>##删除加寻找<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"node.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _node&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tint value;</span></div><div class=\"line\"><span class=\"comment\">// \tstruct _node *next;</span></div><div class=\"line\"><span class=\"comment\">// &#125;Node;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _list&#123; <span class=\"comment\">// 没有为检点的版本</span></div><div class=\"line\">\tNode *head;</div><div class=\"line\">\tNode *tail;</div><div class=\"line\">&#125; List;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// typedef struct _list&#123;</span></div><div class=\"line\"><span class=\"comment\">// \tNode *head;</span></div><div class=\"line\"><span class=\"comment\">// \tNode *tail;</span></div><div class=\"line\"><span class=\"comment\">// &#125; List;</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(List *<span class=\"built_in\">list</span>)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryAndDelete</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tList <span class=\"built_in\">list</span>;</div><div class=\"line\">\t<span class=\"built_in\">list</span>.head = <span class=\"built_in\">list</span>.tail = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> number;</div><div class=\"line\">\t<span class=\"keyword\">do</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(number != <span class=\"number\">-1</span>)&#123;</div><div class=\"line\">\t\t\tadd2(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;<span class=\"keyword\">while</span>(number != <span class=\"number\">-1</span>);</div><div class=\"line\">\tprint(&amp;<span class=\"built_in\">list</span>);</div><div class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;number);</div><div class=\"line\">\tqueryAndDelete(&amp;<span class=\"built_in\">list</span>,number);</div><div class=\"line\">\tprint(&amp;<span class=\"built_in\">list</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\tNode *last = <span class=\"built_in\">list</span>-&gt;head;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(last)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">while</span>(last-&gt;next)&#123;</div><div class=\"line\">\t\t\tlast = last-&gt;next;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tlast-&gt;next = p;</div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = p;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add2</span><span class=\"params\">(List *<span class=\"built_in\">list</span>, <span class=\"keyword\">int</span> number)</span></span>&#123;  <span class=\"comment\">// 哎，早画图早解决了服了</span></div><div class=\"line\">\t<span class=\"comment\">// add to linked-list</span></div><div class=\"line\">\tNode *p = (Node*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Node));</div><div class=\"line\">\tp-&gt;value = number;</div><div class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"comment\">// find last node</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">list</span>-&gt;tail)&#123;</div><div class=\"line\">\t\t(<span class=\"built_in\">list</span>-&gt;tail)-&gt;next = p;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;tail = (<span class=\"built_in\">list</span>-&gt;tail)-&gt;next;</div><div class=\"line\"></div><div class=\"line\">\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">list</span>-&gt;head = <span class=\"built_in\">list</span>-&gt;tail = p;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(List *<span class=\"built_in\">list</span>)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">for</span> (Node *q = <span class=\"built_in\">list</span>-&gt;head;q;q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\t\"</span>,q-&gt;value);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">queryAndDelete</span><span class=\"params\">(List *<span class=\"built_in\">list</span>,<span class=\"keyword\">int</span> number)</span></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> isFound = <span class=\"number\">0</span>;</div><div class=\"line\">\tNode *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">\t<span class=\"keyword\">for</span> ( Node *q = <span class=\"built_in\">list</span>-&gt;head;q;p = q,q=q-&gt;next)&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;value == number)&#123;</div><div class=\"line\">\t\t\tisFound = <span class=\"number\">1</span>;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(q)&#123;</div><div class=\"line\">\t\t\t\tp-&gt;next = q-&gt;next;</div><div class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">\t\t\t\t(<span class=\"built_in\">list</span>-&gt;head)-&gt;next = q-&gt;next;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t<span class=\"built_in\">free</span>(q);</div><div class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(isFound)&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"找到了\\n\"</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"hacker","date":"2017-04-06T09:11:34.000Z","_content":"## hacker\n![Alt text](/images/hacker.jpg)\n","source":"_posts/hacker.md","raw":"---\ntitle: hacker\ndate: 2017-04-06 17:11:34\ntags:\n---\n## hacker\n![Alt text](/images/hacker.jpg)\n","slug":"hacker","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6pj0004hhu2wbijlubi","content":"<h2 id=\"hacker\"><a href=\"#hacker\" class=\"headerlink\" title=\"hacker\"></a>hacker</h2><p><img src=\"/images/hacker.jpg\" alt=\"Alt text\"></p>\n","excerpt":"","more":"<h2 id=\"hacker\"><a href=\"#hacker\" class=\"headerlink\" title=\"hacker\"></a>hacker</h2><p><img src=\"/images/hacker.jpg\" alt=\"Alt text\"></p>\n"},{"title":"Markdown简介","date":"2017-03-19T06:14:37.000Z","_content":"## Markdown简介\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— [维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.example.com)或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按`Cmd + /`查看帮助。\n","source":"_posts/文章测试.md","raw":"---\ntitle: Markdown简介\ndate: 2017-03-19 14:14:37\ntags:\n---\n## Markdown简介\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— [维基百科](https://zh.wikipedia.org/wiki/Markdown)\n\n正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.example.com)或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按`Cmd + /`查看帮助。\n","slug":"文章测试","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6pq0006hhu2abke8g02","content":"<h2 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\" rel=\"external\">维基百科</a></p>\n</blockquote>\n<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.example.com\" target=\"_blank\" rel=\"external\">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Cmd + /</code>查看帮助。</p>\n","excerpt":"","more":"<h2 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\">维基百科</a></p>\n</blockquote>\n<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.example.com\">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Cmd + /</code>查看帮助。</p>\n"},{"title":"构造之法第2章","date":"2017-03-20T04:02:21.000Z","_content":"## 第2章概论\n这一章是讲自身技术的，首先讲到了单元测试，书中说：最好是在设计的时候就写好评单元测试，这样单元测试就能体现API的语义。还提到效能分析工具，从时间复杂度和空间复杂度来判定效能。提到了个人的开发流程，从在校大学生和硕士毕业后工作三年后的个人工作流程进行对比发现后者花在编码阶段的时间大大减少和花在需求分析和软件测试阶段的时间增加了，并且这两者占到了整个开发流程的60%。最后是实践还有更加详细的讲到了回归测试，回归简单的来说就是已经做好的模块，并且单元测试做的也没有问题，结果引入新的模块后出现了老得的模块的问题叫做回归。\n\n## 总结\n我作为在校大三的学生，也是会遇到过类似的问题。老师让做一个课程设计，用java写一个ATM，我当时觉得自己java学的不错（在我们班而言）就迫不及待的就直接编码了。当时什么架构也都不知道，也没有学软件工程，也不清楚个人的开发流程是什么，直接上来就编码。作了可能有一半了发现发现自己写的程序不符合面向对象的要求，也不符合MVC架构的准则。就重新写了一遍，写完之后发现，代码清清爽爽。这也算自己或者大多数，学编程初期的人都会遇到的一个问题吧。现在如果说做一个软件，我估计会强忍着，一上来就去写代码的冲动好好的把需求分析一下，数据库设计一下，功能梳理一下。说实话，第2章是关于测试的，本身来说对测试兴趣不是很高，所以，只是粗略的看了一下，但并不是测试不重要，只是个人感觉兴趣不大。\n","source":"_posts/构造之法第2章.md","raw":"---\ntitle: 构造之法第2章\ndate: 2017-03-20 12:02:21\ntags:\n---\n## 第2章概论\n这一章是讲自身技术的，首先讲到了单元测试，书中说：最好是在设计的时候就写好评单元测试，这样单元测试就能体现API的语义。还提到效能分析工具，从时间复杂度和空间复杂度来判定效能。提到了个人的开发流程，从在校大学生和硕士毕业后工作三年后的个人工作流程进行对比发现后者花在编码阶段的时间大大减少和花在需求分析和软件测试阶段的时间增加了，并且这两者占到了整个开发流程的60%。最后是实践还有更加详细的讲到了回归测试，回归简单的来说就是已经做好的模块，并且单元测试做的也没有问题，结果引入新的模块后出现了老得的模块的问题叫做回归。\n\n## 总结\n我作为在校大三的学生，也是会遇到过类似的问题。老师让做一个课程设计，用java写一个ATM，我当时觉得自己java学的不错（在我们班而言）就迫不及待的就直接编码了。当时什么架构也都不知道，也没有学软件工程，也不清楚个人的开发流程是什么，直接上来就编码。作了可能有一半了发现发现自己写的程序不符合面向对象的要求，也不符合MVC架构的准则。就重新写了一遍，写完之后发现，代码清清爽爽。这也算自己或者大多数，学编程初期的人都会遇到的一个问题吧。现在如果说做一个软件，我估计会强忍着，一上来就去写代码的冲动好好的把需求分析一下，数据库设计一下，功能梳理一下。说实话，第2章是关于测试的，本身来说对测试兴趣不是很高，所以，只是粗略的看了一下，但并不是测试不重要，只是个人感觉兴趣不大。\n","slug":"构造之法第2章","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6pv0008hhu2e6k3keyz","content":"<h2 id=\"第2章概论\"><a href=\"#第2章概论\" class=\"headerlink\" title=\"第2章概论\"></a>第2章概论</h2><p>这一章是讲自身技术的，首先讲到了单元测试，书中说：最好是在设计的时候就写好评单元测试，这样单元测试就能体现API的语义。还提到效能分析工具，从时间复杂度和空间复杂度来判定效能。提到了个人的开发流程，从在校大学生和硕士毕业后工作三年后的个人工作流程进行对比发现后者花在编码阶段的时间大大减少和花在需求分析和软件测试阶段的时间增加了，并且这两者占到了整个开发流程的60%。最后是实践还有更加详细的讲到了回归测试，回归简单的来说就是已经做好的模块，并且单元测试做的也没有问题，结果引入新的模块后出现了老得的模块的问题叫做回归。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我作为在校大三的学生，也是会遇到过类似的问题。老师让做一个课程设计，用java写一个ATM，我当时觉得自己java学的不错（在我们班而言）就迫不及待的就直接编码了。当时什么架构也都不知道，也没有学软件工程，也不清楚个人的开发流程是什么，直接上来就编码。作了可能有一半了发现发现自己写的程序不符合面向对象的要求，也不符合MVC架构的准则。就重新写了一遍，写完之后发现，代码清清爽爽。这也算自己或者大多数，学编程初期的人都会遇到的一个问题吧。现在如果说做一个软件，我估计会强忍着，一上来就去写代码的冲动好好的把需求分析一下，数据库设计一下，功能梳理一下。说实话，第2章是关于测试的，本身来说对测试兴趣不是很高，所以，只是粗略的看了一下，但并不是测试不重要，只是个人感觉兴趣不大。</p>\n","excerpt":"","more":"<h2 id=\"第2章概论\"><a href=\"#第2章概论\" class=\"headerlink\" title=\"第2章概论\"></a>第2章概论</h2><p>这一章是讲自身技术的，首先讲到了单元测试，书中说：最好是在设计的时候就写好评单元测试，这样单元测试就能体现API的语义。还提到效能分析工具，从时间复杂度和空间复杂度来判定效能。提到了个人的开发流程，从在校大学生和硕士毕业后工作三年后的个人工作流程进行对比发现后者花在编码阶段的时间大大减少和花在需求分析和软件测试阶段的时间增加了，并且这两者占到了整个开发流程的60%。最后是实践还有更加详细的讲到了回归测试，回归简单的来说就是已经做好的模块，并且单元测试做的也没有问题，结果引入新的模块后出现了老得的模块的问题叫做回归。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我作为在校大三的学生，也是会遇到过类似的问题。老师让做一个课程设计，用java写一个ATM，我当时觉得自己java学的不错（在我们班而言）就迫不及待的就直接编码了。当时什么架构也都不知道，也没有学软件工程，也不清楚个人的开发流程是什么，直接上来就编码。作了可能有一半了发现发现自己写的程序不符合面向对象的要求，也不符合MVC架构的准则。就重新写了一遍，写完之后发现，代码清清爽爽。这也算自己或者大多数，学编程初期的人都会遇到的一个问题吧。现在如果说做一个软件，我估计会强忍着，一上来就去写代码的冲动好好的把需求分析一下，数据库设计一下，功能梳理一下。说实话，第2章是关于测试的，本身来说对测试兴趣不是很高，所以，只是粗略的看了一下，但并不是测试不重要，只是个人感觉兴趣不大。</p>\n"},{"title":"构造之法第5章","date":"2017-03-20T04:58:41.000Z","_content":"## 第5章团队和流程概述\n- **理论和知识点**\n- **典型的软件团队模式和开发流程都有哪些？各有什么优缺点**\n- **MVP,MBP,RUP**\n- **练习与讨论**\n- **团队模式和开发效率的关系**\n讲了什么是非团队，和一些软件团队的模式：\n## 主治医师模式\n选取一个首席程序员，负责处理主要模型的设计和编码，其他人员负责配合和支持他／她。\n但是这种模式往往会从这一模式退化为“一个学生干活，其余学生跟着打酱油”。\n## 明星模式\n主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星光环盖过了团队其他人的总和，但是这个明星万一哪天陨落了，这个团队是否可以正常运行。\n## 社区模式\n社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬，发挥大众的力量但是，同时代码质量也要进行严格的控制。\n## 业余剧团模式\n这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中这些人也许也会换一个完全不同的角色类型。各人在团队中听从一个中央指挥的指挥和安排。\n## 神秘团队\n一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式好处是：团队内部有极大的自由，没有外界的干扰，团队成员有极大的投入。\n## 特工团队\n软件行业的一些团队由一些有特殊技能的专业人士组成，负责一些棘手的而有紧迫的问题。例如一些专门做网站安全性服务团队。\n## 交响乐团模式\n特点如下：\n- **工具齐全**\n- **各司其职**\n- **有统一的指挥**\n- **具有多个项目的的开发经验**\n## 爵士乐模式\n特点如下：\n- **工作比较随意**\n- **主要的程序员没有现场指挥**\n- **架构师搭建架构之后，程序员自由发挥**\n- **人数较少**\n强调个性化的表达，强有力的互动，对变化的内容有创意的回应。\n## 功能团队模式\n具备不同能力的同事平等协作，共同完成一个功能。他们之间没有管理和被管理的关系。\n## 官僚模式\n![Alt text](/images/guanliao.png)\n层层管理的官僚模式\n这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。这种模式如果应用不好，最后会变成“老板驱动”的开发流程。\n## 开发流程\n我们在开发、运营、维护软件的过程中有很多技术、做法、习惯和思想。软件工程把这些相关的技术和过程统一到一个体系中，叫“软件开发流程”，软件开发流程的目的是为了提高软件开发、运营和维护的效率，以及提升用户满意度、软件的可靠性和可维护性。\n## 写了在改模式\n![Alt text](/images/xieafterupdate.png)\n这个流程也有好处，不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。 “只用一次”的程序 “看过了就扔”的原型 一些不实用的演示程序 但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太大了。要注意的是，许多学校里的软件工程作业的要求符合上面那三点，所以难怪同学们觉得没有必要用其他的开发方法，“写了再改”足矣！\n## 瀑布模型\n当软件行业还在年幼的时期，它从别的成熟行业（硬件设计，建筑工程）借用了不少经验和模型。在那些“硬”的行业中，产品大多遵循 [分析→设计→实现（制造）→销售→维护] 这个流程。由于在“硬”行业中产品一旦大规模生产，要再返回去修改时就非常困难，甚至是不可能的。因此这个模型描述了单向的\n![Alt text](/images/waterfall.png)\n温斯顿正确地指出了在设计大型系统时，要做相邻步骤的回溯，解决上一阶段未能解决的问题:又如, 温斯顿指出,要让产品成功,最好把这个模型走两遍,先有一个模拟版本(Simulation of FinalProduct),在此基础上收集反馈,改进各个步骤,并交付一个最终的版本:\n![Alt text](/images/shouji.png)\n","source":"_posts/构造之法第5章.md","raw":"---\ntitle: 构造之法第5章\ndate: 2017-03-20 12:58:41\ntags:\n---\n## 第5章团队和流程概述\n- **理论和知识点**\n- **典型的软件团队模式和开发流程都有哪些？各有什么优缺点**\n- **MVP,MBP,RUP**\n- **练习与讨论**\n- **团队模式和开发效率的关系**\n讲了什么是非团队，和一些软件团队的模式：\n## 主治医师模式\n选取一个首席程序员，负责处理主要模型的设计和编码，其他人员负责配合和支持他／她。\n但是这种模式往往会从这一模式退化为“一个学生干活，其余学生跟着打酱油”。\n## 明星模式\n主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星光环盖过了团队其他人的总和，但是这个明星万一哪天陨落了，这个团队是否可以正常运行。\n## 社区模式\n社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬，发挥大众的力量但是，同时代码质量也要进行严格的控制。\n## 业余剧团模式\n这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中这些人也许也会换一个完全不同的角色类型。各人在团队中听从一个中央指挥的指挥和安排。\n## 神秘团队\n一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式好处是：团队内部有极大的自由，没有外界的干扰，团队成员有极大的投入。\n## 特工团队\n软件行业的一些团队由一些有特殊技能的专业人士组成，负责一些棘手的而有紧迫的问题。例如一些专门做网站安全性服务团队。\n## 交响乐团模式\n特点如下：\n- **工具齐全**\n- **各司其职**\n- **有统一的指挥**\n- **具有多个项目的的开发经验**\n## 爵士乐模式\n特点如下：\n- **工作比较随意**\n- **主要的程序员没有现场指挥**\n- **架构师搭建架构之后，程序员自由发挥**\n- **人数较少**\n强调个性化的表达，强有力的互动，对变化的内容有创意的回应。\n## 功能团队模式\n具备不同能力的同事平等协作，共同完成一个功能。他们之间没有管理和被管理的关系。\n## 官僚模式\n![Alt text](/images/guanliao.png)\n层层管理的官僚模式\n这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。这种模式如果应用不好，最后会变成“老板驱动”的开发流程。\n## 开发流程\n我们在开发、运营、维护软件的过程中有很多技术、做法、习惯和思想。软件工程把这些相关的技术和过程统一到一个体系中，叫“软件开发流程”，软件开发流程的目的是为了提高软件开发、运营和维护的效率，以及提升用户满意度、软件的可靠性和可维护性。\n## 写了在改模式\n![Alt text](/images/xieafterupdate.png)\n这个流程也有好处，不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。 “只用一次”的程序 “看过了就扔”的原型 一些不实用的演示程序 但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太大了。要注意的是，许多学校里的软件工程作业的要求符合上面那三点，所以难怪同学们觉得没有必要用其他的开发方法，“写了再改”足矣！\n## 瀑布模型\n当软件行业还在年幼的时期，它从别的成熟行业（硬件设计，建筑工程）借用了不少经验和模型。在那些“硬”的行业中，产品大多遵循 [分析→设计→实现（制造）→销售→维护] 这个流程。由于在“硬”行业中产品一旦大规模生产，要再返回去修改时就非常困难，甚至是不可能的。因此这个模型描述了单向的\n![Alt text](/images/waterfall.png)\n温斯顿正确地指出了在设计大型系统时，要做相邻步骤的回溯，解决上一阶段未能解决的问题:又如, 温斯顿指出,要让产品成功,最好把这个模型走两遍,先有一个模拟版本(Simulation of FinalProduct),在此基础上收集反馈,改进各个步骤,并交付一个最终的版本:\n![Alt text](/images/shouji.png)\n","slug":"构造之法第5章","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6px0009hhu2eg1qky49","content":"<h2 id=\"第5章团队和流程概述\"><a href=\"#第5章团队和流程概述\" class=\"headerlink\" title=\"第5章团队和流程概述\"></a>第5章团队和流程概述</h2><ul>\n<li><strong>理论和知识点</strong></li>\n<li><strong>典型的软件团队模式和开发流程都有哪些？各有什么优缺点</strong></li>\n<li><strong>MVP,MBP,RUP</strong></li>\n<li><strong>练习与讨论</strong></li>\n<li><strong>团队模式和开发效率的关系</strong><br>讲了什么是非团队，和一些软件团队的模式：<h2 id=\"主治医师模式\"><a href=\"#主治医师模式\" class=\"headerlink\" title=\"主治医师模式\"></a>主治医师模式</h2>选取一个首席程序员，负责处理主要模型的设计和编码，其他人员负责配合和支持他／她。<br>但是这种模式往往会从这一模式退化为“一个学生干活，其余学生跟着打酱油”。<h2 id=\"明星模式\"><a href=\"#明星模式\" class=\"headerlink\" title=\"明星模式\"></a>明星模式</h2>主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星光环盖过了团队其他人的总和，但是这个明星万一哪天陨落了，这个团队是否可以正常运行。<h2 id=\"社区模式\"><a href=\"#社区模式\" class=\"headerlink\" title=\"社区模式\"></a>社区模式</h2>社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬，发挥大众的力量但是，同时代码质量也要进行严格的控制。<h2 id=\"业余剧团模式\"><a href=\"#业余剧团模式\" class=\"headerlink\" title=\"业余剧团模式\"></a>业余剧团模式</h2>这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中这些人也许也会换一个完全不同的角色类型。各人在团队中听从一个中央指挥的指挥和安排。<h2 id=\"神秘团队\"><a href=\"#神秘团队\" class=\"headerlink\" title=\"神秘团队\"></a>神秘团队</h2>一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式好处是：团队内部有极大的自由，没有外界的干扰，团队成员有极大的投入。<h2 id=\"特工团队\"><a href=\"#特工团队\" class=\"headerlink\" title=\"特工团队\"></a>特工团队</h2>软件行业的一些团队由一些有特殊技能的专业人士组成，负责一些棘手的而有紧迫的问题。例如一些专门做网站安全性服务团队。<h2 id=\"交响乐团模式\"><a href=\"#交响乐团模式\" class=\"headerlink\" title=\"交响乐团模式\"></a>交响乐团模式</h2>特点如下：</li>\n<li><strong>工具齐全</strong></li>\n<li><strong>各司其职</strong></li>\n<li><strong>有统一的指挥</strong></li>\n<li><strong>具有多个项目的的开发经验</strong><h2 id=\"爵士乐模式\"><a href=\"#爵士乐模式\" class=\"headerlink\" title=\"爵士乐模式\"></a>爵士乐模式</h2>特点如下：</li>\n<li><strong>工作比较随意</strong></li>\n<li><strong>主要的程序员没有现场指挥</strong></li>\n<li><strong>架构师搭建架构之后，程序员自由发挥</strong></li>\n<li><strong>人数较少</strong><br>强调个性化的表达，强有力的互动，对变化的内容有创意的回应。<h2 id=\"功能团队模式\"><a href=\"#功能团队模式\" class=\"headerlink\" title=\"功能团队模式\"></a>功能团队模式</h2>具备不同能力的同事平等协作，共同完成一个功能。他们之间没有管理和被管理的关系。<h2 id=\"官僚模式\"><a href=\"#官僚模式\" class=\"headerlink\" title=\"官僚模式\"></a>官僚模式</h2><img src=\"/images/guanliao.png\" alt=\"Alt text\"><br>层层管理的官僚模式<br>这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。这种模式如果应用不好，最后会变成“老板驱动”的开发流程。<h2 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h2>我们在开发、运营、维护软件的过程中有很多技术、做法、习惯和思想。软件工程把这些相关的技术和过程统一到一个体系中，叫“软件开发流程”，软件开发流程的目的是为了提高软件开发、运营和维护的效率，以及提升用户满意度、软件的可靠性和可维护性。<h2 id=\"写了在改模式\"><a href=\"#写了在改模式\" class=\"headerlink\" title=\"写了在改模式\"></a>写了在改模式</h2><img src=\"/images/xieafterupdate.png\" alt=\"Alt text\"><br>这个流程也有好处，不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。 “只用一次”的程序 “看过了就扔”的原型 一些不实用的演示程序 但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太大了。要注意的是，许多学校里的软件工程作业的要求符合上面那三点，所以难怪同学们觉得没有必要用其他的开发方法，“写了再改”足矣！<h2 id=\"瀑布模型\"><a href=\"#瀑布模型\" class=\"headerlink\" title=\"瀑布模型\"></a>瀑布模型</h2>当软件行业还在年幼的时期，它从别的成熟行业（硬件设计，建筑工程）借用了不少经验和模型。在那些“硬”的行业中，产品大多遵循 [分析→设计→实现（制造）→销售→维护] 这个流程。由于在“硬”行业中产品一旦大规模生产，要再返回去修改时就非常困难，甚至是不可能的。因此这个模型描述了单向的<br><img src=\"/images/waterfall.png\" alt=\"Alt text\"><br>温斯顿正确地指出了在设计大型系统时，要做相邻步骤的回溯，解决上一阶段未能解决的问题:又如, 温斯顿指出,要让产品成功,最好把这个模型走两遍,先有一个模拟版本(Simulation of FinalProduct),在此基础上收集反馈,改进各个步骤,并交付一个最终的版本:<br><img src=\"/images/shouji.png\" alt=\"Alt text\"></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"第5章团队和流程概述\"><a href=\"#第5章团队和流程概述\" class=\"headerlink\" title=\"第5章团队和流程概述\"></a>第5章团队和流程概述</h2><ul>\n<li><strong>理论和知识点</strong></li>\n<li><strong>典型的软件团队模式和开发流程都有哪些？各有什么优缺点</strong></li>\n<li><strong>MVP,MBP,RUP</strong></li>\n<li><strong>练习与讨论</strong></li>\n<li><strong>团队模式和开发效率的关系</strong><br>讲了什么是非团队，和一些软件团队的模式：<h2 id=\"主治医师模式\"><a href=\"#主治医师模式\" class=\"headerlink\" title=\"主治医师模式\"></a>主治医师模式</h2>选取一个首席程序员，负责处理主要模型的设计和编码，其他人员负责配合和支持他／她。<br>但是这种模式往往会从这一模式退化为“一个学生干活，其余学生跟着打酱油”。<h2 id=\"明星模式\"><a href=\"#明星模式\" class=\"headerlink\" title=\"明星模式\"></a>明星模式</h2>主治医师模式运用到极点，可以蜕化为明星模式，在这里，明星光环盖过了团队其他人的总和，但是这个明星万一哪天陨落了，这个团队是否可以正常运行。<h2 id=\"社区模式\"><a href=\"#社区模式\" class=\"headerlink\" title=\"社区模式\"></a>社区模式</h2>社区由很多志愿者参与，每个人参与自己感兴趣的项目，贡献力量，大部分人不拿报酬，发挥大众的力量但是，同时代码质量也要进行严格的控制。<h2 id=\"业余剧团模式\"><a href=\"#业余剧团模式\" class=\"headerlink\" title=\"业余剧团模式\"></a>业余剧团模式</h2>这样的团队在每一个项目中，不同的人会挑选不同的角色。在下一个项目中这些人也许也会换一个完全不同的角色类型。各人在团队中听从一个中央指挥的指挥和安排。<h2 id=\"神秘团队\"><a href=\"#神秘团队\" class=\"headerlink\" title=\"神秘团队\"></a>神秘团队</h2>一些软件项目在秘密状态下进行，别人不知道他们具体在做什么。这种模式好处是：团队内部有极大的自由，没有外界的干扰，团队成员有极大的投入。<h2 id=\"特工团队\"><a href=\"#特工团队\" class=\"headerlink\" title=\"特工团队\"></a>特工团队</h2>软件行业的一些团队由一些有特殊技能的专业人士组成，负责一些棘手的而有紧迫的问题。例如一些专门做网站安全性服务团队。<h2 id=\"交响乐团模式\"><a href=\"#交响乐团模式\" class=\"headerlink\" title=\"交响乐团模式\"></a>交响乐团模式</h2>特点如下：</li>\n<li><strong>工具齐全</strong></li>\n<li><strong>各司其职</strong></li>\n<li><strong>有统一的指挥</strong></li>\n<li><strong>具有多个项目的的开发经验</strong><h2 id=\"爵士乐模式\"><a href=\"#爵士乐模式\" class=\"headerlink\" title=\"爵士乐模式\"></a>爵士乐模式</h2>特点如下：</li>\n<li><strong>工作比较随意</strong></li>\n<li><strong>主要的程序员没有现场指挥</strong></li>\n<li><strong>架构师搭建架构之后，程序员自由发挥</strong></li>\n<li><strong>人数较少</strong><br>强调个性化的表达，强有力的互动，对变化的内容有创意的回应。<h2 id=\"功能团队模式\"><a href=\"#功能团队模式\" class=\"headerlink\" title=\"功能团队模式\"></a>功能团队模式</h2>具备不同能力的同事平等协作，共同完成一个功能。他们之间没有管理和被管理的关系。<h2 id=\"官僚模式\"><a href=\"#官僚模式\" class=\"headerlink\" title=\"官僚模式\"></a>官僚模式</h2><img src=\"/images/guanliao.png\" alt=\"Alt text\"><br>层层管理的官僚模式<br>这种模式在软件开发中会出问题。因为成员之间不光有技术方面的合作和领导，同时还混进了组织上的领导和被领导关系。跨组织的合作变得比较困难，因为各自头顶上都有不同的老板。这种模式如果应用不好，最后会变成“老板驱动”的开发流程。<h2 id=\"开发流程\"><a href=\"#开发流程\" class=\"headerlink\" title=\"开发流程\"></a>开发流程</h2>我们在开发、运营、维护软件的过程中有很多技术、做法、习惯和思想。软件工程把这些相关的技术和过程统一到一个体系中，叫“软件开发流程”，软件开发流程的目的是为了提高软件开发、运营和维护的效率，以及提升用户满意度、软件的可靠性和可维护性。<h2 id=\"写了在改模式\"><a href=\"#写了在改模式\" class=\"headerlink\" title=\"写了在改模式\"></a>写了在改模式</h2><img src=\"/images/xieafterupdate.png\" alt=\"Alt text\"><br>这个流程也有好处，不需要太多其他准备或相关知识，大家上来就写代码，也许就能写出来，写不出来就改，也许能改好。当面临下面的任务时，也许这个方法是有用的。 “只用一次”的程序 “看过了就扔”的原型 一些不实用的演示程序 但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太但是，要写一个有实际用户、解决实际需求的软件，这个方法的缺点就太大了。要注意的是，许多学校里的软件工程作业的要求符合上面那三点，所以难怪同学们觉得没有必要用其他的开发方法，“写了再改”足矣！<h2 id=\"瀑布模型\"><a href=\"#瀑布模型\" class=\"headerlink\" title=\"瀑布模型\"></a>瀑布模型</h2>当软件行业还在年幼的时期，它从别的成熟行业（硬件设计，建筑工程）借用了不少经验和模型。在那些“硬”的行业中，产品大多遵循 [分析→设计→实现（制造）→销售→维护] 这个流程。由于在“硬”行业中产品一旦大规模生产，要再返回去修改时就非常困难，甚至是不可能的。因此这个模型描述了单向的<br><img src=\"/images/waterfall.png\" alt=\"Alt text\"><br>温斯顿正确地指出了在设计大型系统时，要做相邻步骤的回溯，解决上一阶段未能解决的问题:又如, 温斯顿指出,要让产品成功,最好把这个模型走两遍,先有一个模拟版本(Simulation of FinalProduct),在此基础上收集反馈,改进各个步骤,并交付一个最终的版本:<br><img src=\"/images/shouji.png\" alt=\"Alt text\"></li>\n</ul>\n"},{"title":"测试驱动开发","date":"2017-04-10T07:17:21.000Z","_content":"## 背景\n一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论。\n## 1. 优势\nTDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。\n需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。\n通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。\n开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。\n快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。\n当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。\n我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。\n那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。\n## 2. 原理\n测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。\n我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。\n【图 V测试模型】\n![Alt text](/images/v.jpg)\n在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。\n关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。\n【图 X测试模型】\n![Alt text](/images/x.jpg)\n## 3. 过程\n软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。\n测试驱动开发的基本过程如下：\n1） 明确当前要完成的功能。可以记录成一个 TODO 列表。\n2） 快速完成针对此功能的测试用例编写。\n3） 测试代码编译不通过。\n4） 编写对应的功能代码。\n5） 测试通过。\n6） 对代码进行重构，并保证测试通过。\n7） 循环完成所有功能的开发。\n为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。\n开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。\n```\nproject/\t\t\t\t项目主目录\n\tproject/test\t\t\t测试项目主目录\n\tproject/test/testSeq.cpp\t\t测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可\n\tproject/test/testSeq.h\n\tproject/test/Makefile\t\t\t测试项目的 Makefile\n\tproject/test/main.cpp\t\t\t测试项目的主文件，不需要修改\n\tproject/main.cpp\t\t           项目的主文件\n\tproject/seq_t.h\t\t\t功能代码，被测试文件\n\tproject/Makefile\t\t           项目的 Makefile\n```\n主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。\n## 4. 原则\n测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。\n一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。\n测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。\n测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。\n先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。\n可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。\n及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。\n小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）\n## 5. 测试技术\n5.1. 测试范围、粒度\n对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。\n测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。\n测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。\n小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。\n5.2. 怎么编写测试用例\n测试用例的编写就用上了传统的测试技术。\n操作过程尽量模拟正常使用的过程。\n全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。\n测试数据尽量包括：真实数据、边界数据。\n测试语句和测试数据应该尽量简单，容易理解。\n为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。\n如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。\n## 6. Tips\n很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。\n软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。\n","source":"_posts/测试驱动开发.md","raw":"---\ntitle: 测试驱动开发\ndate: 2017-04-10 15:17:21\ntags:\n---\n## 背景\n一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论。\n## 1. 优势\nTDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。\n需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。\n通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。\n开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。\n快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。\n当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。\n我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。\n那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。\n## 2. 原理\n测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。\n我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。\n【图 V测试模型】\n![Alt text](/images/v.jpg)\n在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。\n关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。\n【图 X测试模型】\n![Alt text](/images/x.jpg)\n## 3. 过程\n软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。\n测试驱动开发的基本过程如下：\n1） 明确当前要完成的功能。可以记录成一个 TODO 列表。\n2） 快速完成针对此功能的测试用例编写。\n3） 测试代码编译不通过。\n4） 编写对应的功能代码。\n5） 测试通过。\n6） 对代码进行重构，并保证测试通过。\n7） 循环完成所有功能的开发。\n为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。\n开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。\n```\nproject/\t\t\t\t项目主目录\n\tproject/test\t\t\t测试项目主目录\n\tproject/test/testSeq.cpp\t\t测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可\n\tproject/test/testSeq.h\n\tproject/test/Makefile\t\t\t测试项目的 Makefile\n\tproject/test/main.cpp\t\t\t测试项目的主文件，不需要修改\n\tproject/main.cpp\t\t           项目的主文件\n\tproject/seq_t.h\t\t\t功能代码，被测试文件\n\tproject/Makefile\t\t           项目的 Makefile\n```\n主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。\n## 4. 原则\n测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。\n一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。\n测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。\n测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。\n先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。\n可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。\n及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。\n小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）\n## 5. 测试技术\n5.1. 测试范围、粒度\n对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。\n测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。\n测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。\n小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。\n5.2. 怎么编写测试用例\n测试用例的编写就用上了传统的测试技术。\n操作过程尽量模拟正常使用的过程。\n全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。\n测试数据尽量包括：真实数据、边界数据。\n测试语句和测试数据应该尽量简单，容易理解。\n为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。\n如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。\n## 6. Tips\n很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。\n软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。\n","slug":"测试驱动开发","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6py000ahhu2ehabikcv","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论。</p>\n<h2 id=\"1-优势\"><a href=\"#1-优势\" class=\"headerlink\" title=\"1. 优势\"></a>1. 优势</h2><p>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。<br>需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。<br>通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。<br>开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。<br>快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。<br>当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。<br>我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。<br>那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。</p>\n<h2 id=\"2-原理\"><a href=\"#2-原理\" class=\"headerlink\" title=\"2. 原理\"></a>2. 原理</h2><p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。<br>我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。<br>【图 V测试模型】<br><img src=\"/images/v.jpg\" alt=\"Alt text\"><br>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。<br>关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。<br>【图 X测试模型】<br><img src=\"/images/x.jpg\" alt=\"Alt text\"></p>\n<h2 id=\"3-过程\"><a href=\"#3-过程\" class=\"headerlink\" title=\"3. 过程\"></a>3. 过程</h2><p>软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。<br>测试驱动开发的基本过程如下：<br>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。<br>2） 快速完成针对此功能的测试用例编写。<br>3） 测试代码编译不通过。<br>4） 编写对应的功能代码。<br>5） 测试通过。<br>6） 对代码进行重构，并保证测试通过。<br>7） 循环完成所有功能的开发。<br>为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。<br>开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">project/\t\t\t\t项目主目录</div><div class=\"line\">\tproject/test\t\t\t测试项目主目录</div><div class=\"line\">\tproject/test/testSeq.cpp\t\t测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可</div><div class=\"line\">\tproject/test/testSeq.h</div><div class=\"line\">\tproject/test/Makefile\t\t\t测试项目的 Makefile</div><div class=\"line\">\tproject/test/main.cpp\t\t\t测试项目的主文件，不需要修改</div><div class=\"line\">\tproject/main.cpp\t\t           项目的主文件</div><div class=\"line\">\tproject/seq_t.h\t\t\t功能代码，被测试文件</div><div class=\"line\">\tproject/Makefile\t\t           项目的 Makefile</div></pre></td></tr></table></figure></p>\n<p>主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。</p>\n<h2 id=\"4-原则\"><a href=\"#4-原则\" class=\"headerlink\" title=\"4. 原则\"></a>4. 原则</h2><p>测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。<br>一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。<br>测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。<br>测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。<br>先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。<br>可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。<br>及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。<br>小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）</p>\n<h2 id=\"5-测试技术\"><a href=\"#5-测试技术\" class=\"headerlink\" title=\"5. 测试技术\"></a>5. 测试技术</h2><p>5.1. 测试范围、粒度<br>对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。<br>测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。<br>测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。<br>小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。<br>5.2. 怎么编写测试用例<br>测试用例的编写就用上了传统的测试技术。<br>操作过程尽量模拟正常使用的过程。<br>全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。<br>测试数据尽量包括：真实数据、边界数据。<br>测试语句和测试数据应该尽量简单，容易理解。<br>为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。<br>如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。</p>\n<h2 id=\"6-Tips\"><a href=\"#6-Tips\" class=\"headerlink\" title=\"6. Tips\"></a>6. Tips</h2><p>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。<br>软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。</p>\n","excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>一个高效的软件开发过程对软件开发人员来说是至关重要的，决定着开发是痛苦的挣扎，还是不断进步的喜悦。国人对软件蓝领的不屑，对繁琐冗长的传统开发过程的不耐，使大多数开发人员无所适从。最近兴起的一些软件开发过程相关的技术，提供一些比较高效、实用的软件过程开发方法。其中比较基础、关键的一个技术就是测试驱动开发（Test-Driven Development）。虽然TDD光大于极限编程，但测试驱动开发完全可以单独应用。下面就从开发人员使用的角度进行介绍，使开发人员用最少的代价尽快理解、掌握、应用这种技术。下面分优势，原理，过程，原则，测试技术，Tips等方面进行讨论。</p>\n<h2 id=\"1-优势\"><a href=\"#1-优势\" class=\"headerlink\" title=\"1. 优势\"></a>1. 优势</h2><p>TDD的基本思路就是通过测试来推动整个开发的进行。而测试驱动开发技术并不只是单纯的测试工作。<br>需求向来就是软件开发过程中感觉最不好明确描述、易变的东西。这里说的需求不只是指用户的需求，还包括对代码的使用需求。很多开发人员最害怕的就是后期还要修改某个类或者函数的接口进行修改或者扩展，为什么会发生这样的事情就是因为这部分代码的使用需求没有很好的描述。测试驱动开发就是通过编写测试用例，先考虑代码的使用需求（包括功能、过程、接口等），而且这个描述是无二义的，可执行验证的。<br>通过编写这部分代码的测试用例，对其功能的分解、使用过程、接口都进行了设计。而且这种从使用角度对代码的设计通常更符合后期开发的需求。可测试的要求，对代码的内聚性的提高和复用都非常有益。因此测试驱动开发也是一种代码设计的过程。<br>开发人员通常对编写文档非常厌烦，但要使用、理解别人的代码时通常又希望能有文档进行指导。而测试驱动开发过程中产生的测试用例代码就是对代码的最好的解释。<br>快乐工作的基础就是对自己有信心，对自己的工作成果有信心。当前很多开发人员却经常在担心：“代码是否正确？”“辛苦编写的代码还有没有严重bug？”“修改的新代码对其他部分有没有影响？”。这种担心甚至导致某些代码应该修改却不敢修改的地步。测试驱动开发提供的测试集就可以作为你信心的来源。<br>当然测试驱动开发最重要的功能还在于保障代码的正确性，能够迅速发现、定位bug。而迅速发现、定位bug是很多开发人员的梦想。针对关键代码的测试集，以及不断完善的测试用例，为迅速发现、定位bug提供了条件。<br>我的一段功能非常复杂的代码使用TDD开发完成，真实环境应用中只发现几个bug，而且很快被定位解决。您在应用后，也一定会为那种自信的开发过程，功能不断增加、完善的感觉，迅速发现、定位bug的能力所感染，喜欢这个技术的。<br>那么是什么样的原理、方法提供上面说的这些好处哪？下面我们就看看TDD的原理。</p>\n<h2 id=\"2-原理\"><a href=\"#2-原理\" class=\"headerlink\" title=\"2. 原理\"></a>2. 原理</h2><p>测试驱动开发的基本思想就是在开发功能代码之前，先编写测试代码。也就是说在明确要开发某个功能后，首先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。然后循环进行添加其他功能，直到完全部功能的开发。<br>我们这里把这个技术的应用领域从代码编写扩展到整个开发过程。应该对整个开发过程的各个阶段进行测试驱动，首先思考如何对这个阶段进行测试、验证、考核，并编写相关的测试文档，然后开始下一步工作，最后再验证相关的工作。下图是一个比较流行的测试模型：V测试模型。<br>【图 V测试模型】<br><img src=\"/images/v.jpg\" alt=\"Alt text\"><br>在开发的各个阶段，包括需求分析、概要设计、详细设计、编码过程中都应该考虑相对应的测试工作，完成相关的测试用例的设计、测试方案、测试计划的编写。这里提到的开发阶段只是举例，根据实际的开发活动进行调整。相关的测试文档也不一定是非常详细复杂的文档，或者什么形式，但应该养成测试驱动的习惯。<br>关于测试模型，还有X测试模型。这个测试模型，我认为，是对详细阶段和编码阶段进行建模，应该说更详细的描述了详细设计和编码阶段的开发行为。及针对某个功能进行对应的测试驱动开发。<br>【图 X测试模型】<br><img src=\"/images/x.jpg\" alt=\"Alt text\"></p>\n<h2 id=\"3-过程\"><a href=\"#3-过程\" class=\"headerlink\" title=\"3. 过程\"></a>3. 过程</h2><p>软件开发其他阶段的测试驱动开发，根据测试驱动开发的思想完成对应的测试文档即可。下面针对详细设计和编码阶段进行介绍。<br>测试驱动开发的基本过程如下：<br>1） 明确当前要完成的功能。可以记录成一个 TODO 列表。<br>2） 快速完成针对此功能的测试用例编写。<br>3） 测试代码编译不通过。<br>4） 编写对应的功能代码。<br>5） 测试通过。<br>6） 对代码进行重构，并保证测试通过。<br>7） 循环完成所有功能的开发。<br>为了保证整个测试过程比较快捷、方便，通常可以使用测试框架组织所有的测试用例。一个免费的、优秀的测试框架是 Xunit 系列，几乎所有的语言都有对应的测试框架。<br>开发过程中，通常把测试代码和功能代码分开存放，这里提供一个简单的测试框架使用例子，您可以通过它了解测试框架的使用。下面是文件列表。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">project/\t\t\t\t项目主目录</div><div class=\"line\">\tproject/test\t\t\t测试项目主目录</div><div class=\"line\">\tproject/test/testSeq.cpp\t\t测试seq_t 的测试文件，对其他功能文件的测试文件复制后修改即可</div><div class=\"line\">\tproject/test/testSeq.h</div><div class=\"line\">\tproject/test/Makefile\t\t\t测试项目的 Makefile</div><div class=\"line\">\tproject/test/main.cpp\t\t\t测试项目的主文件，不需要修改</div><div class=\"line\">\tproject/main.cpp\t\t           项目的主文件</div><div class=\"line\">\tproject/seq_t.h\t\t\t功能代码，被测试文件</div><div class=\"line\">\tproject/Makefile\t\t           项目的 Makefile</div></pre></td></tr></table></figure></p>\n<p>主要流程基本如此，但要让你的代码很容易的进行测试，全面又不繁琐的进行测试，还是有很多测试原则和技术需要考虑。</p>\n<h2 id=\"4-原则\"><a href=\"#4-原则\" class=\"headerlink\" title=\"4. 原则\"></a>4. 原则</h2><p>测试隔离。不同代码的测试应该相互隔离。对一块代码的测试只考虑此代码的测试，不要考虑其实现细节（比如它使用了其他类的边界条件）。<br>一顶帽子。开发人员开发过程中要做不同的工作，比如：编写测试代码、开发功能代码、对代码重构等。做不同的事，承担不同的角色。开发人员完成对应的工作时应该保持注意力集中在当前工作上，而不要过多的考虑其他方面的细节，保证头上只有一顶帽子。避免考虑无关细节过多，无谓地增加复杂度。<br>测试列表。需要测试的功能点很多。应该在任何阶段想添加功能需求问题时，把相关功能点加到测试列表中，然后继续手头工作。然后不断的完成对应的测试用例、功能代码、重构。一是避免疏漏，也避免干扰当前进行的工作。<br>测试驱动。这个比较核心。完成某个功能，某个类，首先编写测试代码，考虑其如何使用、如何测试。然后在对其进行设计、编码。<br>先写断言。测试代码编写时，应该首先编写对功能代码的判断用的断言语句，然后编写相应的辅助语句。<br>可测试性。功能代码设计、开发时应该具有较强的可测试性。其实遵循比较好的设计原则的代码都具备较好的测试性。比如比较高的内聚性，尽量依赖于接口等。<br>及时重构。无论是功能代码还是测试代码，对结构不合理，重复的代码等情况，在测试通过后，及时进行重构。关于重构，我会另撰文详细分析。<br>小步前进。软件开发是个复杂性非常高的工作，开发过程中要考虑很多东西，包括代码的正确性、可扩展性、性能等等，很多问题都是因为复杂性太大导致的。极限编程提出了一个非常好的思路就是小步前进。把所有的规模大、复杂性高的工作，分解成小的任务来完成。对于一个类来说，一个功能一个功能的完成，如果太困难就再分解。每个功能的完成就走测试代码－功能代码－测试－重构的循环。通过分解降低整个系统开发的复杂性。这样的效果非常明显。几个小的功能代码完成后，大的功能代码几乎是不用调试就可以通过。一个个类方法的实现，很快就看到整个类很快就完成啦。本来感觉很多特性需要增加，很快就会看到没有几个啦。你甚至会为这个速度感到震惊。（我理解，是大幅度减少调试、出错的时间产生的这种速度感）</p>\n<h2 id=\"5-测试技术\"><a href=\"#5-测试技术\" class=\"headerlink\" title=\"5. 测试技术\"></a>5. 测试技术</h2><p>5.1. 测试范围、粒度<br>对哪些功能进行测试？会不会太繁琐？什么时候可以停止测试？这些问题比较常见。按大师 Kent Benk 的话，对那些你认为应该测试的代码进行测试。就是说，要相信自己的感觉，自己的经验。那些重要的功能、核心的代码就应该重点测试。感到疲劳就应该停下来休息一下。感觉没有必要更详细的测试，就停止本轮测试。<br>测试驱动开发强调测试并不应该是负担，而应该是帮助我们减轻工作量的方法。而对于何时停止编写测试用例，也是应该根据你的经验，功能复杂、核心功能的代码就应该编写更全面、细致的测试用例，否则测试流程即可。<br>测试范围没有静态的标准，同时也应该可以随着时间改变。对于开始没有编写足够的测试的功能代码，随着bug的出现，根据bug补齐相关的测试用例即可。<br>小步前进的原则，要求我们对大的功能块测试时，应该先分拆成更小的功能块进行测试，比如一个类A使用了类B、C，就应该编写到A使用B、C功能的测试代码前，完成对B、C的测试和开发。那么是不是每个小类或者小函数都应该测试哪？我认为没有必要。你应该运用你的经验，对那些可能出问题的地方重点测试，感觉不可能出问题的地方就等它真正出问题的时候再补测试吧。<br>5.2. 怎么编写测试用例<br>测试用例的编写就用上了传统的测试技术。<br>操作过程尽量模拟正常使用的过程。<br>全面的测试用例应该尽量做到分支覆盖，核心代码尽量做到路径覆盖。<br>测试数据尽量包括：真实数据、边界数据。<br>测试语句和测试数据应该尽量简单，容易理解。<br>为了避免对其他代码过多的依赖，可以实现简单的桩函数或桩类（Mock Object）。<br>如果内部状态非常复杂或者应该判断流程而不是状态，可以通过记录日志字符串的方式进行验证。</p>\n<h2 id=\"6-Tips\"><a href=\"#6-Tips\" class=\"headerlink\" title=\"6. Tips\"></a>6. Tips</h2><p>很多朋友有疑问，“测试代码的正确性如何保障？是写测试代码还是写测试文档？”这样是不是会陷入“鸡生蛋，蛋生鸡”的循环。其实是不会的。通常测试代码通常是非常简单的，通常围绕着某个情况的正确性判断的几个语句，如果太复杂，就应该继续分解啦。而传统的开发过程通常强调测试文档。但随着开发节奏的加快，用户需求的不断变化，维护高层（需求、概要设计）的测试文档可以，更低层的测试文档的成本的确太大了。而且可实时验证功能正确性的测试代码就是对代码最好的文档。<br>软件开发过程中，除了遵守上面提到的测试驱动开发的几个原则外，一个需要注意的问题就是，谨防过度设计。编写功能代码时应该关注于完成当前功能点，通过测试，使用最简单、直接的方式来编码。过多的考虑后期的扩展，其他功能的添加，无疑增加了过多的复杂性，容易产生问题。应该等到要添加这些特性时在进行详细的测试驱动开发。到时候，有整套测试用例做基础，通过不断重构很容易添加相关特性。</p>\n"},{"title":"读构建之法体会","date":"2017-03-19T08:22:18.000Z","_content":"## 构建之法简介\n  软件工程牵涉的范围很广, 同时也是一般院校的同学反映比较空洞乏味的课程。 但是 软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让 同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。\n  我将逐章的概述内容及我读完之后的感受\n## 第1章概论\n首先一上来提到了一个公式：软件=程序+软件工程\n之后提出了三个问题或者叫做三个现象吧。之后讲了一个例子：从一个出30道加减法的题扩展到一个具有各种功能而且庞大的web应用。在这个例子中就会设计一些算法和数据结构，我想应该没有人会写这样的库给开发者用，所以需要自己去写一些算法和数据结构。后面引出了，程序的运行环境、源代码管理、软件的质量保证的过程是软件测试、绣球分析、软件维护、软件的生命周期和用户体验等概念。上述皆为软件开发活动行管的内容。\n之后提到了软件团队赚钱的方式。再从广义上的软件工程也包括用户体验、用户界面等。从而推出一个公式：软件＝程序＋软件工程。又从中扩展到软件企业＝软件＋商业模式。\n用折纸飞机的玩具阶段、用氢气球飞上天的业余爱好阶段、莱特兄弟制造飞机的探索阶段、现在的航空业的成熟的产业阶段类比软件开发的不同阶段：\n![Alt text](/images/soft classify.png)\n软件工程是把系统的、有序的、可量化的放大应用到软件的开发、运营和维护上的过程。介绍了软件工程包含了哪些领域以及与软件工程相关的一些领域。简单介绍了一下软件开发流程和一些工具。\n软件的特殊性共总结了五点内容：\n- **复杂性**\n- **不可见性**\n- **易变性**\n- **服从性**\n- **非连续性**\n之后对软件工程和计算机科学之间的关系、侧重点和领域等做出比较。\n最后谈了谈bug的来历。\n\n## 总结\n在我看来就是造轮子和用轮子，作为java程序员想快速做出一个网站，不算是难事，即便用上SSM(Spring MVC,Spring,Mybatis)再加上基于RESTFul API的Swagger实现前后端分离的契约。还是加上缓存redis等技术对于数据结构和算法运用的不是很多基本上都是围绕着对数据库的增、删、改、查，这几个操作。肯定会有这个阶段，我们只需要会用轮子，还需要关注轮子是怎么造的嘛？在我看来数据结构和算法是一个编程员的基本功。所以基本功往往不是一时半会可以出效果的，如果不在乎这些基本功，也许一年两年在工作中不会体现，不过在这个领域呆的时间越久我确信，没有这些基本功作为保证，以后会遇见各种各样的瓶颈。\n","source":"_posts/读构建之法体会.md","raw":"---\ntitle: 读构建之法体会\ndate: 2017-03-19 16:22:18\ntags:\n---\n## 构建之法简介\n  软件工程牵涉的范围很广, 同时也是一般院校的同学反映比较空洞乏味的课程。 但是 软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让 同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。\n  我将逐章的概述内容及我读完之后的感受\n## 第1章概论\n首先一上来提到了一个公式：软件=程序+软件工程\n之后提出了三个问题或者叫做三个现象吧。之后讲了一个例子：从一个出30道加减法的题扩展到一个具有各种功能而且庞大的web应用。在这个例子中就会设计一些算法和数据结构，我想应该没有人会写这样的库给开发者用，所以需要自己去写一些算法和数据结构。后面引出了，程序的运行环境、源代码管理、软件的质量保证的过程是软件测试、绣球分析、软件维护、软件的生命周期和用户体验等概念。上述皆为软件开发活动行管的内容。\n之后提到了软件团队赚钱的方式。再从广义上的软件工程也包括用户体验、用户界面等。从而推出一个公式：软件＝程序＋软件工程。又从中扩展到软件企业＝软件＋商业模式。\n用折纸飞机的玩具阶段、用氢气球飞上天的业余爱好阶段、莱特兄弟制造飞机的探索阶段、现在的航空业的成熟的产业阶段类比软件开发的不同阶段：\n![Alt text](/images/soft classify.png)\n软件工程是把系统的、有序的、可量化的放大应用到软件的开发、运营和维护上的过程。介绍了软件工程包含了哪些领域以及与软件工程相关的一些领域。简单介绍了一下软件开发流程和一些工具。\n软件的特殊性共总结了五点内容：\n- **复杂性**\n- **不可见性**\n- **易变性**\n- **服从性**\n- **非连续性**\n之后对软件工程和计算机科学之间的关系、侧重点和领域等做出比较。\n最后谈了谈bug的来历。\n\n## 总结\n在我看来就是造轮子和用轮子，作为java程序员想快速做出一个网站，不算是难事，即便用上SSM(Spring MVC,Spring,Mybatis)再加上基于RESTFul API的Swagger实现前后端分离的契约。还是加上缓存redis等技术对于数据结构和算法运用的不是很多基本上都是围绕着对数据库的增、删、改、查，这几个操作。肯定会有这个阶段，我们只需要会用轮子，还需要关注轮子是怎么造的嘛？在我看来数据结构和算法是一个编程员的基本功。所以基本功往往不是一时半会可以出效果的，如果不在乎这些基本功，也许一年两年在工作中不会体现，不过在这个领域呆的时间越久我确信，没有这些基本功作为保证，以后会遇见各种各样的瓶颈。\n","slug":"读构建之法体会","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6pz000bhhu29kp51do1","content":"<h2 id=\"构建之法简介\"><a href=\"#构建之法简介\" class=\"headerlink\" title=\"构建之法简介\"></a>构建之法简介</h2><p>  软件工程牵涉的范围很广, 同时也是一般院校的同学反映比较空洞乏味的课程。 但是 软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让 同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。<br>  我将逐章的概述内容及我读完之后的感受</p>\n<h2 id=\"第1章概论\"><a href=\"#第1章概论\" class=\"headerlink\" title=\"第1章概论\"></a>第1章概论</h2><p>首先一上来提到了一个公式：软件=程序+软件工程<br>之后提出了三个问题或者叫做三个现象吧。之后讲了一个例子：从一个出30道加减法的题扩展到一个具有各种功能而且庞大的web应用。在这个例子中就会设计一些算法和数据结构，我想应该没有人会写这样的库给开发者用，所以需要自己去写一些算法和数据结构。后面引出了，程序的运行环境、源代码管理、软件的质量保证的过程是软件测试、绣球分析、软件维护、软件的生命周期和用户体验等概念。上述皆为软件开发活动行管的内容。<br>之后提到了软件团队赚钱的方式。再从广义上的软件工程也包括用户体验、用户界面等。从而推出一个公式：软件＝程序＋软件工程。又从中扩展到软件企业＝软件＋商业模式。<br>用折纸飞机的玩具阶段、用氢气球飞上天的业余爱好阶段、莱特兄弟制造飞机的探索阶段、现在的航空业的成熟的产业阶段类比软件开发的不同阶段：<br><img src=\"/images/soft classify.png\" alt=\"Alt text\"><br>软件工程是把系统的、有序的、可量化的放大应用到软件的开发、运营和维护上的过程。介绍了软件工程包含了哪些领域以及与软件工程相关的一些领域。简单介绍了一下软件开发流程和一些工具。<br>软件的特殊性共总结了五点内容：</p>\n<ul>\n<li><strong>复杂性</strong></li>\n<li><strong>不可见性</strong></li>\n<li><strong>易变性</strong></li>\n<li><strong>服从性</strong></li>\n<li><strong>非连续性</strong><br>之后对软件工程和计算机科学之间的关系、侧重点和领域等做出比较。<br>最后谈了谈bug的来历。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在我看来就是造轮子和用轮子，作为java程序员想快速做出一个网站，不算是难事，即便用上SSM(Spring MVC,Spring,Mybatis)再加上基于RESTFul API的Swagger实现前后端分离的契约。还是加上缓存redis等技术对于数据结构和算法运用的不是很多基本上都是围绕着对数据库的增、删、改、查，这几个操作。肯定会有这个阶段，我们只需要会用轮子，还需要关注轮子是怎么造的嘛？在我看来数据结构和算法是一个编程员的基本功。所以基本功往往不是一时半会可以出效果的，如果不在乎这些基本功，也许一年两年在工作中不会体现，不过在这个领域呆的时间越久我确信，没有这些基本功作为保证，以后会遇见各种各样的瓶颈。</p>\n","excerpt":"","more":"<h2 id=\"构建之法简介\"><a href=\"#构建之法简介\" class=\"headerlink\" title=\"构建之法简介\"></a>构建之法简介</h2><p>  软件工程牵涉的范围很广, 同时也是一般院校的同学反映比较空洞乏味的课程。 但是 软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让 同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。<br>  我将逐章的概述内容及我读完之后的感受</p>\n<h2 id=\"第1章概论\"><a href=\"#第1章概论\" class=\"headerlink\" title=\"第1章概论\"></a>第1章概论</h2><p>首先一上来提到了一个公式：软件=程序+软件工程<br>之后提出了三个问题或者叫做三个现象吧。之后讲了一个例子：从一个出30道加减法的题扩展到一个具有各种功能而且庞大的web应用。在这个例子中就会设计一些算法和数据结构，我想应该没有人会写这样的库给开发者用，所以需要自己去写一些算法和数据结构。后面引出了，程序的运行环境、源代码管理、软件的质量保证的过程是软件测试、绣球分析、软件维护、软件的生命周期和用户体验等概念。上述皆为软件开发活动行管的内容。<br>之后提到了软件团队赚钱的方式。再从广义上的软件工程也包括用户体验、用户界面等。从而推出一个公式：软件＝程序＋软件工程。又从中扩展到软件企业＝软件＋商业模式。<br>用折纸飞机的玩具阶段、用氢气球飞上天的业余爱好阶段、莱特兄弟制造飞机的探索阶段、现在的航空业的成熟的产业阶段类比软件开发的不同阶段：<br><img src=\"/images/soft classify.png\" alt=\"Alt text\"><br>软件工程是把系统的、有序的、可量化的放大应用到软件的开发、运营和维护上的过程。介绍了软件工程包含了哪些领域以及与软件工程相关的一些领域。简单介绍了一下软件开发流程和一些工具。<br>软件的特殊性共总结了五点内容：</p>\n<ul>\n<li><strong>复杂性</strong></li>\n<li><strong>不可见性</strong></li>\n<li><strong>易变性</strong></li>\n<li><strong>服从性</strong></li>\n<li><strong>非连续性</strong><br>之后对软件工程和计算机科学之间的关系、侧重点和领域等做出比较。<br>最后谈了谈bug的来历。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在我看来就是造轮子和用轮子，作为java程序员想快速做出一个网站，不算是难事，即便用上SSM(Spring MVC,Spring,Mybatis)再加上基于RESTFul API的Swagger实现前后端分离的契约。还是加上缓存redis等技术对于数据结构和算法运用的不是很多基本上都是围绕着对数据库的增、删、改、查，这几个操作。肯定会有这个阶段，我们只需要会用轮子，还需要关注轮子是怎么造的嘛？在我看来数据结构和算法是一个编程员的基本功。所以基本功往往不是一时半会可以出效果的，如果不在乎这些基本功，也许一年两年在工作中不会体现，不过在这个领域呆的时间越久我确信，没有这些基本功作为保证，以后会遇见各种各样的瓶颈。</p>\n"},{"title":"C++内联函数","date":"2017-04-25T04:47:36.000Z","_content":"# Overhead for a function call\n- **the processing time required by a device prior to the execution of a command**:\n - **Push parameters**: 将函数的参数推到栈里面去\n\n - **Push return address**:把返回地址推到栈里面去\n - **Prepare return values**:准备返回的值\n - **Pop all pushed**:把所有推进栈里面的东西都赶出来\n# inline Function\n上述这么多额外的事情，可以用一个手段来避免产生这些额外的开销\nC++给我们提供了一种方式，就是内联函数。内联函数我们在调用它的时候，并不是会产生那些动作（push,pop,return,call），\n而是把那个函数的代码嵌入到那个地方去，但是仍然保持函数的独立性（函数独有的空间，对参数类型的检查等）。\n当然，如果你的函数是inline的，这个函数就不会出现在最终的可执行代码里面。它只会出现在编译器里面。\n如果你想写函数是inline的话，在.h和.cpp必须都要在函数前面写上inline。实际上.h和.cpp是写给不同人看的，\n.cpp是用来产生那个函数的，.h是用来给调用这个函数的地方看的。.cpp里面有没有inline是让编译器生成不生成这个函数的，有inline就不生成这个函数。头文件里面的inline是告诉，这个地方你不能生成调用它的那个代码，要把函数体拆进来。\n## 代码 main.cpp\n``` C++\n#include \"a.h\"\n\nint main(int argc, char const *argv[])\n{\n\tf(10,10);\n\treturn 0;\n}\n```\n## 代码 a.cpp\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\ninline void f(int i,int j){\n\tcout<<i<<\"  \"<<j<<endl;\n\n}\n```\n## 代码 a.h\n``` C++\ninline void f(int i,int j);\n```\n出错信息：\n![Alt text](/images/C++/inline1.png)\n这个warning说这个函数是inline的但是却没有定义。linker说main.cpp要用的这个f函数不存在。\n我们可以cpp main.cpp 看一下。cpp 这个命令是编译预处理器。\n![Alt text](/images/C++/inline2.png)\n编译器在编译的时候是按照，每一个编译单元去编译的，也就是每一个文件去编译。\n通过cpp可以看到并没有定义函数体，所以是没有办法插进去的。所以只能放弃将f函数做内联。\n而a.o中没有产生任何代码因为它是inline的，所以a.o中没有f函数的痕迹在的，当link的时候就出现问题了\nmain.cpp说我要个f函数，然后a.cpp里又没有f函数。所以我们应该把f函数的body放在a.h里面去。\n## 代码 a.h\n``` c++\n#include <iostream>\nusing namespace std;\ninline void f(int i,int j);\ninline void f(int i,int j){\n\tcout<<i<<\"  \"<<j<<endl;\n\n}\n```\n编译过了，运行也正常了\n所以这是一种权衡（tradeoff）\n有inline之后，对于之前的用法就会不一样，之前的用法是说你的每一个类应该会有对应的.cpp和对应的一个.h，.h里面放的是声明，而.cpp里放的是定义。\n而inline函数这种函数的定义就不再是个定义，而是个声明，因此它不能放.cpp，只放在.h就够了。所以对应上面的代码来说，不需要有a.cpp有a.h就够了.h把所有inline的函数的body都放进去，就可以了。\n对于inline函数而言，用inline函数就意味着，在这个函数被调用的时候，函数的代码会被插入到被调用的地方，这也意味着你的代码会变长程序会变大，因此它会牺牲代码的空间但是它会降低调用函数的overhead（额外的开销），这是典型的以空间换时间的策略。\n这种方式比C的宏要好，C的宏不会进行类型检查，而inline会进行类型检查，所以inline比宏要好要安全。\n## 注意\n但是编译器也会做一个这样的事情，它如果发现你的inline函数过于巨大它可能会拒绝这个inline函数作为inline（inline函数内部做了很复杂的循环或者内部做了递归）\n如果是成员函数\n例如这个\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\nclass A{\n\tpublic :\n\t\tvoid f(){cout<<\"f()\"<<endl;};\n};\n\n```\nf函数体直接写在后面了，这样就不用在写.cpp了只要写一个.h就可以了\n放在头文件里\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\nclass A{\n\tpublic :\n\t\tvoid f();\n};\n\ninline void A::f(){\n\tcout<<\"f()\"<<endl;\n}\n```\n所以加了inline这个函数就不是定义而是声明，然后他不在class里面，而在class外面。\n这样做的好处是，class会很清爽。\n","source":"_posts/C++/C++内联函数.md","raw":"---\ntitle: C++内联函数\ndate: 2017-04-25 12:47:36\ntags:\ncategories: C++\n---\n# Overhead for a function call\n- **the processing time required by a device prior to the execution of a command**:\n - **Push parameters**: 将函数的参数推到栈里面去\n\n - **Push return address**:把返回地址推到栈里面去\n - **Prepare return values**:准备返回的值\n - **Pop all pushed**:把所有推进栈里面的东西都赶出来\n# inline Function\n上述这么多额外的事情，可以用一个手段来避免产生这些额外的开销\nC++给我们提供了一种方式，就是内联函数。内联函数我们在调用它的时候，并不是会产生那些动作（push,pop,return,call），\n而是把那个函数的代码嵌入到那个地方去，但是仍然保持函数的独立性（函数独有的空间，对参数类型的检查等）。\n当然，如果你的函数是inline的，这个函数就不会出现在最终的可执行代码里面。它只会出现在编译器里面。\n如果你想写函数是inline的话，在.h和.cpp必须都要在函数前面写上inline。实际上.h和.cpp是写给不同人看的，\n.cpp是用来产生那个函数的，.h是用来给调用这个函数的地方看的。.cpp里面有没有inline是让编译器生成不生成这个函数的，有inline就不生成这个函数。头文件里面的inline是告诉，这个地方你不能生成调用它的那个代码，要把函数体拆进来。\n## 代码 main.cpp\n``` C++\n#include \"a.h\"\n\nint main(int argc, char const *argv[])\n{\n\tf(10,10);\n\treturn 0;\n}\n```\n## 代码 a.cpp\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\ninline void f(int i,int j){\n\tcout<<i<<\"  \"<<j<<endl;\n\n}\n```\n## 代码 a.h\n``` C++\ninline void f(int i,int j);\n```\n出错信息：\n![Alt text](/images/C++/inline1.png)\n这个warning说这个函数是inline的但是却没有定义。linker说main.cpp要用的这个f函数不存在。\n我们可以cpp main.cpp 看一下。cpp 这个命令是编译预处理器。\n![Alt text](/images/C++/inline2.png)\n编译器在编译的时候是按照，每一个编译单元去编译的，也就是每一个文件去编译。\n通过cpp可以看到并没有定义函数体，所以是没有办法插进去的。所以只能放弃将f函数做内联。\n而a.o中没有产生任何代码因为它是inline的，所以a.o中没有f函数的痕迹在的，当link的时候就出现问题了\nmain.cpp说我要个f函数，然后a.cpp里又没有f函数。所以我们应该把f函数的body放在a.h里面去。\n## 代码 a.h\n``` c++\n#include <iostream>\nusing namespace std;\ninline void f(int i,int j);\ninline void f(int i,int j){\n\tcout<<i<<\"  \"<<j<<endl;\n\n}\n```\n编译过了，运行也正常了\n所以这是一种权衡（tradeoff）\n有inline之后，对于之前的用法就会不一样，之前的用法是说你的每一个类应该会有对应的.cpp和对应的一个.h，.h里面放的是声明，而.cpp里放的是定义。\n而inline函数这种函数的定义就不再是个定义，而是个声明，因此它不能放.cpp，只放在.h就够了。所以对应上面的代码来说，不需要有a.cpp有a.h就够了.h把所有inline的函数的body都放进去，就可以了。\n对于inline函数而言，用inline函数就意味着，在这个函数被调用的时候，函数的代码会被插入到被调用的地方，这也意味着你的代码会变长程序会变大，因此它会牺牲代码的空间但是它会降低调用函数的overhead（额外的开销），这是典型的以空间换时间的策略。\n这种方式比C的宏要好，C的宏不会进行类型检查，而inline会进行类型检查，所以inline比宏要好要安全。\n## 注意\n但是编译器也会做一个这样的事情，它如果发现你的inline函数过于巨大它可能会拒绝这个inline函数作为inline（inline函数内部做了很复杂的循环或者内部做了递归）\n如果是成员函数\n例如这个\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\nclass A{\n\tpublic :\n\t\tvoid f(){cout<<\"f()\"<<endl;};\n};\n\n```\nf函数体直接写在后面了，这样就不用在写.cpp了只要写一个.h就可以了\n放在头文件里\n``` C++\n#include <iostream>\nusing namespace std;\n#include \"a.h\"\n\nclass A{\n\tpublic :\n\t\tvoid f();\n};\n\ninline void A::f(){\n\tcout<<\"f()\"<<endl;\n}\n```\n所以加了inline这个函数就不是定义而是声明，然后他不在class里面，而在class外面。\n这样做的好处是，class会很清爽。\n","slug":"C++/C++内联函数","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6s7000chhu2suxwu7pw","content":"<h1 id=\"Overhead-for-a-function-call\"><a href=\"#Overhead-for-a-function-call\" class=\"headerlink\" title=\"Overhead for a function call\"></a>Overhead for a function call</h1><ul>\n<li><p><strong>the processing time required by a device prior to the execution of a command</strong>:</p>\n<ul>\n<li><p><strong>Push parameters</strong>: 将函数的参数推到栈里面去</p>\n</li>\n<li><p><strong>Push return address</strong>:把返回地址推到栈里面去</p>\n</li>\n<li><strong>Prepare return values</strong>:准备返回的值</li>\n<li><strong>Pop all pushed</strong>:把所有推进栈里面的东西都赶出来<h1 id=\"inline-Function\"><a href=\"#inline-Function\" class=\"headerlink\" title=\"inline Function\"></a>inline Function</h1>上述这么多额外的事情，可以用一个手段来避免产生这些额外的开销<br>C++给我们提供了一种方式，就是内联函数。内联函数我们在调用它的时候，并不是会产生那些动作（push,pop,return,call），<br>而是把那个函数的代码嵌入到那个地方去，但是仍然保持函数的独立性（函数独有的空间，对参数类型的检查等）。<br>当然，如果你的函数是inline的，这个函数就不会出现在最终的可执行代码里面。它只会出现在编译器里面。<br>如果你想写函数是inline的话，在.h和.cpp必须都要在函数前面写上inline。实际上.h和.cpp是写给不同人看的，<br>.cpp是用来产生那个函数的，.h是用来给调用这个函数的地方看的。.cpp里面有没有inline是让编译器生成不生成这个函数的，有inline就不生成这个函数。头文件里面的inline是告诉，这个地方你不能生成调用它的那个代码，要把函数体拆进来。<h2 id=\"代码-main-cpp\"><a href=\"#代码-main-cpp\" class=\"headerlink\" title=\"代码 main.cpp\"></a>代码 main.cpp</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tf(<span class=\"number\">10</span>,<span class=\"number\">10</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码-a-cpp\"><a href=\"#代码-a-cpp\" class=\"headerlink\" title=\"代码 a.cpp\"></a>代码 a.cpp</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\"  \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"代码-a-h\"><a href=\"#代码-a-h\" class=\"headerlink\" title=\"代码 a.h\"></a>代码 a.h</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>;</div></pre></td></tr></table></figure>\n<p>出错信息：<br><img src=\"/images/C++/inline1.png\" alt=\"Alt text\"><br>这个warning说这个函数是inline的但是却没有定义。linker说main.cpp要用的这个f函数不存在。<br>我们可以cpp main.cpp 看一下。cpp 这个命令是编译预处理器。<br><img src=\"/images/C++/inline2.png\" alt=\"Alt text\"><br>编译器在编译的时候是按照，每一个编译单元去编译的，也就是每一个文件去编译。<br>通过cpp可以看到并没有定义函数体，所以是没有办法插进去的。所以只能放弃将f函数做内联。<br>而a.o中没有产生任何代码因为它是inline的，所以a.o中没有f函数的痕迹在的，当link的时候就出现问题了<br>main.cpp说我要个f函数，然后a.cpp里又没有f函数。所以我们应该把f函数的body放在a.h里面去。</p>\n<h2 id=\"代码-a-h-1\"><a href=\"#代码-a-h-1\" class=\"headerlink\" title=\"代码 a.h\"></a>代码 a.h</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\"  \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译过了，运行也正常了<br>所以这是一种权衡（tradeoff）<br>有inline之后，对于之前的用法就会不一样，之前的用法是说你的每一个类应该会有对应的.cpp和对应的一个.h，.h里面放的是声明，而.cpp里放的是定义。<br>而inline函数这种函数的定义就不再是个定义，而是个声明，因此它不能放.cpp，只放在.h就够了。所以对应上面的代码来说，不需要有a.cpp有a.h就够了.h把所有inline的函数的body都放进去，就可以了。<br>对于inline函数而言，用inline函数就意味着，在这个函数被调用的时候，函数的代码会被插入到被调用的地方，这也意味着你的代码会变长程序会变大，因此它会牺牲代码的空间但是它会降低调用函数的overhead（额外的开销），这是典型的以空间换时间的策略。<br>这种方式比C的宏要好，C的宏不会进行类型检查，而inline会进行类型检查，所以inline比宏要好要安全。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>但是编译器也会做一个这样的事情，它如果发现你的inline函数过于巨大它可能会拒绝这个inline函数作为inline（inline函数内部做了很复杂的循环或者内部做了递归）<br>如果是成员函数<br>例如这个<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"f()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>f函数体直接写在后面了，这样就不用在写.cpp了只要写一个.h就可以了<br>放在头文件里<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> A::f()&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"f()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以加了inline这个函数就不是定义而是声明，然后他不在class里面，而在class外面。<br>这样做的好处是，class会很清爽。</p>\n","excerpt":"","more":"<h1 id=\"Overhead-for-a-function-call\"><a href=\"#Overhead-for-a-function-call\" class=\"headerlink\" title=\"Overhead for a function call\"></a>Overhead for a function call</h1><ul>\n<li><p><strong>the processing time required by a device prior to the execution of a command</strong>:</p>\n<ul>\n<li><p><strong>Push parameters</strong>: 将函数的参数推到栈里面去</p>\n</li>\n<li><p><strong>Push return address</strong>:把返回地址推到栈里面去</p>\n</li>\n<li><strong>Prepare return values</strong>:准备返回的值</li>\n<li><strong>Pop all pushed</strong>:把所有推进栈里面的东西都赶出来<h1 id=\"inline-Function\"><a href=\"#inline-Function\" class=\"headerlink\" title=\"inline Function\"></a>inline Function</h1>上述这么多额外的事情，可以用一个手段来避免产生这些额外的开销<br>C++给我们提供了一种方式，就是内联函数。内联函数我们在调用它的时候，并不是会产生那些动作（push,pop,return,call），<br>而是把那个函数的代码嵌入到那个地方去，但是仍然保持函数的独立性（函数独有的空间，对参数类型的检查等）。<br>当然，如果你的函数是inline的，这个函数就不会出现在最终的可执行代码里面。它只会出现在编译器里面。<br>如果你想写函数是inline的话，在.h和.cpp必须都要在函数前面写上inline。实际上.h和.cpp是写给不同人看的，<br>.cpp是用来产生那个函数的，.h是用来给调用这个函数的地方看的。.cpp里面有没有inline是让编译器生成不生成这个函数的，有inline就不生成这个函数。头文件里面的inline是告诉，这个地方你不能生成调用它的那个代码，要把函数体拆进来。<h2 id=\"代码-main-cpp\"><a href=\"#代码-main-cpp\" class=\"headerlink\" title=\"代码 main.cpp\"></a>代码 main.cpp</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tf(<span class=\"number\">10</span>,<span class=\"number\">10</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码-a-cpp\"><a href=\"#代码-a-cpp\" class=\"headerlink\" title=\"代码 a.cpp\"></a>代码 a.cpp</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\"  \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"代码-a-h\"><a href=\"#代码-a-h\" class=\"headerlink\" title=\"代码 a.h\"></a>代码 a.h</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>;</div></pre></td></tr></table></figure>\n<p>出错信息：<br><img src=\"/images/C++/inline1.png\" alt=\"Alt text\"><br>这个warning说这个函数是inline的但是却没有定义。linker说main.cpp要用的这个f函数不存在。<br>我们可以cpp main.cpp 看一下。cpp 这个命令是编译预处理器。<br><img src=\"/images/C++/inline2.png\" alt=\"Alt text\"><br>编译器在编译的时候是按照，每一个编译单元去编译的，也就是每一个文件去编译。<br>通过cpp可以看到并没有定义函数体，所以是没有办法插进去的。所以只能放弃将f函数做内联。<br>而a.o中没有产生任何代码因为它是inline的，所以a.o中没有f函数的痕迹在的，当link的时候就出现问题了<br>main.cpp说我要个f函数，然后a.cpp里又没有f函数。所以我们应该把f函数的body放在a.h里面去。</p>\n<h2 id=\"代码-a-h-1\"><a href=\"#代码-a-h-1\" class=\"headerlink\" title=\"代码 a.h\"></a>代码 a.h</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;i&lt;&lt;<span class=\"string\">\"  \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>编译过了，运行也正常了<br>所以这是一种权衡（tradeoff）<br>有inline之后，对于之前的用法就会不一样，之前的用法是说你的每一个类应该会有对应的.cpp和对应的一个.h，.h里面放的是声明，而.cpp里放的是定义。<br>而inline函数这种函数的定义就不再是个定义，而是个声明，因此它不能放.cpp，只放在.h就够了。所以对应上面的代码来说，不需要有a.cpp有a.h就够了.h把所有inline的函数的body都放进去，就可以了。<br>对于inline函数而言，用inline函数就意味着，在这个函数被调用的时候，函数的代码会被插入到被调用的地方，这也意味着你的代码会变长程序会变大，因此它会牺牲代码的空间但是它会降低调用函数的overhead（额外的开销），这是典型的以空间换时间的策略。<br>这种方式比C的宏要好，C的宏不会进行类型检查，而inline会进行类型检查，所以inline比宏要好要安全。</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>但是编译器也会做一个这样的事情，它如果发现你的inline函数过于巨大它可能会拒绝这个inline函数作为inline（inline函数内部做了很复杂的循环或者内部做了递归）<br>如果是成员函数<br>例如这个<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"f()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>f函数体直接写在后面了，这样就不用在写.cpp了只要写一个.h就可以了<br>放在头文件里<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> A::f()&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"f()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>所以加了inline这个函数就不是定义而是声明，然后他不在class里面，而在class外面。<br>这样做的好处是，class会很清爽。</p>\n"},{"title":"Const","date":"2017-05-05T04:50:51.000Z","_content":"# Const\n在C语言当中的，这个变量加上一个Const关键字之后，这个变量被初始化之后呢，就不能赋值。\n![Alt text](/images/C++/const1.png)\n但是由于指针的存在，就出现一个问题，就是这个const是修饰谁的，比如:\n``` c++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *p = &i;\n\tcout<<*p<<endl;\n\t*p = 2;\n\treturn 0;\n}\n```\n会在第9行报错，error: read-only variable is not assignable\n说这个变量是只读的，变量是不能被赋值的。\n说明这个指针所指的这个对象是const的是不能被修改的，但是指针变量还是可以修改的。\n\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *p = &i;\n\tcout<<*p<<endl;\n\tp++;\n\treturn 0;\n}\n```\n没有报错。我们再看两个例子：\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tint *const p = &i;\n\tcout<<*p<<endl;\n\t*p = 2;\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这个没有报错，输出是：\n10\n2\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tint *const p = &i;\n\tcout<<*p<<endl;\n\tp++;\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这个报错了，error: cannot assign to variable 'p' with const-qualified type 'int *const'\n说不能对变量p赋值，因为这个指针p是被const修饰的，是类型'int *const'\n这个指针p所指向的那个变量的值被修改了，但是p不能被修改，说明这个const修饰的是指针变量p，所以指针变量p不能被修改。\n这就有一个问题了，怎么区分呢？其实有一个小技巧\n```C++\nconst int *p = &i; // 看这个*号，const在星号左边说明是指针所指的那个变量是const的\nint *const p = &i; // const在星号右边说明这个指针p是const的\n```\n当然你可以都让它们是const的，让指针是const的同时，让指针所指的那个变量（内存空间）也都是const\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *const p = &i;\n\tp++;  // 这里会有错，error: cannot assign to variable 'p' with const-qualified type 'int *const'\n\tcout<<*p<<endl;\n\t*p = 2; // 这里会有错，error: read-only variable is not assignable\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这样两个变量都是const的了\n接下来再试一件事情\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tchar *s = \"hello world\";\n\tcout<<s<<endl;\n\ts[0] = 'B';\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n我 g++ 了一下，有一个warning:\n![Alt text](/images/C++/const2.png)\n如果我先无视这个warning ./a.out 一下\n![Alt text](/images/C++/const3.png)\n它输出了这个 hello world 之后程序异常终止了。\n前面的那个warning 的意思是说：conversion from string literal to 'char *' is deprecated\n说这事已经过时了，这个意思是说你想将\"hello world\"这个字符串交给char *是不对的，做了修改之后程序就崩溃了。\n实际上事情是这样的，s在栈里面，因为是本地变量（本地变量和函数的参数列表的变量都在栈里面）s是一个指针，它指向了一块内存，也就是说\"hello world\"是一块内存，内存又分为三种不同的地方，本地变量是放在，栈里面，new出来的东西是放在堆里面，然后全局变量在一个全局数据区里面。而全局变量里面的这种常量，是在代码段里的，因为\"hello world\"是一个常量，所以尽管我们没有在s前面加上const，实际上它是const的。它被放在了代码段里面，而代码段是不可写的。现在说有的操作系统，都是葱花1970年代出得那个Unix，现代操作系统的基本理论是从那里来的，所以不管外表是什么样，里面东西是一样的。你的程序运行起来之后，你的程序会从操作系统得到一块内存，这块内存当然是虚拟的，但是这块内存是独立的，每个进程，每个程序都有独立的内存。每块内存从0开始，在计算机的内部有一个计算机的硬件，MMU内存管理单元。由它来管这件事情，它会划分，从0开始到0x000xxx是代码段，如果你去试图去写这个代码段，就会有错：Bus error，实际上是MMU的地方出了错。\n这是这件事情，假如：\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\t// char *s = \"hello world\";\n\tchar s[] = \"hello world\";\n\tcout<<s<<endl;\n\ts[0] = 'B';\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n输出：\nhello world\nBello world\n没有warning、没有error\n说明了 char[] s = \"hello world\";\n做了一件事，将代码段里的\"hello world\" 复制到栈里面了，存在本地变量里面。\n可以写一个程序来验证。\n``` C++\n#include <stdio.h>\n\n\nint main(int argc, char const *argv[])\n{\n\tconst char *s1 = \"hello world\";\n\tchar s2[] = \"hello world\";\n\tprintf(\"s1  =%p\\n\",s1);\n\tprintf(\"s2  =%p\\n\",s2);\n    printf(\"main=%p\\n\",main;\n\treturn 0;\n}\n```\n之后我们编译运行一下输出：\n![Alt text](/images/C++/const4.png)\n明显地址是不同的，char *s1 是比较靠前的地址，所以它在代码段里的\n同时也看了main函数的地址，也是比较靠前的\n","source":"_posts/C++/Const.md","raw":"---\ntitle: Const\ndate: 2017-05-05 12:50:51\ntags:\ncategories: C++\n---\n# Const\n在C语言当中的，这个变量加上一个Const关键字之后，这个变量被初始化之后呢，就不能赋值。\n![Alt text](/images/C++/const1.png)\n但是由于指针的存在，就出现一个问题，就是这个const是修饰谁的，比如:\n``` c++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *p = &i;\n\tcout<<*p<<endl;\n\t*p = 2;\n\treturn 0;\n}\n```\n会在第9行报错，error: read-only variable is not assignable\n说这个变量是只读的，变量是不能被赋值的。\n说明这个指针所指的这个对象是const的是不能被修改的，但是指针变量还是可以修改的。\n\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *p = &i;\n\tcout<<*p<<endl;\n\tp++;\n\treturn 0;\n}\n```\n没有报错。我们再看两个例子：\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tint *const p = &i;\n\tcout<<*p<<endl;\n\t*p = 2;\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这个没有报错，输出是：\n10\n2\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tint *const p = &i;\n\tcout<<*p<<endl;\n\tp++;\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这个报错了，error: cannot assign to variable 'p' with const-qualified type 'int *const'\n说不能对变量p赋值，因为这个指针p是被const修饰的，是类型'int *const'\n这个指针p所指向的那个变量的值被修改了，但是p不能被修改，说明这个const修饰的是指针变量p，所以指针变量p不能被修改。\n这就有一个问题了，怎么区分呢？其实有一个小技巧\n```C++\nconst int *p = &i; // 看这个*号，const在星号左边说明是指针所指的那个变量是const的\nint *const p = &i; // const在星号右边说明这个指针p是const的\n```\n当然你可以都让它们是const的，让指针是const的同时，让指针所指的那个变量（内存空间）也都是const\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tint i = 10;\n\tconst int *const p = &i;\n\tp++;  // 这里会有错，error: cannot assign to variable 'p' with const-qualified type 'int *const'\n\tcout<<*p<<endl;\n\t*p = 2; // 这里会有错，error: read-only variable is not assignable\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n这样两个变量都是const的了\n接下来再试一件事情\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tchar *s = \"hello world\";\n\tcout<<s<<endl;\n\ts[0] = 'B';\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n我 g++ 了一下，有一个warning:\n![Alt text](/images/C++/const2.png)\n如果我先无视这个warning ./a.out 一下\n![Alt text](/images/C++/const3.png)\n它输出了这个 hello world 之后程序异常终止了。\n前面的那个warning 的意思是说：conversion from string literal to 'char *' is deprecated\n说这事已经过时了，这个意思是说你想将\"hello world\"这个字符串交给char *是不对的，做了修改之后程序就崩溃了。\n实际上事情是这样的，s在栈里面，因为是本地变量（本地变量和函数的参数列表的变量都在栈里面）s是一个指针，它指向了一块内存，也就是说\"hello world\"是一块内存，内存又分为三种不同的地方，本地变量是放在，栈里面，new出来的东西是放在堆里面，然后全局变量在一个全局数据区里面。而全局变量里面的这种常量，是在代码段里的，因为\"hello world\"是一个常量，所以尽管我们没有在s前面加上const，实际上它是const的。它被放在了代码段里面，而代码段是不可写的。现在说有的操作系统，都是葱花1970年代出得那个Unix，现代操作系统的基本理论是从那里来的，所以不管外表是什么样，里面东西是一样的。你的程序运行起来之后，你的程序会从操作系统得到一块内存，这块内存当然是虚拟的，但是这块内存是独立的，每个进程，每个程序都有独立的内存。每块内存从0开始，在计算机的内部有一个计算机的硬件，MMU内存管理单元。由它来管这件事情，它会划分，从0开始到0x000xxx是代码段，如果你去试图去写这个代码段，就会有错：Bus error，实际上是MMU的地方出了错。\n这是这件事情，假如：\n```C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\t// char *s = \"hello world\";\n\tchar s[] = \"hello world\";\n\tcout<<s<<endl;\n\ts[0] = 'B';\n\tcout<<s<<endl;\n\treturn 0;\n}\n```\n输出：\nhello world\nBello world\n没有warning、没有error\n说明了 char[] s = \"hello world\";\n做了一件事，将代码段里的\"hello world\" 复制到栈里面了，存在本地变量里面。\n可以写一个程序来验证。\n``` C++\n#include <stdio.h>\n\n\nint main(int argc, char const *argv[])\n{\n\tconst char *s1 = \"hello world\";\n\tchar s2[] = \"hello world\";\n\tprintf(\"s1  =%p\\n\",s1);\n\tprintf(\"s2  =%p\\n\",s2);\n    printf(\"main=%p\\n\",main;\n\treturn 0;\n}\n```\n之后我们编译运行一下输出：\n![Alt text](/images/C++/const4.png)\n明显地址是不同的，char *s1 是比较靠前的地址，所以它在代码段里的\n同时也看了main函数的地址，也是比较靠前的\n","slug":"C++/Const","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6s9000dhhu2a1pocz6v","content":"<h1 id=\"Const\"><a href=\"#Const\" class=\"headerlink\" title=\"Const\"></a>Const</h1><p>在C语言当中的，这个变量加上一个Const关键字之后，这个变量被初始化之后呢，就不能赋值。<br><img src=\"/images/C++/const1.png\" alt=\"Alt text\"><br>但是由于指针的存在，就出现一个问题，就是这个const是修饰谁的，比如:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>会在第9行报错，error: read-only variable is not assignable<br>说这个变量是只读的，变量是不能被赋值的。<br>说明这个指针所指的这个对象是const的是不能被修改的，但是指针变量还是可以修改的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tp++;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没有报错。我们再看两个例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个没有报错，输出是：<br>10<br>2<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tp++;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个报错了，error: cannot assign to variable ‘p’ with const-qualified type ‘int <em>const’<br>说不能对变量p赋值，因为这个指针p是被const修饰的，是类型’int </em>const’<br>这个指针p所指向的那个变量的值被修改了，但是p不能被修改，说明这个const修饰的是指针变量p，所以指针变量p不能被修改。<br>这就有一个问题了，怎么区分呢？其实有一个小技巧<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i; <span class=\"comment\">// 看这个*号，const在星号左边说明是指针所指的那个变量是const的</span></div><div class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i; <span class=\"comment\">// const在星号右边说明这个指针p是const的</span></div></pre></td></tr></table></figure></p>\n<p>当然你可以都让它们是const的，让指针是const的同时，让指针所指的那个变量（内存空间）也都是const<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\tp++;  <span class=\"comment\">// 这里会有错，error: cannot assign to variable 'p' with const-qualified type 'int *const'</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>; <span class=\"comment\">// 这里会有错，error: read-only variable is not assignable</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样两个变量都是const的了<br>接下来再试一件事情<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> *s = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\ts[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我 g++ 了一下，有一个warning:<br><img src=\"/images/C++/const2.png\" alt=\"Alt text\"><br>如果我先无视这个warning ./a.out 一下<br><img src=\"/images/C++/const3.png\" alt=\"Alt text\"><br>它输出了这个 hello world 之后程序异常终止了。<br>前面的那个warning 的意思是说：conversion from string literal to ‘char <em>‘ is deprecated<br>说这事已经过时了，这个意思是说你想将”hello world”这个字符串交给char </em>是不对的，做了修改之后程序就崩溃了。<br>实际上事情是这样的，s在栈里面，因为是本地变量（本地变量和函数的参数列表的变量都在栈里面）s是一个指针，它指向了一块内存，也就是说”hello world”是一块内存，内存又分为三种不同的地方，本地变量是放在，栈里面，new出来的东西是放在堆里面，然后全局变量在一个全局数据区里面。而全局变量里面的这种常量，是在代码段里的，因为”hello world”是一个常量，所以尽管我们没有在s前面加上const，实际上它是const的。它被放在了代码段里面，而代码段是不可写的。现在说有的操作系统，都是葱花1970年代出得那个Unix，现代操作系统的基本理论是从那里来的，所以不管外表是什么样，里面东西是一样的。你的程序运行起来之后，你的程序会从操作系统得到一块内存，这块内存当然是虚拟的，但是这块内存是独立的，每个进程，每个程序都有独立的内存。每块内存从0开始，在计算机的内部有一个计算机的硬件，MMU内存管理单元。由它来管这件事情，它会划分，从0开始到0x000xxx是代码段，如果你去试图去写这个代码段，就会有错：Bus error，实际上是MMU的地方出了错。<br>这是这件事情，假如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"comment\">// char *s = \"hello world\";</span></div><div class=\"line\">\t<span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\ts[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出：<br>hello world<br>Bello world<br>没有warning、没有error<br>说明了 char[] s = “hello world”;<br>做了一件事，将代码段里的”hello world” 复制到栈里面了，存在本地变量里面。<br>可以写一个程序来验证。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s1 = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span> s2[] = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s1  =%p\\n\"</span>,s1);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s2  =%p\\n\"</span>,s2);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"main=%p\\n\"</span>,main;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后我们编译运行一下输出：<br><img src=\"/images/C++/const4.png\" alt=\"Alt text\"><br>明显地址是不同的，char *s1 是比较靠前的地址，所以它在代码段里的<br>同时也看了main函数的地址，也是比较靠前的</p>\n","excerpt":"","more":"<h1 id=\"Const\"><a href=\"#Const\" class=\"headerlink\" title=\"Const\"></a>Const</h1><p>在C语言当中的，这个变量加上一个Const关键字之后，这个变量被初始化之后呢，就不能赋值。<br><img src=\"/images/C++/const1.png\" alt=\"Alt text\"><br>但是由于指针的存在，就出现一个问题，就是这个const是修饰谁的，比如:<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>会在第9行报错，error: read-only variable is not assignable<br>说这个变量是只读的，变量是不能被赋值的。<br>说明这个指针所指的这个对象是const的是不能被修改的，但是指针变量还是可以修改的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tp++;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>没有报错。我们再看两个例子：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个没有报错，输出是：<br>10<br>2<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tp++;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个报错了，error: cannot assign to variable ‘p’ with const-qualified type ‘int <em>const’<br>说不能对变量p赋值，因为这个指针p是被const修饰的，是类型’int </em>const’<br>这个指针p所指向的那个变量的值被修改了，但是p不能被修改，说明这个const修饰的是指针变量p，所以指针变量p不能被修改。<br>这就有一个问题了，怎么区分呢？其实有一个小技巧<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;i; <span class=\"comment\">// 看这个*号，const在星号左边说明是指针所指的那个变量是const的</span></div><div class=\"line\"><span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i; <span class=\"comment\">// const在星号右边说明这个指针p是const的</span></div></pre></td></tr></table></figure></p>\n<p>当然你可以都让它们是const的，让指针是const的同时，让指针所指的那个变量（内存空间）也都是const<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">10</span>;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p = &amp;i;</div><div class=\"line\">\tp++;  <span class=\"comment\">// 这里会有错，error: cannot assign to variable 'p' with const-qualified type 'int *const'</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t*p = <span class=\"number\">2</span>; <span class=\"comment\">// 这里会有错，error: read-only variable is not assignable</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样两个变量都是const的了<br>接下来再试一件事情<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> *s = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\ts[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我 g++ 了一下，有一个warning:<br><img src=\"/images/C++/const2.png\" alt=\"Alt text\"><br>如果我先无视这个warning ./a.out 一下<br><img src=\"/images/C++/const3.png\" alt=\"Alt text\"><br>它输出了这个 hello world 之后程序异常终止了。<br>前面的那个warning 的意思是说：conversion from string literal to ‘char <em>‘ is deprecated<br>说这事已经过时了，这个意思是说你想将”hello world”这个字符串交给char </em>是不对的，做了修改之后程序就崩溃了。<br>实际上事情是这样的，s在栈里面，因为是本地变量（本地变量和函数的参数列表的变量都在栈里面）s是一个指针，它指向了一块内存，也就是说”hello world”是一块内存，内存又分为三种不同的地方，本地变量是放在，栈里面，new出来的东西是放在堆里面，然后全局变量在一个全局数据区里面。而全局变量里面的这种常量，是在代码段里的，因为”hello world”是一个常量，所以尽管我们没有在s前面加上const，实际上它是const的。它被放在了代码段里面，而代码段是不可写的。现在说有的操作系统，都是葱花1970年代出得那个Unix，现代操作系统的基本理论是从那里来的，所以不管外表是什么样，里面东西是一样的。你的程序运行起来之后，你的程序会从操作系统得到一块内存，这块内存当然是虚拟的，但是这块内存是独立的，每个进程，每个程序都有独立的内存。每块内存从0开始，在计算机的内部有一个计算机的硬件，MMU内存管理单元。由它来管这件事情，它会划分，从0开始到0x000xxx是代码段，如果你去试图去写这个代码段，就会有错：Bus error，实际上是MMU的地方出了错。<br>这是这件事情，假如：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"comment\">// char *s = \"hello world\";</span></div><div class=\"line\">\t<span class=\"keyword\">char</span> s[] = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\ts[<span class=\"number\">0</span>] = <span class=\"string\">'B'</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;s&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出：<br>hello world<br>Bello world<br>没有warning、没有error<br>说明了 char[] s = “hello world”;<br>做了一件事，将代码段里的”hello world” 复制到栈里面了，存在本地变量里面。<br>可以写一个程序来验证。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s1 = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">char</span> s2[] = <span class=\"string\">\"hello world\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s1  =%p\\n\"</span>,s1);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"s2  =%p\\n\"</span>,s2);</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"main=%p\\n\"</span>,main;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后我们编译运行一下输出：<br><img src=\"/images/C++/const4.png\" alt=\"Alt text\"><br>明显地址是不同的，char *s1 是比较靠前的地址，所以它在代码段里的<br>同时也看了main函数的地址，也是比较靠前的</p>\n"},{"title":"C++继承","date":"2017-04-23T05:35:44.000Z","_content":"# name hiding\n先看一下例子\n``` c++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\t A():i(10){cout<<\"A::A()\"<<endl;}\n\t\tint getI(){return this->i;}\n\t\tint getI(int i){return i;}\n};\nclass B:public A{\n\tpublic :\n\t\tint getI(){return 20;}\n};\nint main(){\n\tB b;\n\tcout<<b.getI()<<endl;\n\treturn 0;\n}\n```\n结果输出：\nA::A()\n20\n这个理解上没有什么问题，这个所有的OOP的语言都有，这个叫做override，函数的重写或者叫函数的复写。\n接下来再看一个例子\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\t A():i(10){cout<<\"A::A()\"<<endl;}\n\t\tint getI(){return this->i;}\n\t\tint getI(int i){return i;}\n};\nclass B:public A{\n\tpublic :\n\t\tint getI(){return 20;}\n};\nint main(){\n\tB b;\n\tcout<<b.getI()<<endl;\n\tcout<<b.getI(1)<<endl;\n\treturn 0;\n}\n```\n报错：\n![Alt text](/images/namehiding.png)\n意思大概是说，函数中的参数过多，应该是0个，但是现在有一个参数，你可能想调用的是那个无参数的函数\n相当于类B中没有带一个参数的getI函数。不是说B类继承A类，之后就是把所有的A类当中，不管是private的还是public的都继承过来了嘛，为什么A类有带一个参数getI但是对B类的对象调用会报错。这个是因为C++所特有的，除了C++其他的OOP语言都不是这么干的，这叫name hiding。对于C++来说，如果父类当中有overload的函数，在子类当中你出现和父类相同的函数（名字，参数列表都一样）那么子类当中就只有那一个函数了，父类的那些就都被隐藏掉了。这是因为在C++，B类中的getI函数和A类中的getI函数是没有任何关系的，其他的OOP语言会构成一种关系，叫override\n# Function overloading\noverload 是指的我的一些函数可以有相同的函数名，然后他们有不同的参数列表（这个是参数列表的个数和类型会不一样）。\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\tA():i(0){}\n\t\tvoid print(){cout<< i <<endl;}\n\t\tvoid print(long i){cout<< i <<endl;}\n\t\tvoid print(int i){cout<< i <<endl;}\n};\n\nint main(){\n\tA a;\n\ta.print();\n\ta.print(155L);\n\ta.print(15);\n\treturn 0;\n}\n\n```\n这个就是overload（重载）\n当然，如果一个函数的名称相同，参数表相同而返回值类型不同，构不构成overload呢？\n这个显然不行的，因为这样编译器无从分辨，你到底要调用哪个函数。\n有的人会说我可以这样\n``` C++\nint a = f();\ndouble a = f();\n```\n通过返回值要交给哪个类型的变量来让编译器来判断，我要调那个函数。\n但是问题在于你还可以这样写\n``` C++\nf();\n```\n这样写编译器就不会知道。\n# default value\n很多编程语言都支持default value\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\tA():i(0){}\n\t\tvoid print(int i=10){cout<< i <<endl;}\n\n};\n\nint main(){\n\tA a;\n\ta.print();\n\treturn 0;\n}\n\n```\n不过在这里的忠告是，尽量不用default value ，当然用default value在一些情况下你可以少打一些字。\n但是对软件工程来说，一般情况下凡事让你少打字的情况都是不好的。因为default value会造成你阅读上的困难。\n当你看到我在调用print的函数的时候你会以为他只是一个没有参数的函数，但是你找不到。而且default value很不安全，它不一定是设计者的意图。\n","source":"_posts/C++/inherit.md","raw":"---\ntitle: C++继承\ndate: 2017-04-23 13:35:44\ntags:\ncategories: C++\n---\n# name hiding\n先看一下例子\n``` c++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\t A():i(10){cout<<\"A::A()\"<<endl;}\n\t\tint getI(){return this->i;}\n\t\tint getI(int i){return i;}\n};\nclass B:public A{\n\tpublic :\n\t\tint getI(){return 20;}\n};\nint main(){\n\tB b;\n\tcout<<b.getI()<<endl;\n\treturn 0;\n}\n```\n结果输出：\nA::A()\n20\n这个理解上没有什么问题，这个所有的OOP的语言都有，这个叫做override，函数的重写或者叫函数的复写。\n接下来再看一个例子\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\t A():i(10){cout<<\"A::A()\"<<endl;}\n\t\tint getI(){return this->i;}\n\t\tint getI(int i){return i;}\n};\nclass B:public A{\n\tpublic :\n\t\tint getI(){return 20;}\n};\nint main(){\n\tB b;\n\tcout<<b.getI()<<endl;\n\tcout<<b.getI(1)<<endl;\n\treturn 0;\n}\n```\n报错：\n![Alt text](/images/namehiding.png)\n意思大概是说，函数中的参数过多，应该是0个，但是现在有一个参数，你可能想调用的是那个无参数的函数\n相当于类B中没有带一个参数的getI函数。不是说B类继承A类，之后就是把所有的A类当中，不管是private的还是public的都继承过来了嘛，为什么A类有带一个参数getI但是对B类的对象调用会报错。这个是因为C++所特有的，除了C++其他的OOP语言都不是这么干的，这叫name hiding。对于C++来说，如果父类当中有overload的函数，在子类当中你出现和父类相同的函数（名字，参数列表都一样）那么子类当中就只有那一个函数了，父类的那些就都被隐藏掉了。这是因为在C++，B类中的getI函数和A类中的getI函数是没有任何关系的，其他的OOP语言会构成一种关系，叫override\n# Function overloading\noverload 是指的我的一些函数可以有相同的函数名，然后他们有不同的参数列表（这个是参数列表的个数和类型会不一样）。\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\tA():i(0){}\n\t\tvoid print(){cout<< i <<endl;}\n\t\tvoid print(long i){cout<< i <<endl;}\n\t\tvoid print(int i){cout<< i <<endl;}\n};\n\nint main(){\n\tA a;\n\ta.print();\n\ta.print(155L);\n\ta.print(15);\n\treturn 0;\n}\n\n```\n这个就是overload（重载）\n当然，如果一个函数的名称相同，参数表相同而返回值类型不同，构不构成overload呢？\n这个显然不行的，因为这样编译器无从分辨，你到底要调用哪个函数。\n有的人会说我可以这样\n``` C++\nint a = f();\ndouble a = f();\n```\n通过返回值要交给哪个类型的变量来让编译器来判断，我要调那个函数。\n但是问题在于你还可以这样写\n``` C++\nf();\n```\n这样写编译器就不会知道。\n# default value\n很多编程语言都支持default value\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tprivate :\n\t\tint i;\n\tpublic :\n\t\tA():i(0){}\n\t\tvoid print(int i=10){cout<< i <<endl;}\n\n};\n\nint main(){\n\tA a;\n\ta.print();\n\treturn 0;\n}\n\n```\n不过在这里的忠告是，尽量不用default value ，当然用default value在一些情况下你可以少打一些字。\n但是对软件工程来说，一般情况下凡事让你少打字的情况都是不好的。因为default value会造成你阅读上的困难。\n当你看到我在调用print的函数的时候你会以为他只是一个没有参数的函数，但是你找不到。而且default value很不安全，它不一定是设计者的意图。\n","slug":"C++/inherit","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sf000fhhu2hemr8rbf","content":"<h1 id=\"name-hiding\"><a href=\"#name-hiding\" class=\"headerlink\" title=\"name hiding\"></a>name hiding</h1><p>先看一下例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t A():i(<span class=\"number\">10</span>)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::A()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"keyword\">return</span> i;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B:<span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">20</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tB b;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果输出：<br>A::A()<br>20<br>这个理解上没有什么问题，这个所有的OOP的语言都有，这个叫做override，函数的重写或者叫函数的复写。<br>接下来再看一个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t A():i(<span class=\"number\">10</span>)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::A()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"keyword\">return</span> i;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B:<span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">20</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tB b;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI(<span class=\"number\">1</span>)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>报错：<br><img src=\"/images/namehiding.png\" alt=\"Alt text\"><br>意思大概是说，函数中的参数过多，应该是0个，但是现在有一个参数，你可能想调用的是那个无参数的函数<br>相当于类B中没有带一个参数的getI函数。不是说B类继承A类，之后就是把所有的A类当中，不管是private的还是public的都继承过来了嘛，为什么A类有带一个参数getI但是对B类的对象调用会报错。这个是因为C++所特有的，除了C++其他的OOP语言都不是这么干的，这叫name hiding。对于C++来说，如果父类当中有overload的函数，在子类当中你出现和父类相同的函数（名字，参数列表都一样）那么子类当中就只有那一个函数了，父类的那些就都被隐藏掉了。这是因为在C++，B类中的getI函数和A类中的getI函数是没有任何关系的，其他的OOP语言会构成一种关系，叫override</p>\n<h1 id=\"Function-overloading\"><a href=\"#Function-overloading\" class=\"headerlink\" title=\"Function overloading\"></a>Function overloading</h1><p>overload 是指的我的一些函数可以有相同的函数名，然后他们有不同的参数列表（这个是参数列表的个数和类型会不一样）。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">0</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">long</span> i)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.print();</div><div class=\"line\">\ta.print(<span class=\"number\">155L</span>);</div><div class=\"line\">\ta.print(<span class=\"number\">15</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个就是overload（重载）<br>当然，如果一个函数的名称相同，参数表相同而返回值类型不同，构不构成overload呢？<br>这个显然不行的，因为这样编译器无从分辨，你到底要调用哪个函数。<br>有的人会说我可以这样<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = f();</div><div class=\"line\"><span class=\"keyword\">double</span> a = f();</div></pre></td></tr></table></figure></p>\n<p>通过返回值要交给哪个类型的变量来让编译器来判断，我要调那个函数。<br>但是问题在于你还可以这样写<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f();</div></pre></td></tr></table></figure></p>\n<p>这样写编译器就不会知道。</p>\n<h1 id=\"default-value\"><a href=\"#default-value\" class=\"headerlink\" title=\"default value\"></a>default value</h1><p>很多编程语言都支持default value<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">0</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i=<span class=\"number\">10</span>)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.print();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不过在这里的忠告是，尽量不用default value ，当然用default value在一些情况下你可以少打一些字。<br>但是对软件工程来说，一般情况下凡事让你少打字的情况都是不好的。因为default value会造成你阅读上的困难。<br>当你看到我在调用print的函数的时候你会以为他只是一个没有参数的函数，但是你找不到。而且default value很不安全，它不一定是设计者的意图。</p>\n","excerpt":"","more":"<h1 id=\"name-hiding\"><a href=\"#name-hiding\" class=\"headerlink\" title=\"name hiding\"></a>name hiding</h1><p>先看一下例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t A():i(<span class=\"number\">10</span>)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::A()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"keyword\">return</span> i;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B:<span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">20</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tB b;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果输出：<br>A::A()<br>20<br>这个理解上没有什么问题，这个所有的OOP的语言都有，这个叫做override，函数的重写或者叫函数的复写。<br>接下来再看一个例子<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t A():i(<span class=\"number\">10</span>)&#123;<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::A()\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"keyword\">return</span> i;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B:<span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getI</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">20</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tB b;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.getI(<span class=\"number\">1</span>)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>报错：<br><img src=\"/images/namehiding.png\" alt=\"Alt text\"><br>意思大概是说，函数中的参数过多，应该是0个，但是现在有一个参数，你可能想调用的是那个无参数的函数<br>相当于类B中没有带一个参数的getI函数。不是说B类继承A类，之后就是把所有的A类当中，不管是private的还是public的都继承过来了嘛，为什么A类有带一个参数getI但是对B类的对象调用会报错。这个是因为C++所特有的，除了C++其他的OOP语言都不是这么干的，这叫name hiding。对于C++来说，如果父类当中有overload的函数，在子类当中你出现和父类相同的函数（名字，参数列表都一样）那么子类当中就只有那一个函数了，父类的那些就都被隐藏掉了。这是因为在C++，B类中的getI函数和A类中的getI函数是没有任何关系的，其他的OOP语言会构成一种关系，叫override</p>\n<h1 id=\"Function-overloading\"><a href=\"#Function-overloading\" class=\"headerlink\" title=\"Function overloading\"></a>Function overloading</h1><p>overload 是指的我的一些函数可以有相同的函数名，然后他们有不同的参数列表（这个是参数列表的个数和类型会不一样）。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">0</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">long</span> i)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.print();</div><div class=\"line\">\ta.print(<span class=\"number\">155L</span>);</div><div class=\"line\">\ta.print(<span class=\"number\">15</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个就是overload（重载）<br>当然，如果一个函数的名称相同，参数表相同而返回值类型不同，构不构成overload呢？<br>这个显然不行的，因为这样编译器无从分辨，你到底要调用哪个函数。<br>有的人会说我可以这样<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> a = f();</div><div class=\"line\"><span class=\"keyword\">double</span> a = f();</div></pre></td></tr></table></figure></p>\n<p>通过返回值要交给哪个类型的变量来让编译器来判断，我要调那个函数。<br>但是问题在于你还可以这样写<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">f();</div></pre></td></tr></table></figure></p>\n<p>这样写编译器就不会知道。</p>\n<h1 id=\"default-value\"><a href=\"#default-value\" class=\"headerlink\" title=\"default value\"></a>default value</h1><p>很多编程语言都支持default value<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">private</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">0</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> i=<span class=\"number\">10</span>)</span></span>&#123;<span class=\"built_in\">cout</span>&lt;&lt; i &lt;&lt;<span class=\"built_in\">endl</span>;&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.print();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>不过在这里的忠告是，尽量不用default value ，当然用default value在一些情况下你可以少打一些字。<br>但是对软件工程来说，一般情况下凡事让你少打字的情况都是不好的。因为default value会造成你阅读上的困难。<br>当你看到我在调用print的函数的时候你会以为他只是一个没有参数的函数，但是你找不到。而且default value很不安全，它不一定是设计者的意图。</p>\n"},{"title":"reference","date":"2017-05-09T00:32:08.000Z","_content":"# Declaring references\nreference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。\n![Alt text](/images/C++/reference1.png)\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tchar c;\n\tchar* p = &c;\n\tchar& r =  c;\n\treturn 0;\n}\n```\n这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。\n如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。\n![Alt text](/images/C++/reference2.png)\n我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。\n## Rules of references\n定义reference的时候必须要初始化。\n``` C++\nvoid f(int& x);\nf(y);   // 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，\n        // 因为你调用的时候不知道，传的是那个对象还是reference\n```\n![Alt text](/images/C++/reference3.png)\nreference需要一个地方去放它，i*3有结果但是没有location，没有一个对方去放它。\n![Alt text](/images/C++/reference4.png)\nReferences和Pointers做了一对比。\n实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点*，所以做出来reference来。\n在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个*号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个*号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。\n","source":"_posts/C++/reference.md","raw":"---\ntitle: reference\ndate: 2017-05-09 08:32:08\ntags:\ncategories: C++\n---\n# Declaring references\nreference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。\n![Alt text](/images/C++/reference1.png)\n``` C++\n#include <iostream>\nusing namespace std;\n\nint main(int argc, char const *argv[])\n{\n\tchar c;\n\tchar* p = &c;\n\tchar& r =  c;\n\treturn 0;\n}\n```\n这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。\n如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。\n![Alt text](/images/C++/reference2.png)\n我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。\n## Rules of references\n定义reference的时候必须要初始化。\n``` C++\nvoid f(int& x);\nf(y);   // 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，\n        // 因为你调用的时候不知道，传的是那个对象还是reference\n```\n![Alt text](/images/C++/reference3.png)\nreference需要一个地方去放它，i*3有结果但是没有location，没有一个对方去放它。\n![Alt text](/images/C++/reference4.png)\nReferences和Pointers做了一对比。\n实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点*，所以做出来reference来。\n在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个*号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个*号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。\n","slug":"C++/reference","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sh000ghhu2lauaxbyb","content":"<h1 id=\"Declaring-references\"><a href=\"#Declaring-references\" class=\"headerlink\" title=\"Declaring references\"></a>Declaring references</h1><p>reference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。<br><img src=\"/images/C++/reference1.png\" alt=\"Alt text\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> c;</div><div class=\"line\">\t<span class=\"keyword\">char</span>* p = &amp;c;</div><div class=\"line\">\t<span class=\"keyword\">char</span>&amp; r =  c;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。<br>如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。<br><img src=\"/images/C++/reference2.png\" alt=\"Alt text\"><br>我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。</p>\n<h2 id=\"Rules-of-references\"><a href=\"#Rules-of-references\" class=\"headerlink\" title=\"Rules of references\"></a>Rules of references</h2><p>定义reference的时候必须要初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; x)</span></span>;</div><div class=\"line\">f(y);   <span class=\"comment\">// 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，</span></div><div class=\"line\">        <span class=\"comment\">// 因为你调用的时候不知道，传的是那个对象还是reference</span></div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/C++/reference3.png\" alt=\"Alt text\"><br>reference需要一个地方去放它，i<em>3有结果但是没有location，没有一个对方去放它。<br><img src=\"/images/C++/reference4.png\" alt=\"Alt text\"><br>References和Pointers做了一对比。<br>实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点</em>，所以做出来reference来。<br>在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个<em>号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个</em>号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。</p>\n","excerpt":"","more":"<h1 id=\"Declaring-references\"><a href=\"#Declaring-references\" class=\"headerlink\" title=\"Declaring references\"></a>Declaring references</h1><p>reference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。<br><img src=\"/images/C++/reference1.png\" alt=\"Alt text\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> c;</div><div class=\"line\">\t<span class=\"keyword\">char</span>* p = &amp;c;</div><div class=\"line\">\t<span class=\"keyword\">char</span>&amp; r =  c;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。<br>如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。<br><img src=\"/images/C++/reference2.png\" alt=\"Alt text\"><br>我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。</p>\n<h2 id=\"Rules-of-references\"><a href=\"#Rules-of-references\" class=\"headerlink\" title=\"Rules of references\"></a>Rules of references</h2><p>定义reference的时候必须要初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; x)</span></span>;</div><div class=\"line\">f(y);   <span class=\"comment\">// 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，</span></div><div class=\"line\">        <span class=\"comment\">// 因为你调用的时候不知道，传的是那个对象还是reference</span></div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/C++/reference3.png\" alt=\"Alt text\"><br>reference需要一个地方去放它，i<em>3有结果但是没有location，没有一个对方去放它。<br><img src=\"/images/C++/reference4.png\" alt=\"Alt text\"><br>References和Pointers做了一对比。<br>实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点</em>，所以做出来reference来。<br>在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个<em>号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个</em>号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。</p>\n"},{"title":"多态","date":"2017-05-09T07:59:21.000Z","_content":"# Upcatsting\n如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：\nD->B  ：一个D的对象可以交给B的变量；\nD*->B*：一个D的指针可以交给B的指针；\nD&->B&：一个D的引用可以交给B的引用；\n可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。\n![Alt text](/images/C++/多态1.png)\n假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。\n我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。\n![Alt text](/images/C++/多态2.png)\n先看一下代码：\n![Alt text](/images/C++/多态3.png)\n在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。\n在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。\n![Alt text](/images/C++/多态4.png)\n我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。\n![Alt text](/images/C++/多态5.png)\n看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。\n所以多态建立于两个事情的基础上：\n第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。\n第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。\n    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。\n    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。\n这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。\n然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。\n# How virtual work in C++\n![Alt text](/images/C++/多态4.png)\n任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tcout<<*p<<endl;\n\n\treturn 0;\n}\n```\n输出结果:\nA::f() 10\n16\n238158040\n它的大小是16\n如果我们在改一下\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tp += 2; // p++ 的结果是1\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n结果：\nA::f() 10\n16\n10\n说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(100){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a,b;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tint* q = (int*)&b;\n    int* x = (int*)*p; // p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针\n\tcout<<*p<<endl;\n\tcout<<*q<<endl;\n    cout<<x<<endl;\n\treturn 0;\n}```\n结果:\nA::f() 100\n16\n134115552\n134115552\n0x7fe70e0\nx是一个很小的值。\n我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，*p和*q是一样的。\n所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable\n这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。\n# Shape VS Ellipse\n![Alt text](/images/C++/多态7.png)\n我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;\n再来看Circle\n![Alt text](/images/C++/多态8.png)\nCircle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构\n如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir\n![Alt text](/images/C++/多态9.png)\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nclass B : public A{\n\tpublic :\n\t\tB():j(20){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"B::f() \"<<i<<endl;\n\t\t}\n\t\tint j;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\tB b;\n\tA *p = &b;\n\tp->f(); // B::f() 10\n\ta = b;  \n\ta.f();\t// A::f() 10\n\treturn 0;\n}\n```\n结果：\nB::f() 10\nA::f() 10\n我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。\n我们可以换一下vptr\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nclass B : public A{\n\tpublic :\n\t\tB():j(20){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"B::f() \"<<j<<endl;\n\t\t}\n\t\tint j;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\tB b;\n\tA *p = &a;\n\tint*r = (int*)&a;\n\tint*t = (int*)&b;\n\t*r = *t;\n\tp->f();\n\treturn 0;\n}\n```\n结果：\nB::f() 0\n0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0\n所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。\n## Overriding\n在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。\n注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。\n","source":"_posts/C++/多态.md","raw":"---\ntitle: 多态\ndate: 2017-05-09 15:59:21\ntags:\ncategories: C++\n---\n# Upcatsting\n如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：\nD->B  ：一个D的对象可以交给B的变量；\nD*->B*：一个D的指针可以交给B的指针；\nD&->B&：一个D的引用可以交给B的引用；\n可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。\n![Alt text](/images/C++/多态1.png)\n假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。\n我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。\n![Alt text](/images/C++/多态2.png)\n先看一下代码：\n![Alt text](/images/C++/多态3.png)\n在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。\n在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。\n![Alt text](/images/C++/多态4.png)\n我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。\n![Alt text](/images/C++/多态5.png)\n看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。\n所以多态建立于两个事情的基础上：\n第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。\n第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。\n    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。\n    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。\n这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。\n然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。\n# How virtual work in C++\n![Alt text](/images/C++/多态4.png)\n任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。\n``` C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tcout<<*p<<endl;\n\n\treturn 0;\n}\n```\n输出结果:\nA::f() 10\n16\n238158040\n它的大小是16\n如果我们在改一下\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tp += 2; // p++ 的结果是1\n\tcout<<*p<<endl;\n\treturn 0;\n}\n```\n结果：\nA::f() 10\n16\n10\n说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(100){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nint main(int argc, char const *argv[])\n{\n\tA a,b;\n\ta.f();\n\tcout<<sizeof(a)<<endl;\n\tint* p = (int*)&a;\n\tint* q = (int*)&b;\n    int* x = (int*)*p; // p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针\n\tcout<<*p<<endl;\n\tcout<<*q<<endl;\n    cout<<x<<endl;\n\treturn 0;\n}```\n结果:\nA::f() 100\n16\n134115552\n134115552\n0x7fe70e0\nx是一个很小的值。\n我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，*p和*q是一样的。\n所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable\n这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。\n# Shape VS Ellipse\n![Alt text](/images/C++/多态7.png)\n我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;\n再来看Circle\n![Alt text](/images/C++/多态8.png)\nCircle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构\n如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir\n![Alt text](/images/C++/多态9.png)\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nclass B : public A{\n\tpublic :\n\t\tB():j(20){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"B::f() \"<<i<<endl;\n\t\t}\n\t\tint j;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\tB b;\n\tA *p = &b;\n\tp->f(); // B::f() 10\n\ta = b;  \n\ta.f();\t// A::f() 10\n\treturn 0;\n}\n```\n结果：\nB::f() 10\nA::f() 10\n我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。\n我们可以换一下vptr\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tA():i(10){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"A::f() \"<<i<<endl;\n\t\t}\n\t\tint i;\n};\nclass B : public A{\n\tpublic :\n\t\tB():j(20){}\n\t\tvirtual void f(){\n\t\t\tcout<<\"B::f() \"<<j<<endl;\n\t\t}\n\t\tint j;\n};\nint main(int argc, char const *argv[])\n{\n\tA a;\n\tB b;\n\tA *p = &a;\n\tint*r = (int*)&a;\n\tint*t = (int*)&b;\n\t*r = *t;\n\tp->f();\n\treturn 0;\n}\n```\n结果：\nB::f() 0\n0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0\n所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。\n## Overriding\n在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。\n注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。\n","slug":"C++/多态","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6si000hhhu2ermwv9ju","content":"<h1 id=\"Upcatsting\"><a href=\"#Upcatsting\" class=\"headerlink\" title=\"Upcatsting\"></a>Upcatsting</h1><p>如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：<br>D-&gt;B  ：一个D的对象可以交给B的变量；<br>D<em>-&gt;B</em>：一个D的指针可以交给B的指针；<br>D&amp;-&gt;B&amp;：一个D的引用可以交给B的引用；<br>可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。<br><img src=\"/images/C++/多态1.png\" alt=\"Alt text\"><br>假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。<br>我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。<br><img src=\"/images/C++/多态2.png\" alt=\"Alt text\"><br>先看一下代码：<br><img src=\"/images/C++/多态3.png\" alt=\"Alt text\"><br>在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。<br>在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。<br><img src=\"/images/C++/多态4.png\" alt=\"Alt text\"><br>我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。<br><img src=\"/images/C++/多态5.png\" alt=\"Alt text\"><br>看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。<br>所以多态建立于两个事情的基础上：<br>第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。<br>第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。<br>    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。<br>    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。<br>这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。<br>然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。</p>\n<h1 id=\"How-virtual-work-in-C\"><a href=\"#How-virtual-work-in-C\" class=\"headerlink\" title=\"How virtual work in C++\"></a>How virtual work in C++</h1><p><img src=\"/images/C++/多态4.png\" alt=\"Alt text\"><br>任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果:<br>A::f() 10<br>16<br>238158040<br>它的大小是16<br>如果我们在改一下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\tp += <span class=\"number\">2</span>; <span class=\"comment\">// p++ 的结果是1</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>A::f() 10<br>16<br>10<br>说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">100</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tA a,b;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* q = (<span class=\"keyword\">int</span>*)&amp;b;</div><div class=\"line\">    <span class=\"keyword\">int</span>* x = (<span class=\"keyword\">int</span>*)*p; <span class=\"comment\">// p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*q&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果:<br>A::f() 100<br>16<br>134115552<br>134115552<br>0x7fe70e0<br>x是一个很小的值。<br>我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，<em>p和</em>q是一样的。<br>所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable<br>这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。</p>\n<h1 id=\"Shape-VS-Ellipse\"><a href=\"#Shape-VS-Ellipse\" class=\"headerlink\" title=\"Shape VS Ellipse\"></a>Shape VS Ellipse</h1><p><img src=\"/images/C++/多态7.png\" alt=\"Alt text\"><br>我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;<br>再来看Circle<br><img src=\"/images/C++/多态8.png\" alt=\"Alt text\"><br>Circle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构<br>如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir<br><img src=\"/images/C++/多态9.png\" alt=\"Alt text\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B : <span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tB():j(<span class=\"number\">20</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"B::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\tB b;</div><div class=\"line\">\tA *p = &amp;b;</div><div class=\"line\">\tp-&gt;f(); <span class=\"comment\">// B::f() 10</span></div><div class=\"line\">\ta = b;  </div><div class=\"line\">\ta.f();\t<span class=\"comment\">// A::f() 10</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>B::f() 10<br>A::f() 10<br>我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。<br>我们可以换一下vptr<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B : <span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tB():j(<span class=\"number\">20</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"B::f() \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\tB b;</div><div class=\"line\">\tA *p = &amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>*r = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>*t = (<span class=\"keyword\">int</span>*)&amp;b;</div><div class=\"line\">\t*r = *t;</div><div class=\"line\">\tp-&gt;f();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>B::f() 0<br>0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0<br>所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。</p>\n<h2 id=\"Overriding\"><a href=\"#Overriding\" class=\"headerlink\" title=\"Overriding\"></a>Overriding</h2><p>在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。<br>注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。</p>\n","excerpt":"","more":"<h1 id=\"Upcatsting\"><a href=\"#Upcatsting\" class=\"headerlink\" title=\"Upcatsting\"></a>Upcatsting</h1><p>如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：<br>D-&gt;B  ：一个D的对象可以交给B的变量；<br>D<em>-&gt;B</em>：一个D的指针可以交给B的指针；<br>D&amp;-&gt;B&amp;：一个D的引用可以交给B的引用；<br>可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。<br><img src=\"/images/C++/多态1.png\" alt=\"Alt text\"><br>假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。<br>我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。<br><img src=\"/images/C++/多态2.png\" alt=\"Alt text\"><br>先看一下代码：<br><img src=\"/images/C++/多态3.png\" alt=\"Alt text\"><br>在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。<br>在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。<br><img src=\"/images/C++/多态4.png\" alt=\"Alt text\"><br>我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。<br><img src=\"/images/C++/多态5.png\" alt=\"Alt text\"><br>看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。<br>所以多态建立于两个事情的基础上：<br>第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。<br>第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。<br>    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。<br>    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。<br>这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。<br>然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。</p>\n<h1 id=\"How-virtual-work-in-C\"><a href=\"#How-virtual-work-in-C\" class=\"headerlink\" title=\"How virtual work in C++\"></a>How virtual work in C++</h1><p><img src=\"/images/C++/多态4.png\" alt=\"Alt text\"><br>任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出结果:<br>A::f() 10<br>16<br>238158040<br>它的大小是16<br>如果我们在改一下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\tp += <span class=\"number\">2</span>; <span class=\"comment\">// p++ 的结果是1</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>A::f() 10<br>16<br>10<br>说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">100</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tA a,b;</div><div class=\"line\">\ta.f();</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"keyword\">sizeof</span>(a)&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* p = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>* q = (<span class=\"keyword\">int</span>*)&amp;b;</div><div class=\"line\">    <span class=\"keyword\">int</span>* x = (<span class=\"keyword\">int</span>*)*p; <span class=\"comment\">// p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针</span></div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*p&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;*q&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;x&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果:<br>A::f() 100<br>16<br>134115552<br>134115552<br>0x7fe70e0<br>x是一个很小的值。<br>我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，<em>p和</em>q是一样的。<br>所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable<br>这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。</p>\n<h1 id=\"Shape-VS-Ellipse\"><a href=\"#Shape-VS-Ellipse\" class=\"headerlink\" title=\"Shape VS Ellipse\"></a>Shape VS Ellipse</h1><p><img src=\"/images/C++/多态7.png\" alt=\"Alt text\"><br>我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;<br>再来看Circle<br><img src=\"/images/C++/多态8.png\" alt=\"Alt text\"><br>Circle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构<br>如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir<br><img src=\"/images/C++/多态9.png\" alt=\"Alt text\"><br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B : <span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tB():j(<span class=\"number\">20</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"B::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\tB b;</div><div class=\"line\">\tA *p = &amp;b;</div><div class=\"line\">\tp-&gt;f(); <span class=\"comment\">// B::f() 10</span></div><div class=\"line\">\ta = b;  </div><div class=\"line\">\ta.f();\t<span class=\"comment\">// A::f() 10</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>B::f() 10<br>A::f() 10<br>我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。<br>我们可以换一下vptr<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tA():i(<span class=\"number\">10</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"A::f() \"</span>&lt;&lt;i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> i;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">class</span> B : <span class=\"keyword\">public</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tB():j(<span class=\"number\">20</span>)&#123;&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"B::f() \"</span>&lt;&lt;j&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> j;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\tA a;</div><div class=\"line\">\tB b;</div><div class=\"line\">\tA *p = &amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>*r = (<span class=\"keyword\">int</span>*)&amp;a;</div><div class=\"line\">\t<span class=\"keyword\">int</span>*t = (<span class=\"keyword\">int</span>*)&amp;b;</div><div class=\"line\">\t*r = *t;</div><div class=\"line\">\tp-&gt;f();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>B::f() 0<br>0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0<br>所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。</p>\n<h2 id=\"Overriding\"><a href=\"#Overriding\" class=\"headerlink\" title=\"Overriding\"></a>Overriding</h2><p>在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。<br>注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。</p>\n"},{"title":"拷贝构造函数","date":"2017-05-22T02:19:08.000Z","_content":"# 拷贝构造函数\n首先分清楚一组词initialization和assignment;\ninitialization：定义一个变量的时候给了它一个值；\nassignment：已经定义好变量了，你在给它一个值；\n初始化和赋值在C++是非常不一样的。\n先看一下代码：\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = f(h);\n\th.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nbegin of f\nx argumnet inside f(): objectCont = 1\nend of f\n~HowMany(): objectCont = 0\nafter call to f(): objectCont = 0\n~HowMany(): objectCont = -1\n~HowMany(): objectCont = -2\n出现了不平衡，通过某些方法绕过了构造方法，来创建了HowMany的对象。\n在看一下这个代码：\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tHowMany(int i){objectCont++;print(\"HowMany(int)\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = 10; // 跟 HoWMany h2(10); 等价的，\n\t// h.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nHowMany(int): objectCont = 2\n~HowMany(): objectCont = 1\n~HowMany(): objectCont = 0\n如果说，有一个要int类型的构造函数，在创建这个类的对象的时候我们可以写成HowMany h2 = 10，那么有一个要HowMany对象的构造函数呢？我们把之前的都还原，再加上这个构造函数。\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tHowMany(int i){objectCont++;print(\"HowMany(int)\");}\n\t\tHowMany(const HowMany& o){objectCont++;print(\"HowMany(HowMany)\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = f(h);\n\th.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nHowMany(HowMany): objectCont = 2\nbegin of f\nx argumnet inside f(): objectCont = 2\nend of f\nHowMany(HowMany): objectCont = 3\n~HowMany(): objectCont = 2\nafter call to f(): objectCont = 2\n~HowMany(): objectCont = 1\n~HowMany(): objectCont = 0\n平衡也都回来了，最大的时候有三个。有三个，一个是f里面的那个x，有一个h，h2是第三个。\n这说明，如果有一个类的构造函数，这个构造函数它的参数是自己那个类型的const reference，这个构造函数就可以在做这种类型的初始化的时候别调用（初始化这个对象的时候，用另外一个这个类的对象来初始化）。这样的构造函数我们有一个特殊的名字，拷贝构造。\n![Alt text](/images/C++/copy1.png)\n如果你没有给一个那样的拷贝构造，C++会自动给你一个，当然如果你给了，你就可以通过你给的那个拷贝构造怎么去控制。比方说你有些东西不想拷贝，或者有些东西要做很多的安排。如果你没有那个拷贝构造，编译器会给你一个，那个会拷贝每一个成员变量，它会做成员变量对成员变量的拷贝，这是在成员级别的拷贝，不是字节对字节的拷贝，只不过如果你的member全部都不是对象，那么它的最终结果就是字节对字节的拷贝。如果你的成员中有指针的话，那么拷贝就是指针的拷贝，就是两个指针指向同一片内存。同样的道理如果出现成员变量是reference的话，也会发生reference的拷贝，这两个reference是绑定同一个变量。\n我们可以试一下\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tint *i;\n\t\tvoid setI(int i);\n\t\tint* getI();\n};\n\ninline void A::setI(int i){\n\tthis->i = &i;\n}\ninline int* A::getI(){\n\treturn this->i;\n}\nint main(int argc, char const *argv[])\n{\n\tint i = 12;\n\tA a;\n\ta.i = &i;\n\tcout<<a.i<<endl;\n\tA b = a;\n\tcout<<b.i<<endl;\n\treturn 0;\n}\n```\n结果：\n0x7fff5089faac\n0x7fff5089faac\n地址是一样的，但是我们所希望的是，它们不只想同一块内存。这就需要人为的写出拷贝构造去给那个指针分配空间。\n一般来说，调用拷贝构造的场景就是初始化的时候，但是初始化又有一些隐藏的场景（调函数的时候）。还有就是我们有一个函数，这个函数会创建一个本定变量（对象）将这个对象return回去，也会发生拷贝构造。\ninitialization指的是只能做一次的，任何对象的初始化只能做一次。做完之后，在对它做任何动作那就是assignment而不是initialization。所以到了C++就不要用char*，char*是c的字符串，到了C++用string。\n到了现在我们到了现在，写一个类就应该写三个函数，不管用到没用到，第一个：default constructor；第二个：virtual destructor；第三个：copy constructor；不要依赖于编译器给你的那个。如果不想对象被拷贝，就把拷贝构造函数设置为private的。\n","source":"_posts/C++/拷贝构造函数.md","raw":"---\ntitle: 拷贝构造函数\ndate: 2017-05-22 10:19:08\ntags:\ncategories: C++\n---\n# 拷贝构造函数\n首先分清楚一组词initialization和assignment;\ninitialization：定义一个变量的时候给了它一个值；\nassignment：已经定义好变量了，你在给它一个值；\n初始化和赋值在C++是非常不一样的。\n先看一下代码：\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = f(h);\n\th.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nbegin of f\nx argumnet inside f(): objectCont = 1\nend of f\n~HowMany(): objectCont = 0\nafter call to f(): objectCont = 0\n~HowMany(): objectCont = -1\n~HowMany(): objectCont = -2\n出现了不平衡，通过某些方法绕过了构造方法，来创建了HowMany的对象。\n在看一下这个代码：\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tHowMany(int i){objectCont++;print(\"HowMany(int)\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = 10; // 跟 HoWMany h2(10); 等价的，\n\t// h.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nHowMany(int): objectCont = 2\n~HowMany(): objectCont = 1\n~HowMany(): objectCont = 0\n如果说，有一个要int类型的构造函数，在创建这个类的对象的时候我们可以写成HowMany h2 = 10，那么有一个要HowMany对象的构造函数呢？我们把之前的都还原，再加上这个构造函数。\n```C++\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstatic int objectCont = 0;\n\nclass HowMany{\n\tpublic :\n\t\tHowMany(){objectCont++;print(\"HowMany()\");}\n\t\tHowMany(int i){objectCont++;print(\"HowMany(int)\");}\n\t\tHowMany(const HowMany& o){objectCont++;print(\"HowMany(HowMany)\");}\n\t\tvoid print(const string& msg = \"\" ){\n\t\t\tif(msg.size() != 0){\n\t\t\t\tcout<< msg <<\": \";\n\t\t\t\tcout << \"objectCont = \"<<objectCont<<endl;\n\t\t\t}\n\t\t}\n\t\t~HowMany(){\n\t\t\tobjectCont--;\n\t\t\tprint(\"~HowMany()\");\n\t\t}\n};\n\nHowMany f(HowMany x){\n\tcout<<\"begin of f\" <<endl;\n\tx.print(\"x argumnet inside f()\");\n\tcout<<\"end of f\"<<endl;\n\treturn x;\n\n}\nint main(int argc, char const *argv[])\n{\n\n\tHowMany h;\n\th.print(\"after construction of h\");\n\tHowMany h2 = f(h);\n\th.print(\"after call to f()\");\n\treturn 0;\n}\n```\n结果：\nHowMany(): objectCont = 1\nafter construction of h: objectCont = 1\nHowMany(HowMany): objectCont = 2\nbegin of f\nx argumnet inside f(): objectCont = 2\nend of f\nHowMany(HowMany): objectCont = 3\n~HowMany(): objectCont = 2\nafter call to f(): objectCont = 2\n~HowMany(): objectCont = 1\n~HowMany(): objectCont = 0\n平衡也都回来了，最大的时候有三个。有三个，一个是f里面的那个x，有一个h，h2是第三个。\n这说明，如果有一个类的构造函数，这个构造函数它的参数是自己那个类型的const reference，这个构造函数就可以在做这种类型的初始化的时候别调用（初始化这个对象的时候，用另外一个这个类的对象来初始化）。这样的构造函数我们有一个特殊的名字，拷贝构造。\n![Alt text](/images/C++/copy1.png)\n如果你没有给一个那样的拷贝构造，C++会自动给你一个，当然如果你给了，你就可以通过你给的那个拷贝构造怎么去控制。比方说你有些东西不想拷贝，或者有些东西要做很多的安排。如果你没有那个拷贝构造，编译器会给你一个，那个会拷贝每一个成员变量，它会做成员变量对成员变量的拷贝，这是在成员级别的拷贝，不是字节对字节的拷贝，只不过如果你的member全部都不是对象，那么它的最终结果就是字节对字节的拷贝。如果你的成员中有指针的话，那么拷贝就是指针的拷贝，就是两个指针指向同一片内存。同样的道理如果出现成员变量是reference的话，也会发生reference的拷贝，这两个reference是绑定同一个变量。\n我们可以试一下\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A{\n\tpublic :\n\t\tint *i;\n\t\tvoid setI(int i);\n\t\tint* getI();\n};\n\ninline void A::setI(int i){\n\tthis->i = &i;\n}\ninline int* A::getI(){\n\treturn this->i;\n}\nint main(int argc, char const *argv[])\n{\n\tint i = 12;\n\tA a;\n\ta.i = &i;\n\tcout<<a.i<<endl;\n\tA b = a;\n\tcout<<b.i<<endl;\n\treturn 0;\n}\n```\n结果：\n0x7fff5089faac\n0x7fff5089faac\n地址是一样的，但是我们所希望的是，它们不只想同一块内存。这就需要人为的写出拷贝构造去给那个指针分配空间。\n一般来说，调用拷贝构造的场景就是初始化的时候，但是初始化又有一些隐藏的场景（调函数的时候）。还有就是我们有一个函数，这个函数会创建一个本定变量（对象）将这个对象return回去，也会发生拷贝构造。\ninitialization指的是只能做一次的，任何对象的初始化只能做一次。做完之后，在对它做任何动作那就是assignment而不是initialization。所以到了C++就不要用char*，char*是c的字符串，到了C++用string。\n到了现在我们到了现在，写一个类就应该写三个函数，不管用到没用到，第一个：default constructor；第二个：virtual destructor；第三个：copy constructor；不要依赖于编译器给你的那个。如果不想对象被拷贝，就把拷贝构造函数设置为private的。\n","slug":"C++/拷贝构造函数","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sp000jhhu22yvtjzxo","content":"<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><p>首先分清楚一组词initialization和assignment;<br>initialization：定义一个变量的时候给了它一个值；<br>assignment：已经定义好变量了，你在给它一个值；<br>初始化和赋值在C++是非常不一样的。<br>先看一下代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = f(h);</div><div class=\"line\">\th.print(<span class=\"string\">\"after call to f()\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>begin of f<br>x argumnet inside f(): objectCont = 1<br>end of f<br>~HowMany(): objectCont = 0<br>after call to f(): objectCont = 0<br>~HowMany(): objectCont = -1<br>~HowMany(): objectCont = -2<br>出现了不平衡，通过某些方法绕过了构造方法，来创建了HowMany的对象。<br>在看一下这个代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">int</span> i)&#123;objectCont++;print(<span class=\"string\">\"HowMany(int)\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = <span class=\"number\">10</span>; <span class=\"comment\">// 跟 HoWMany h2(10); 等价的，</span></div><div class=\"line\">\t<span class=\"comment\">// h.print(\"after call to f()\");</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(int): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>如果说，有一个要int类型的构造函数，在创建这个类的对象的时候我们可以写成HowMany h2 = 10，那么有一个要HowMany对象的构造函数呢？我们把之前的都还原，再加上这个构造函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">int</span> i)&#123;objectCont++;print(<span class=\"string\">\"HowMany(int)\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">const</span> HowMany&amp; o)&#123;objectCont++;print(<span class=\"string\">\"HowMany(HowMany)\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = f(h);</div><div class=\"line\">\th.print(<span class=\"string\">\"after call to f()\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(HowMany): objectCont = 2<br>begin of f<br>x argumnet inside f(): objectCont = 2<br>end of f<br>HowMany(HowMany): objectCont = 3<br>~HowMany(): objectCont = 2<br>after call to f(): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>平衡也都回来了，最大的时候有三个。有三个，一个是f里面的那个x，有一个h，h2是第三个。<br>这说明，如果有一个类的构造函数，这个构造函数它的参数是自己那个类型的const reference，这个构造函数就可以在做这种类型的初始化的时候别调用（初始化这个对象的时候，用另外一个这个类的对象来初始化）。这样的构造函数我们有一个特殊的名字，拷贝构造。<br><img src=\"/images/C++/copy1.png\" alt=\"Alt text\"><br>如果你没有给一个那样的拷贝构造，C++会自动给你一个，当然如果你给了，你就可以通过你给的那个拷贝构造怎么去控制。比方说你有些东西不想拷贝，或者有些东西要做很多的安排。如果你没有那个拷贝构造，编译器会给你一个，那个会拷贝每一个成员变量，它会做成员变量对成员变量的拷贝，这是在成员级别的拷贝，不是字节对字节的拷贝，只不过如果你的member全部都不是对象，那么它的最终结果就是字节对字节的拷贝。如果你的成员中有指针的话，那么拷贝就是指针的拷贝，就是两个指针指向同一片内存。同样的道理如果出现成员变量是reference的话，也会发生reference的拷贝，这两个reference是绑定同一个变量。<br>我们可以试一下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> *i;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">getI</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> A::setI(<span class=\"keyword\">int</span> i)&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>-&gt;i = &amp;i;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span>* A::getI()&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">12</span>;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.i = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;a.i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tA b = a;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>0x7fff5089faac<br>0x7fff5089faac<br>地址是一样的，但是我们所希望的是，它们不只想同一块内存。这就需要人为的写出拷贝构造去给那个指针分配空间。<br>一般来说，调用拷贝构造的场景就是初始化的时候，但是初始化又有一些隐藏的场景（调函数的时候）。还有就是我们有一个函数，这个函数会创建一个本定变量（对象）将这个对象return回去，也会发生拷贝构造。<br>initialization指的是只能做一次的，任何对象的初始化只能做一次。做完之后，在对它做任何动作那就是assignment而不是initialization。所以到了C++就不要用char<em>，char</em>是c的字符串，到了C++用string。<br>到了现在我们到了现在，写一个类就应该写三个函数，不管用到没用到，第一个：default constructor；第二个：virtual destructor；第三个：copy constructor；不要依赖于编译器给你的那个。如果不想对象被拷贝，就把拷贝构造函数设置为private的。</p>\n","excerpt":"","more":"<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><p>首先分清楚一组词initialization和assignment;<br>initialization：定义一个变量的时候给了它一个值；<br>assignment：已经定义好变量了，你在给它一个值；<br>初始化和赋值在C++是非常不一样的。<br>先看一下代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = f(h);</div><div class=\"line\">\th.print(<span class=\"string\">\"after call to f()\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>begin of f<br>x argumnet inside f(): objectCont = 1<br>end of f<br>~HowMany(): objectCont = 0<br>after call to f(): objectCont = 0<br>~HowMany(): objectCont = -1<br>~HowMany(): objectCont = -2<br>出现了不平衡，通过某些方法绕过了构造方法，来创建了HowMany的对象。<br>在看一下这个代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">int</span> i)&#123;objectCont++;print(<span class=\"string\">\"HowMany(int)\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = <span class=\"number\">10</span>; <span class=\"comment\">// 跟 HoWMany h2(10); 等价的，</span></div><div class=\"line\">\t<span class=\"comment\">// h.print(\"after call to f()\");</span></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(int): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>如果说，有一个要int类型的构造函数，在创建这个类的对象的时候我们可以写成HowMany h2 = 10，那么有一个要HowMany对象的构造函数呢？我们把之前的都还原，再加上这个构造函数。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> objectCont = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> HowMany&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\tHowMany()&#123;objectCont++;print(<span class=\"string\">\"HowMany()\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">int</span> i)&#123;objectCont++;print(<span class=\"string\">\"HowMany(int)\"</span>);&#125;</div><div class=\"line\">\t\tHowMany(<span class=\"keyword\">const</span> HowMany&amp; o)&#123;objectCont++;print(<span class=\"string\">\"HowMany(HowMany)\"</span>);&#125;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; msg = <span class=\"string\">\"\"</span> )</span></span>&#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span>(msg.size() != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span>&lt;&lt; msg &lt;&lt;<span class=\"string\">\": \"</span>;</div><div class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"objectCont = \"</span>&lt;&lt;objectCont&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t~HowMany()&#123;</div><div class=\"line\">\t\t\tobjectCont--;</div><div class=\"line\">\t\t\tprint(<span class=\"string\">\"~HowMany()\"</span>);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\">HowMany <span class=\"title\">f</span><span class=\"params\">(HowMany x)</span></span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"begin of f\"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tx.print(<span class=\"string\">\"x argumnet inside f()\"</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"end of f\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> x;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">\tHowMany h;</div><div class=\"line\">\th.print(<span class=\"string\">\"after construction of h\"</span>);</div><div class=\"line\">\tHowMany h2 = f(h);</div><div class=\"line\">\th.print(<span class=\"string\">\"after call to f()\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(HowMany): objectCont = 2<br>begin of f<br>x argumnet inside f(): objectCont = 2<br>end of f<br>HowMany(HowMany): objectCont = 3<br>~HowMany(): objectCont = 2<br>after call to f(): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>平衡也都回来了，最大的时候有三个。有三个，一个是f里面的那个x，有一个h，h2是第三个。<br>这说明，如果有一个类的构造函数，这个构造函数它的参数是自己那个类型的const reference，这个构造函数就可以在做这种类型的初始化的时候别调用（初始化这个对象的时候，用另外一个这个类的对象来初始化）。这样的构造函数我们有一个特殊的名字，拷贝构造。<br><img src=\"/images/C++/copy1.png\" alt=\"Alt text\"><br>如果你没有给一个那样的拷贝构造，C++会自动给你一个，当然如果你给了，你就可以通过你给的那个拷贝构造怎么去控制。比方说你有些东西不想拷贝，或者有些东西要做很多的安排。如果你没有那个拷贝构造，编译器会给你一个，那个会拷贝每一个成员变量，它会做成员变量对成员变量的拷贝，这是在成员级别的拷贝，不是字节对字节的拷贝，只不过如果你的member全部都不是对象，那么它的最终结果就是字节对字节的拷贝。如果你的成员中有指针的话，那么拷贝就是指针的拷贝，就是两个指针指向同一片内存。同样的道理如果出现成员变量是reference的话，也会发生reference的拷贝，这两个reference是绑定同一个变量。<br>我们可以试一下<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> A&#123;</div><div class=\"line\">\t<span class=\"keyword\">public</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">int</span> *i;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setI</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</div><div class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">getI</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> A::setI(<span class=\"keyword\">int</span> i)&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>-&gt;i = &amp;i;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span>* A::getI()&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>-&gt;i;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">int</span> i = <span class=\"number\">12</span>;</div><div class=\"line\">\tA a;</div><div class=\"line\">\ta.i = &amp;i;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;a.i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tA b = a;</div><div class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;b.i&lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>结果：<br>0x7fff5089faac<br>0x7fff5089faac<br>地址是一样的，但是我们所希望的是，它们不只想同一块内存。这就需要人为的写出拷贝构造去给那个指针分配空间。<br>一般来说，调用拷贝构造的场景就是初始化的时候，但是初始化又有一些隐藏的场景（调函数的时候）。还有就是我们有一个函数，这个函数会创建一个本定变量（对象）将这个对象return回去，也会发生拷贝构造。<br>initialization指的是只能做一次的，任何对象的初始化只能做一次。做完之后，在对它做任何动作那就是assignment而不是initialization。所以到了C++就不要用char<em>，char</em>是c的字符串，到了C++用string。<br>到了现在我们到了现在，写一个类就应该写三个函数，不管用到没用到，第一个：default constructor；第二个：virtual destructor；第三个：copy constructor；不要依赖于编译器给你的那个。如果不想对象被拷贝，就把拷贝构造函数设置为private的。</p>\n"},{"title":"静态对象","date":"2017-05-31T10:39:21.000Z","_content":"# 静态对象\n![Alt text](/images/C++/static1.png)\nstatic关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。\n它的第一层含义是说：存储是持久存储的。\n第二层含义是说：它的访问性，是受局限的。\n这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。\n到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。\n我们在进一步去理解这两样东西是什么。\n![Alt text](/images/C++/static2.png)\n我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。\nstatic的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。\n## Static inside functions\n- Value is remembered for entire program\n- Initialization occurs only once\n其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。\n![Alt text](/images/C++/static3.png)\n如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。\n也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。\n如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。\n如果你的对象是全局的呢？\n![Alt text](/images/C++/static4.png)\n它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。\n这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。\n![Alt text](/images/C++/static5.png)\n","source":"_posts/C++/静态对象.md","raw":"---\ntitle: 静态对象\ndate: 2017-05-31 18:39:21\ntags:\ncategories: C++\n---\n# 静态对象\n![Alt text](/images/C++/static1.png)\nstatic关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。\n它的第一层含义是说：存储是持久存储的。\n第二层含义是说：它的访问性，是受局限的。\n这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。\n到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。\n我们在进一步去理解这两样东西是什么。\n![Alt text](/images/C++/static2.png)\n我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。\nstatic的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。\n## Static inside functions\n- Value is remembered for entire program\n- Initialization occurs only once\n其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。\n![Alt text](/images/C++/static3.png)\n如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。\n也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。\n如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。\n如果你的对象是全局的呢？\n![Alt text](/images/C++/static4.png)\n它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。\n这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。\n![Alt text](/images/C++/static5.png)\n","slug":"C++/静态对象","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6ss000lhhu2radoxe59","content":"<h1 id=\"静态对象\"><a href=\"#静态对象\" class=\"headerlink\" title=\"静态对象\"></a>静态对象</h1><p><img src=\"/images/C++/static1.png\" alt=\"Alt text\"><br>static关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。<br>它的第一层含义是说：存储是持久存储的。<br>第二层含义是说：它的访问性，是受局限的。<br>这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。<br>到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。<br>我们在进一步去理解这两样东西是什么。<br><img src=\"/images/C++/static2.png\" alt=\"Alt text\"><br>我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。<br>static的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。</p>\n<h2 id=\"Static-inside-functions\"><a href=\"#Static-inside-functions\" class=\"headerlink\" title=\"Static inside functions\"></a>Static inside functions</h2><ul>\n<li>Value is remembered for entire program</li>\n<li>Initialization occurs only once<br>其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。<br><img src=\"/images/C++/static3.png\" alt=\"Alt text\"><br>如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。<br>也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。<br>如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。<br>如果你的对象是全局的呢？<br><img src=\"/images/C++/static4.png\" alt=\"Alt text\"><br>它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。<br>这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。<br><img src=\"/images/C++/static5.png\" alt=\"Alt text\"></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"静态对象\"><a href=\"#静态对象\" class=\"headerlink\" title=\"静态对象\"></a>静态对象</h1><p><img src=\"/images/C++/static1.png\" alt=\"Alt text\"><br>static关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。<br>它的第一层含义是说：存储是持久存储的。<br>第二层含义是说：它的访问性，是受局限的。<br>这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。<br>到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。<br>我们在进一步去理解这两样东西是什么。<br><img src=\"/images/C++/static2.png\" alt=\"Alt text\"><br>我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。<br>static的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。</p>\n<h2 id=\"Static-inside-functions\"><a href=\"#Static-inside-functions\" class=\"headerlink\" title=\"Static inside functions\"></a>Static inside functions</h2><ul>\n<li>Value is remembered for entire program</li>\n<li>Initialization occurs only once<br>其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。<br><img src=\"/images/C++/static3.png\" alt=\"Alt text\"><br>如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。<br>也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。<br>如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。<br>如果你的对象是全局的呢？<br><img src=\"/images/C++/static4.png\" alt=\"Alt text\"><br>它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。<br>这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。<br><img src=\"/images/C++/static5.png\" alt=\"Alt text\"></li>\n</ul>\n"},{"title":"快速排序","date":"2017-05-17T07:39:03.000Z","_content":"# 4.1分而治之\n我们将探索分而治之（divide and conquer,D&C）一种的递归式问题解方法。\n书上介绍了一个土地划分的问题。将一个长方形的土地分为由多个正方形组成的，求这个正方形最大的面积是多少。\n有兴趣的可以看一下。还介绍了欧几里得算法。\n现在说一下D&C的工作原理：\n- **(1)**:找出简单的基线条件；\n- **(2)**:确定如何缩小问题的规模，使其符合基准条件。\nD&C并非可用于解决问题的算法，而是一种解决问题的思路。我们看一个例子。\n给定一个数组\n![Alt text](/images/algorithm/D&R1.png)\n你需要将这些数字想加，并返回结果。使用循环很容易完成这种任务。\n```python\ndef sum(list):\n\ts = 0\n\tfor i in list:\n\t\ts += i\n\treturn s\nlist = [1,2,3]\nprint sum(list)\n```\n但如何使用递归来完成任务呢？\n- **第一步**:找出基线条件。想一下最简单的数组是什么样子的。\n![Alt text](/images/algorithm/D&R2.png)\n- **第二步**:每次递归调用都必须离空数组更近一步。\n![Alt text](/images/algorithm/D&R3.png)\n![Alt text](/images/algorithm/D&R4.png)\n参考代码：\n```python\ndef sum(list):\n\tif len(list)==0:\n\t\treturn 0\n\telse :\n\t\treturn list.pop(0) + sum(list)\nlist = [1,2,3,4]\n\nprint sum(list)\n```\n>提示\n编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样。\n\n我们修改成尾递归：\n```python\ndef sum(list,s=0):\n\n\tif len(list)==0:\n\t\treturn s\n\telse :\n\t\treturn sum(list,list.pop(0) + sum(list))\nlist = [1,2,3,4]\n\nprint sum(list)\n```\n注意基准条件！\n![Alt text](/images/algorithm/D&R5.png)\n## 快速排序\n快速查找是一种常用的排序算法，比选择排序快得多。例如C语言标准裤中的函数qsort实现的就是快速排序。快速排序也使用了D&C。\n![Alt text](/images/algorithm/D&R6.png)\n这被称为分区partitioning（分区）。现在你有：\n- **1**:一个由所有小于基准值的数字组成的子数组；\n- **2**:基准值；\n- **3**:一个由所有大于基准值的数组组成的子数组。\n![Alt text](/images/algorithm/D&R7.png)\n``` python\ndef quest(list):\n\tif len(list) < 2 :\n\t\treturn list\n\telse :\n\t\tfirst = list[0]\n\t\tleft = [i for i in list[1:] if i <= first]\n\t\tright = [i for i in list[1:] if i > first]\n\t\treturn quest(left)+[first]+quest(right)\nlist = [11,2,55,22,33,11]\nprint quest(list)\n```\n对于像时间复杂度O(n)，其实n的前面有一个固定的时间量C，有的时候可以忽略，例如：\n二分法查找和简单查找来说，前者是O(logn)后者是O(n)比如二分法查找的固定的时间常量是1秒而简单查找固定的时间量是10毫秒。你可能认为简单查找的常量为10毫秒，而二分查的常量为1秒，因为简单查找的速度要快得多。现在假设你要在包含40亿歌元素的列表中查找：\n简单查找 10毫秒*40亿 ＝ 463天\n二分查找 1秒*32      = 32秒\n正如你看到的常量没有影响。但是有的时候，常量的影响可能很大。\n例如：合并排序和快速排序，快速排序最早情况是O(n2)和选择排序是一样的时间复杂度，平均情况是O(nlogn)。而合并排序，平均和最糟都是O(nlogn)。快速排序的时间复杂度跟基准值有关。快速排序最佳情况的时间复杂度是O(logn)（调用栈的高度是O(logn）而每层需要的时间是O(n)所以最佳情况是O(n) * O(logn) = O(nlogn)\n在最糟情况下，有O(n)曾，因此时间复杂度是O(n)* O(n) = O(n2)\n","source":"_posts/algorithm/快速排序.md","raw":"---\ntitle: 快速排序\ndate: 2017-05-17 15:39:03\ntags:\ncategories: 算法\n---\n# 4.1分而治之\n我们将探索分而治之（divide and conquer,D&C）一种的递归式问题解方法。\n书上介绍了一个土地划分的问题。将一个长方形的土地分为由多个正方形组成的，求这个正方形最大的面积是多少。\n有兴趣的可以看一下。还介绍了欧几里得算法。\n现在说一下D&C的工作原理：\n- **(1)**:找出简单的基线条件；\n- **(2)**:确定如何缩小问题的规模，使其符合基准条件。\nD&C并非可用于解决问题的算法，而是一种解决问题的思路。我们看一个例子。\n给定一个数组\n![Alt text](/images/algorithm/D&R1.png)\n你需要将这些数字想加，并返回结果。使用循环很容易完成这种任务。\n```python\ndef sum(list):\n\ts = 0\n\tfor i in list:\n\t\ts += i\n\treturn s\nlist = [1,2,3]\nprint sum(list)\n```\n但如何使用递归来完成任务呢？\n- **第一步**:找出基线条件。想一下最简单的数组是什么样子的。\n![Alt text](/images/algorithm/D&R2.png)\n- **第二步**:每次递归调用都必须离空数组更近一步。\n![Alt text](/images/algorithm/D&R3.png)\n![Alt text](/images/algorithm/D&R4.png)\n参考代码：\n```python\ndef sum(list):\n\tif len(list)==0:\n\t\treturn 0\n\telse :\n\t\treturn list.pop(0) + sum(list)\nlist = [1,2,3,4]\n\nprint sum(list)\n```\n>提示\n编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样。\n\n我们修改成尾递归：\n```python\ndef sum(list,s=0):\n\n\tif len(list)==0:\n\t\treturn s\n\telse :\n\t\treturn sum(list,list.pop(0) + sum(list))\nlist = [1,2,3,4]\n\nprint sum(list)\n```\n注意基准条件！\n![Alt text](/images/algorithm/D&R5.png)\n## 快速排序\n快速查找是一种常用的排序算法，比选择排序快得多。例如C语言标准裤中的函数qsort实现的就是快速排序。快速排序也使用了D&C。\n![Alt text](/images/algorithm/D&R6.png)\n这被称为分区partitioning（分区）。现在你有：\n- **1**:一个由所有小于基准值的数字组成的子数组；\n- **2**:基准值；\n- **3**:一个由所有大于基准值的数组组成的子数组。\n![Alt text](/images/algorithm/D&R7.png)\n``` python\ndef quest(list):\n\tif len(list) < 2 :\n\t\treturn list\n\telse :\n\t\tfirst = list[0]\n\t\tleft = [i for i in list[1:] if i <= first]\n\t\tright = [i for i in list[1:] if i > first]\n\t\treturn quest(left)+[first]+quest(right)\nlist = [11,2,55,22,33,11]\nprint quest(list)\n```\n对于像时间复杂度O(n)，其实n的前面有一个固定的时间量C，有的时候可以忽略，例如：\n二分法查找和简单查找来说，前者是O(logn)后者是O(n)比如二分法查找的固定的时间常量是1秒而简单查找固定的时间量是10毫秒。你可能认为简单查找的常量为10毫秒，而二分查的常量为1秒，因为简单查找的速度要快得多。现在假设你要在包含40亿歌元素的列表中查找：\n简单查找 10毫秒*40亿 ＝ 463天\n二分查找 1秒*32      = 32秒\n正如你看到的常量没有影响。但是有的时候，常量的影响可能很大。\n例如：合并排序和快速排序，快速排序最早情况是O(n2)和选择排序是一样的时间复杂度，平均情况是O(nlogn)。而合并排序，平均和最糟都是O(nlogn)。快速排序的时间复杂度跟基准值有关。快速排序最佳情况的时间复杂度是O(logn)（调用栈的高度是O(logn）而每层需要的时间是O(n)所以最佳情况是O(n) * O(logn) = O(nlogn)\n在最糟情况下，有O(n)曾，因此时间复杂度是O(n)* O(n) = O(n2)\n","slug":"algorithm/快速排序","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6su000ohhu2dwlcwdof","content":"<h1 id=\"4-1分而治之\"><a href=\"#4-1分而治之\" class=\"headerlink\" title=\"4.1分而治之\"></a>4.1分而治之</h1><p>我们将探索分而治之（divide and conquer,D&amp;C）一种的递归式问题解方法。<br>书上介绍了一个土地划分的问题。将一个长方形的土地分为由多个正方形组成的，求这个正方形最大的面积是多少。<br>有兴趣的可以看一下。还介绍了欧几里得算法。<br>现在说一下D&amp;C的工作原理：</p>\n<ul>\n<li><strong>(1)</strong>:找出简单的基线条件；</li>\n<li><strong>(2)</strong>:确定如何缩小问题的规模，使其符合基准条件。<br>D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。我们看一个例子。<br>给定一个数组<br><img src=\"/images/algorithm/D&amp;R1.png\" alt=\"Alt text\"><br>你需要将这些数字想加，并返回结果。使用循环很容易完成这种任务。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\ts = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list:</div><div class=\"line\">\t\ts += i</div><div class=\"line\">\t<span class=\"keyword\">return</span> s</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但如何使用递归来完成任务呢？</p>\n<ul>\n<li><strong>第一步</strong>:找出基线条件。想一下最简单的数组是什么样子的。<br><img src=\"/images/algorithm/D&amp;R2.png\" alt=\"Alt text\"></li>\n<li><strong>第二步</strong>:每次递归调用都必须离空数组更近一步。<br><img src=\"/images/algorithm/D&amp;R3.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/D&amp;R4.png\" alt=\"Alt text\"><br>参考代码：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list)==<span class=\"number\">0</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> list.pop(<span class=\"number\">0</span>) + sum(list)</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>提示<br>编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样。</p>\n</blockquote>\n<p>我们修改成尾递归：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list,s=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list)==<span class=\"number\">0</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> s</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sum(list,list.pop(<span class=\"number\">0</span>) + sum(list))</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure></p>\n<p>注意基准条件！<br><img src=\"/images/algorithm/D&amp;R5.png\" alt=\"Alt text\"></p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速查找是一种常用的排序算法，比选择排序快得多。例如C语言标准裤中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。<br><img src=\"/images/algorithm/D&amp;R6.png\" alt=\"Alt text\"><br>这被称为分区partitioning（分区）。现在你有：</p>\n<ul>\n<li><strong>1</strong>:一个由所有小于基准值的数字组成的子数组；</li>\n<li><strong>2</strong>:基准值；</li>\n<li><strong>3</strong>:一个由所有大于基准值的数组组成的子数组。<br><img src=\"/images/algorithm/D&amp;R7.png\" alt=\"Alt text\"><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quest</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list) &lt; <span class=\"number\">2</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> list</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\tfirst = list[<span class=\"number\">0</span>]</div><div class=\"line\">\t\tleft = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &lt;= first]</div><div class=\"line\">\t\tright = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &gt; first]</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> quest(left)+[first]+quest(right)</div><div class=\"line\">list = [<span class=\"number\">11</span>,<span class=\"number\">2</span>,<span class=\"number\">55</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">11</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> quest(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于像时间复杂度O(n)，其实n的前面有一个固定的时间量C，有的时候可以忽略，例如：<br>二分法查找和简单查找来说，前者是O(logn)后者是O(n)比如二分法查找的固定的时间常量是1秒而简单查找固定的时间量是10毫秒。你可能认为简单查找的常量为10毫秒，而二分查的常量为1秒，因为简单查找的速度要快得多。现在假设你要在包含40亿歌元素的列表中查找：<br>简单查找 10毫秒<em>40亿 ＝ 463天<br>二分查找 1秒</em>32      = 32秒<br>正如你看到的常量没有影响。但是有的时候，常量的影响可能很大。<br>例如：合并排序和快速排序，快速排序最早情况是O(n2)和选择排序是一样的时间复杂度，平均情况是O(nlogn)。而合并排序，平均和最糟都是O(nlogn)。快速排序的时间复杂度跟基准值有关。快速排序最佳情况的时间复杂度是O(logn)（调用栈的高度是O(logn）而每层需要的时间是O(n)所以最佳情况是O(n) <em> O(logn) = O(nlogn)<br>在最糟情况下，有O(n)曾，因此时间复杂度是O(n)</em> O(n) = O(n2)</p>\n","excerpt":"","more":"<h1 id=\"4-1分而治之\"><a href=\"#4-1分而治之\" class=\"headerlink\" title=\"4.1分而治之\"></a>4.1分而治之</h1><p>我们将探索分而治之（divide and conquer,D&amp;C）一种的递归式问题解方法。<br>书上介绍了一个土地划分的问题。将一个长方形的土地分为由多个正方形组成的，求这个正方形最大的面积是多少。<br>有兴趣的可以看一下。还介绍了欧几里得算法。<br>现在说一下D&amp;C的工作原理：</p>\n<ul>\n<li><strong>(1)</strong>:找出简单的基线条件；</li>\n<li><strong>(2)</strong>:确定如何缩小问题的规模，使其符合基准条件。<br>D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。我们看一个例子。<br>给定一个数组<br><img src=\"/images/algorithm/D&amp;R1.png\" alt=\"Alt text\"><br>你需要将这些数字想加，并返回结果。使用循环很容易完成这种任务。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\ts = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list:</div><div class=\"line\">\t\ts += i</div><div class=\"line\">\t<span class=\"keyword\">return</span> s</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>但如何使用递归来完成任务呢？</p>\n<ul>\n<li><strong>第一步</strong>:找出基线条件。想一下最简单的数组是什么样子的。<br><img src=\"/images/algorithm/D&amp;R2.png\" alt=\"Alt text\"></li>\n<li><strong>第二步</strong>:每次递归调用都必须离空数组更近一步。<br><img src=\"/images/algorithm/D&amp;R3.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/D&amp;R4.png\" alt=\"Alt text\"><br>参考代码：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list)==<span class=\"number\">0</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> list.pop(<span class=\"number\">0</span>) + sum(list)</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p>提示<br>编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样。</p>\n</blockquote>\n<p>我们修改成尾递归：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">(list,s=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list)==<span class=\"number\">0</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> s</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> sum(list,list.pop(<span class=\"number\">0</span>) + sum(list))</div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> sum(list)</div></pre></td></tr></table></figure></p>\n<p>注意基准条件！<br><img src=\"/images/algorithm/D&amp;R5.png\" alt=\"Alt text\"></p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速查找是一种常用的排序算法，比选择排序快得多。例如C语言标准裤中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。<br><img src=\"/images/algorithm/D&amp;R6.png\" alt=\"Alt text\"><br>这被称为分区partitioning（分区）。现在你有：</p>\n<ul>\n<li><strong>1</strong>:一个由所有小于基准值的数字组成的子数组；</li>\n<li><strong>2</strong>:基准值；</li>\n<li><strong>3</strong>:一个由所有大于基准值的数组组成的子数组。<br><img src=\"/images/algorithm/D&amp;R7.png\" alt=\"Alt text\"><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quest</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> len(list) &lt; <span class=\"number\">2</span> :</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> list</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\tfirst = list[<span class=\"number\">0</span>]</div><div class=\"line\">\t\tleft = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &lt;= first]</div><div class=\"line\">\t\tright = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> list[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &gt; first]</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> quest(left)+[first]+quest(right)</div><div class=\"line\">list = [<span class=\"number\">11</span>,<span class=\"number\">2</span>,<span class=\"number\">55</span>,<span class=\"number\">22</span>,<span class=\"number\">33</span>,<span class=\"number\">11</span>]</div><div class=\"line\"><span class=\"keyword\">print</span> quest(list)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对于像时间复杂度O(n)，其实n的前面有一个固定的时间量C，有的时候可以忽略，例如：<br>二分法查找和简单查找来说，前者是O(logn)后者是O(n)比如二分法查找的固定的时间常量是1秒而简单查找固定的时间量是10毫秒。你可能认为简单查找的常量为10毫秒，而二分查的常量为1秒，因为简单查找的速度要快得多。现在假设你要在包含40亿歌元素的列表中查找：<br>简单查找 10毫秒<em>40亿 ＝ 463天<br>二分查找 1秒</em>32      = 32秒<br>正如你看到的常量没有影响。但是有的时候，常量的影响可能很大。<br>例如：合并排序和快速排序，快速排序最早情况是O(n2)和选择排序是一样的时间复杂度，平均情况是O(nlogn)。而合并排序，平均和最糟都是O(nlogn)。快速排序的时间复杂度跟基准值有关。快速排序最佳情况的时间复杂度是O(logn)（调用栈的高度是O(logn）而每层需要的时间是O(n)所以最佳情况是O(n) <em> O(logn) = O(nlogn)<br>在最糟情况下，有O(n)曾，因此时间复杂度是O(n)</em> O(n) = O(n2)</p>\n"},{"title":"散列表","date":"2017-05-25T05:04:44.000Z","_content":"# 散列表\n散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。\n对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。\n## 5.1散列函数\n散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。\n![Alt text](/images/algorithm/hash1.png)\n散列函数必须满足一些要求：\n- **它必须是一致的。** 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。\n- **它应将不同的输入映射到不同的数字。** 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。\n\n-------------------\n动手写一个例子:\n``` python\nmap = dict() # 和map = {}等价\n\nmap[\"apple\"] = 1\nmap[\"pear\"] = 1\n\nprint map\n```\n结果：\n{'pear': 1, 'apple': 1}\n散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。\n- 散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。\n- 散列函数将不同的输入映射到不同的索引。\n- 散列函数知道数组有多大，只返回有效的索引。\n在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。\n## 将散列表用作缓存\n![Alt text](/images/algorithm/hash2.png)\n将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。\n大致上说缓存具有以下两个优点：\n- 用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。\n- Facebook需要做的工作也就更少了。\n缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。\n## 小结\n这里总结一下，散列表适合用于：\n- 模仿映射关系\n- 防止重复\n- 缓存/记住数据，以免服务器再通过处理来生成它们。\n### 代码\n``` python\ncache = {}\n\ndef get_page(url):\n\tif cahce.get(url):\n\t\treturn cachae[\"url\"]\n\telse :\n\t\tdata = get_data_from_server(url)\n\t\tcache[url] = data\n\t\treturn data\n```\n# 冲突\n冲突：给两个键分配的位置相同。\n避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。\n简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。\n![Alt text](/images/algorithm/hash3.png)\n但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。\n这里有两个教训:\n- **散列函数很重要。** 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。\n- **如果散列表存储的链表很长，散列表的速度将急剧下降。** 然而使用散列函数很好，这些链表就不会很长！\n## 性能\n在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。\n![Alt text](/images/algorithm/hash4.png)\n图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。\n在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。\n![Alt text](/images/algorithm/hash5.png)\n在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：\n- 较低的填裝因子；\n- 良好的散列函数。\n## 填装因子\n散列表的填裝因子很容易计算：\n![Alt text](/images/algorithm/hash6.png)\n散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。\n![Alt text](/images/algorithm/hash7.png)\n这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。\n你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。\n## 良好的散列函数\n![Alt text](/images/algorithm/hash8.png)\n","source":"_posts/algorithm/散列表.md","raw":"---\ntitle: 散列表\ndate: 2017-05-25 13:04:44\ntags:\ncategories: 算法\n---\n# 散列表\n散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。\n对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。\n## 5.1散列函数\n散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。\n![Alt text](/images/algorithm/hash1.png)\n散列函数必须满足一些要求：\n- **它必须是一致的。** 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。\n- **它应将不同的输入映射到不同的数字。** 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。\n\n-------------------\n动手写一个例子:\n``` python\nmap = dict() # 和map = {}等价\n\nmap[\"apple\"] = 1\nmap[\"pear\"] = 1\n\nprint map\n```\n结果：\n{'pear': 1, 'apple': 1}\n散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。\n- 散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。\n- 散列函数将不同的输入映射到不同的索引。\n- 散列函数知道数组有多大，只返回有效的索引。\n在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。\n## 将散列表用作缓存\n![Alt text](/images/algorithm/hash2.png)\n将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。\n大致上说缓存具有以下两个优点：\n- 用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。\n- Facebook需要做的工作也就更少了。\n缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。\n## 小结\n这里总结一下，散列表适合用于：\n- 模仿映射关系\n- 防止重复\n- 缓存/记住数据，以免服务器再通过处理来生成它们。\n### 代码\n``` python\ncache = {}\n\ndef get_page(url):\n\tif cahce.get(url):\n\t\treturn cachae[\"url\"]\n\telse :\n\t\tdata = get_data_from_server(url)\n\t\tcache[url] = data\n\t\treturn data\n```\n# 冲突\n冲突：给两个键分配的位置相同。\n避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。\n简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。\n![Alt text](/images/algorithm/hash3.png)\n但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。\n这里有两个教训:\n- **散列函数很重要。** 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。\n- **如果散列表存储的链表很长，散列表的速度将急剧下降。** 然而使用散列函数很好，这些链表就不会很长！\n## 性能\n在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。\n![Alt text](/images/algorithm/hash4.png)\n图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。\n在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。\n![Alt text](/images/algorithm/hash5.png)\n在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：\n- 较低的填裝因子；\n- 良好的散列函数。\n## 填装因子\n散列表的填裝因子很容易计算：\n![Alt text](/images/algorithm/hash6.png)\n散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。\n![Alt text](/images/algorithm/hash7.png)\n这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。\n你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。\n## 良好的散列函数\n![Alt text](/images/algorithm/hash8.png)\n","slug":"algorithm/散列表","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sw000qhhu2mk139bp8","content":"<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。<br>对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。</p>\n<h2 id=\"5-1散列函数\"><a href=\"#5-1散列函数\" class=\"headerlink\" title=\"5.1散列函数\"></a>5.1散列函数</h2><p>散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。<br><img src=\"/images/algorithm/hash1.png\" alt=\"Alt text\"><br>散列函数必须满足一些要求：</p>\n<ul>\n<li><strong>它必须是一致的。</strong> 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。</li>\n<li><strong>它应将不同的输入映射到不同的数字。</strong> 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</li>\n</ul>\n<hr>\n<p>动手写一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">map = dict() <span class=\"comment\"># 和map = &#123;&#125;等价</span></div><div class=\"line\"></div><div class=\"line\">map[<span class=\"string\">\"apple\"</span>] = <span class=\"number\">1</span></div><div class=\"line\">map[<span class=\"string\">\"pear\"</span>] = <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> map</div></pre></td></tr></table></figure></p>\n<p>结果：<br>{‘pear’: 1, ‘apple’: 1}<br>散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。</p>\n<ul>\n<li>散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。</li>\n<li>散列函数将不同的输入映射到不同的索引。</li>\n<li>散列函数知道数组有多大，只返回有效的索引。<br>在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。<h2 id=\"将散列表用作缓存\"><a href=\"#将散列表用作缓存\" class=\"headerlink\" title=\"将散列表用作缓存\"></a>将散列表用作缓存</h2><img src=\"/images/algorithm/hash2.png\" alt=\"Alt text\"><br>将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。<br>大致上说缓存具有以下两个优点：</li>\n<li>用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。</li>\n<li>Facebook需要做的工作也就更少了。<br>缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2>这里总结一下，散列表适合用于：</li>\n<li>模仿映射关系</li>\n<li>防止重复</li>\n<li>缓存/记住数据，以免服务器再通过处理来生成它们。<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cache = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_page</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> cahce.get(url):</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> cachae[<span class=\"string\">\"url\"</span>]</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\tdata = get_data_from_server(url)</div><div class=\"line\">\t\tcache[url] = data</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> data</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><p>冲突：给两个键分配的位置相同。<br>避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。<br>简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br><img src=\"/images/algorithm/hash3.png\" alt=\"Alt text\"><br>但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。<br>这里有两个教训:</p>\n<ul>\n<li><strong>散列函数很重要。</strong> 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。</li>\n<li><strong>如果散列表存储的链表很长，散列表的速度将急剧下降。</strong> 然而使用散列函数很好，这些链表就不会很长！<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2>在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。<br><img src=\"/images/algorithm/hash4.png\" alt=\"Alt text\"><br>图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。<br>在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。<br><img src=\"/images/algorithm/hash5.png\" alt=\"Alt text\"><br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：</li>\n<li>较低的填裝因子；</li>\n<li>良好的散列函数。<h2 id=\"填装因子\"><a href=\"#填装因子\" class=\"headerlink\" title=\"填装因子\"></a>填装因子</h2>散列表的填裝因子很容易计算：<br><img src=\"/images/algorithm/hash6.png\" alt=\"Alt text\"><br>散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。<br><img src=\"/images/algorithm/hash7.png\" alt=\"Alt text\"><br>这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。<br>你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。<h2 id=\"良好的散列函数\"><a href=\"#良好的散列函数\" class=\"headerlink\" title=\"良好的散列函数\"></a>良好的散列函数</h2><img src=\"/images/algorithm/hash8.png\" alt=\"Alt text\"></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h1><p>散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。<br>对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。</p>\n<h2 id=\"5-1散列函数\"><a href=\"#5-1散列函数\" class=\"headerlink\" title=\"5.1散列函数\"></a>5.1散列函数</h2><p>散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。<br><img src=\"/images/algorithm/hash1.png\" alt=\"Alt text\"><br>散列函数必须满足一些要求：</p>\n<ul>\n<li><strong>它必须是一致的。</strong> 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。</li>\n<li><strong>它应将不同的输入映射到不同的数字。</strong> 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</li>\n</ul>\n<hr>\n<p>动手写一个例子:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">map = dict() <span class=\"comment\"># 和map = &#123;&#125;等价</span></div><div class=\"line\"></div><div class=\"line\">map[<span class=\"string\">\"apple\"</span>] = <span class=\"number\">1</span></div><div class=\"line\">map[<span class=\"string\">\"pear\"</span>] = <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> map</div></pre></td></tr></table></figure></p>\n<p>结果：<br>{‘pear’: 1, ‘apple’: 1}<br>散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。</p>\n<ul>\n<li>散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。</li>\n<li>散列函数将不同的输入映射到不同的索引。</li>\n<li>散列函数知道数组有多大，只返回有效的索引。<br>在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。<h2 id=\"将散列表用作缓存\"><a href=\"#将散列表用作缓存\" class=\"headerlink\" title=\"将散列表用作缓存\"></a>将散列表用作缓存</h2><img src=\"/images/algorithm/hash2.png\" alt=\"Alt text\"><br>将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。<br>大致上说缓存具有以下两个优点：</li>\n<li>用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。</li>\n<li>Facebook需要做的工作也就更少了。<br>缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2>这里总结一下，散列表适合用于：</li>\n<li>模仿映射关系</li>\n<li>防止重复</li>\n<li>缓存/记住数据，以免服务器再通过处理来生成它们。<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">cache = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_page</span><span class=\"params\">(url)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> cahce.get(url):</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> cachae[<span class=\"string\">\"url\"</span>]</div><div class=\"line\">\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\tdata = get_data_from_server(url)</div><div class=\"line\">\t\tcache[url] = data</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> data</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"冲突\"><a href=\"#冲突\" class=\"headerlink\" title=\"冲突\"></a>冲突</h1><p>冲突：给两个键分配的位置相同。<br>避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。<br>简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br><img src=\"/images/algorithm/hash3.png\" alt=\"Alt text\"><br>但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。<br>这里有两个教训:</p>\n<ul>\n<li><strong>散列函数很重要。</strong> 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。</li>\n<li><strong>如果散列表存储的链表很长，散列表的速度将急剧下降。</strong> 然而使用散列函数很好，这些链表就不会很长！<h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2>在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。<br><img src=\"/images/algorithm/hash4.png\" alt=\"Alt text\"><br>图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。<br>在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。<br><img src=\"/images/algorithm/hash5.png\" alt=\"Alt text\"><br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：</li>\n<li>较低的填裝因子；</li>\n<li>良好的散列函数。<h2 id=\"填装因子\"><a href=\"#填装因子\" class=\"headerlink\" title=\"填装因子\"></a>填装因子</h2>散列表的填裝因子很容易计算：<br><img src=\"/images/algorithm/hash6.png\" alt=\"Alt text\"><br>散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。<br><img src=\"/images/algorithm/hash7.png\" alt=\"Alt text\"><br>这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。<br>你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。<h2 id=\"良好的散列函数\"><a href=\"#良好的散列函数\" class=\"headerlink\" title=\"良好的散列函数\"></a>良好的散列函数</h2><img src=\"/images/algorithm/hash8.png\" alt=\"Alt text\"></li>\n</ul>\n"},{"title":"二分法查询","date":"2017-05-01T07:50:51.000Z","_content":"# 缘起\n最近在学python学完之后，想做点东西巩固一下python的语法，无意间在知乎上看到有人推荐算法图解这本书，讲了一些算法关键我是看到它的代码使用python写的，正好在巩固python的语法的同时将算法好好学一下。\n## 二分法\n下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。\n你的目标是以最小的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。\n假设你从1开始依次网上猜，猜测过程会是这样。\n也就是我们所说的遍历，这是简单查找，更准确的说法是傻栈。每猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！\n### 更佳的查找方法\n下面是一种更佳的猜法。从50开始。\n![Alt text](/images/algorithm/1.png)\n![Alt text](/images/algorithm/2.png)\n因此,使用二分查找只需18步——少多了!一般而言,对于包含n个元素的列表,用二分查\n找最多需要log2n步,而简单查找最多需要n步。\n![Alt text](/images/algorithm/3.png)\n下面是我自己写的：\n``` python\nlist = []\nfor n in range(1,101) : # 先给这个列表赋值，1到100\n\tlist.append(n)\nleft = 0  # 第一个节点\nright = len(list)-1 # 最后一个节点\nmid = int((left + right) / 2) # 中间节点\nnumber = input('plase input a number:\\n') # 这要注意一点python2 当中 input 输入的数字就是数字而python3 中输入数字会变成字符串\nnumber = int(number)\nwhile list[mid] != number and left < right: # 如果输入的数字不是中间节点，并且整个列表没有查询完进入循环\n\tif number>list[mid]:    # 如果数字大于中间节点，我们就把中间节点之前的所有都丢弃（不在前半部分）\n\t\tleft = mid +1\t    # 让最左节点成为原来节点的后继节点\n\telif  number<list[mid]: # 如果数字小于中间节点，我们就把中间节点之后的所有都丢弃（不在后半部分）\n\t\tright = mid - 1\t\t# 让最右节点成为原来节点的前驱节点\n\tmid = int((left + right) / 2) # 每一次循环将mid重新赋值\n\tprint('left= %d'%left)\n\tprint('right= %d'%right)\nif list[mid] == number:\n\tprint('找到了 是第%d个元素。'%(mid+1))\nelse  :\n\tprint('没找到')\n```\n下面是书上的的代码：\n``` python\nlist = []\nfor n in range(1,101) :\n\tlist.append(n)\ndef binary_search(list,item):\n\t\tlow = 0\n\t\thigh = len(list) - 1\n\n\t\twhile low <= high:\n\t\t\tmid =  (low + high) / 2\n\t\t\tguess = list[mid]\n\t\t\tif guess == item :\n\t\t\t\treturn mid\n\t\t\tif guess > item:\n\t\t\t\thigh = mid -1\n\t\t\telse :\n\t\t\t\tlow = mid + 1\nif binary_search(list,11) != None :\n\tprint(list[binary_search(list,11)])\n\n```\n![Alt text](/images/algorithm/4.png)\n","source":"_posts/algorithm/算法.md","raw":"---\ntitle: 二分法查询\ndate: 2017-05-01 15:50:51\ntags:\ncategories: 算法\n---\n# 缘起\n最近在学python学完之后，想做点东西巩固一下python的语法，无意间在知乎上看到有人推荐算法图解这本书，讲了一些算法关键我是看到它的代码使用python写的，正好在巩固python的语法的同时将算法好好学一下。\n## 二分法\n下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。\n你的目标是以最小的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。\n假设你从1开始依次网上猜，猜测过程会是这样。\n也就是我们所说的遍历，这是简单查找，更准确的说法是傻栈。每猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！\n### 更佳的查找方法\n下面是一种更佳的猜法。从50开始。\n![Alt text](/images/algorithm/1.png)\n![Alt text](/images/algorithm/2.png)\n因此,使用二分查找只需18步——少多了!一般而言,对于包含n个元素的列表,用二分查\n找最多需要log2n步,而简单查找最多需要n步。\n![Alt text](/images/algorithm/3.png)\n下面是我自己写的：\n``` python\nlist = []\nfor n in range(1,101) : # 先给这个列表赋值，1到100\n\tlist.append(n)\nleft = 0  # 第一个节点\nright = len(list)-1 # 最后一个节点\nmid = int((left + right) / 2) # 中间节点\nnumber = input('plase input a number:\\n') # 这要注意一点python2 当中 input 输入的数字就是数字而python3 中输入数字会变成字符串\nnumber = int(number)\nwhile list[mid] != number and left < right: # 如果输入的数字不是中间节点，并且整个列表没有查询完进入循环\n\tif number>list[mid]:    # 如果数字大于中间节点，我们就把中间节点之前的所有都丢弃（不在前半部分）\n\t\tleft = mid +1\t    # 让最左节点成为原来节点的后继节点\n\telif  number<list[mid]: # 如果数字小于中间节点，我们就把中间节点之后的所有都丢弃（不在后半部分）\n\t\tright = mid - 1\t\t# 让最右节点成为原来节点的前驱节点\n\tmid = int((left + right) / 2) # 每一次循环将mid重新赋值\n\tprint('left= %d'%left)\n\tprint('right= %d'%right)\nif list[mid] == number:\n\tprint('找到了 是第%d个元素。'%(mid+1))\nelse  :\n\tprint('没找到')\n```\n下面是书上的的代码：\n``` python\nlist = []\nfor n in range(1,101) :\n\tlist.append(n)\ndef binary_search(list,item):\n\t\tlow = 0\n\t\thigh = len(list) - 1\n\n\t\twhile low <= high:\n\t\t\tmid =  (low + high) / 2\n\t\t\tguess = list[mid]\n\t\t\tif guess == item :\n\t\t\t\treturn mid\n\t\t\tif guess > item:\n\t\t\t\thigh = mid -1\n\t\t\telse :\n\t\t\t\tlow = mid + 1\nif binary_search(list,11) != None :\n\tprint(list[binary_search(list,11)])\n\n```\n![Alt text](/images/algorithm/4.png)\n","slug":"algorithm/算法","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sy000thhu2te0yuv0i","content":"<h1 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h1><p>最近在学python学完之后，想做点东西巩固一下python的语法，无意间在知乎上看到有人推荐算法图解这本书，讲了一些算法关键我是看到它的代码使用python写的，正好在巩固python的语法的同时将算法好好学一下。</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。<br>你的目标是以最小的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。<br>假设你从1开始依次网上猜，猜测过程会是这样。<br>也就是我们所说的遍历，这是简单查找，更准确的说法是傻栈。每猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！</p>\n<h3 id=\"更佳的查找方法\"><a href=\"#更佳的查找方法\" class=\"headerlink\" title=\"更佳的查找方法\"></a>更佳的查找方法</h3><p>下面是一种更佳的猜法。从50开始。<br><img src=\"/images/algorithm/1.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/2.png\" alt=\"Alt text\"><br>因此,使用二分查找只需18步——少多了!一般而言,对于包含n个元素的列表,用二分查<br>找最多需要log2n步,而简单查找最多需要n步。<br><img src=\"/images/algorithm/3.png\" alt=\"Alt text\"><br>下面是我自己写的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">101</span>) : <span class=\"comment\"># 先给这个列表赋值，1到100</span></div><div class=\"line\">\tlist.append(n)</div><div class=\"line\">left = <span class=\"number\">0</span>  <span class=\"comment\"># 第一个节点</span></div><div class=\"line\">right = len(list)<span class=\"number\">-1</span> <span class=\"comment\"># 最后一个节点</span></div><div class=\"line\">mid = int((left + right) / <span class=\"number\">2</span>) <span class=\"comment\"># 中间节点</span></div><div class=\"line\">number = input(<span class=\"string\">'plase input a number:\\n'</span>) <span class=\"comment\"># 这要注意一点python2 当中 input 输入的数字就是数字而python3 中输入数字会变成字符串</span></div><div class=\"line\">number = int(number)</div><div class=\"line\"><span class=\"keyword\">while</span> list[mid] != number <span class=\"keyword\">and</span> left &lt; right: <span class=\"comment\"># 如果输入的数字不是中间节点，并且整个列表没有查询完进入循环</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> number&gt;list[mid]:    <span class=\"comment\"># 如果数字大于中间节点，我们就把中间节点之前的所有都丢弃（不在前半部分）</span></div><div class=\"line\">\t\tleft = mid +<span class=\"number\">1</span>\t    <span class=\"comment\"># 让最左节点成为原来节点的后继节点</span></div><div class=\"line\">\t<span class=\"keyword\">elif</span>  number&lt;list[mid]: <span class=\"comment\"># 如果数字小于中间节点，我们就把中间节点之后的所有都丢弃（不在后半部分）</span></div><div class=\"line\">\t\tright = mid - <span class=\"number\">1</span>\t\t<span class=\"comment\"># 让最右节点成为原来节点的前驱节点</span></div><div class=\"line\">\tmid = int((left + right) / <span class=\"number\">2</span>) <span class=\"comment\"># 每一次循环将mid重新赋值</span></div><div class=\"line\">\tprint(<span class=\"string\">'left= %d'</span>%left)</div><div class=\"line\">\tprint(<span class=\"string\">'right= %d'</span>%right)</div><div class=\"line\"><span class=\"keyword\">if</span> list[mid] == number:</div><div class=\"line\">\tprint(<span class=\"string\">'找到了 是第%d个元素。'</span>%(mid+<span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"keyword\">else</span>  :</div><div class=\"line\">\tprint(<span class=\"string\">'没找到'</span>)</div></pre></td></tr></table></figure></p>\n<p>下面是书上的的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">101</span>) :</div><div class=\"line\">\tlist.append(n)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(list,item)</span>:</span></div><div class=\"line\">\t\tlow = <span class=\"number\">0</span></div><div class=\"line\">\t\thigh = len(list) - <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> low &lt;= high:</div><div class=\"line\">\t\t\tmid =  (low + high) / <span class=\"number\">2</span></div><div class=\"line\">\t\t\tguess = list[mid]</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> guess == item :</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> guess &gt; item:</div><div class=\"line\">\t\t\t\thigh = mid <span class=\"number\">-1</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">if</span> binary_search(list,<span class=\"number\">11</span>) != <span class=\"keyword\">None</span> :</div><div class=\"line\">\tprint(list[binary_search(list,<span class=\"number\">11</span>)])</div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/algorithm/4.png\" alt=\"Alt text\"></p>\n","excerpt":"","more":"<h1 id=\"缘起\"><a href=\"#缘起\" class=\"headerlink\" title=\"缘起\"></a>缘起</h1><p>最近在学python学完之后，想做点东西巩固一下python的语法，无意间在知乎上看到有人推荐算法图解这本书，讲了一些算法关键我是看到它的代码使用python写的，正好在巩固python的语法的同时将算法好好学一下。</p>\n<h2 id=\"二分法\"><a href=\"#二分法\" class=\"headerlink\" title=\"二分法\"></a>二分法</h2><p>下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。<br>你的目标是以最小的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。<br>假设你从1开始依次网上猜，猜测过程会是这样。<br>也就是我们所说的遍历，这是简单查找，更准确的说法是傻栈。每猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！</p>\n<h3 id=\"更佳的查找方法\"><a href=\"#更佳的查找方法\" class=\"headerlink\" title=\"更佳的查找方法\"></a>更佳的查找方法</h3><p>下面是一种更佳的猜法。从50开始。<br><img src=\"/images/algorithm/1.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/2.png\" alt=\"Alt text\"><br>因此,使用二分查找只需18步——少多了!一般而言,对于包含n个元素的列表,用二分查<br>找最多需要log2n步,而简单查找最多需要n步。<br><img src=\"/images/algorithm/3.png\" alt=\"Alt text\"><br>下面是我自己写的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">101</span>) : <span class=\"comment\"># 先给这个列表赋值，1到100</span></div><div class=\"line\">\tlist.append(n)</div><div class=\"line\">left = <span class=\"number\">0</span>  <span class=\"comment\"># 第一个节点</span></div><div class=\"line\">right = len(list)<span class=\"number\">-1</span> <span class=\"comment\"># 最后一个节点</span></div><div class=\"line\">mid = int((left + right) / <span class=\"number\">2</span>) <span class=\"comment\"># 中间节点</span></div><div class=\"line\">number = input(<span class=\"string\">'plase input a number:\\n'</span>) <span class=\"comment\"># 这要注意一点python2 当中 input 输入的数字就是数字而python3 中输入数字会变成字符串</span></div><div class=\"line\">number = int(number)</div><div class=\"line\"><span class=\"keyword\">while</span> list[mid] != number <span class=\"keyword\">and</span> left &lt; right: <span class=\"comment\"># 如果输入的数字不是中间节点，并且整个列表没有查询完进入循环</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> number&gt;list[mid]:    <span class=\"comment\"># 如果数字大于中间节点，我们就把中间节点之前的所有都丢弃（不在前半部分）</span></div><div class=\"line\">\t\tleft = mid +<span class=\"number\">1</span>\t    <span class=\"comment\"># 让最左节点成为原来节点的后继节点</span></div><div class=\"line\">\t<span class=\"keyword\">elif</span>  number&lt;list[mid]: <span class=\"comment\"># 如果数字小于中间节点，我们就把中间节点之后的所有都丢弃（不在后半部分）</span></div><div class=\"line\">\t\tright = mid - <span class=\"number\">1</span>\t\t<span class=\"comment\"># 让最右节点成为原来节点的前驱节点</span></div><div class=\"line\">\tmid = int((left + right) / <span class=\"number\">2</span>) <span class=\"comment\"># 每一次循环将mid重新赋值</span></div><div class=\"line\">\tprint(<span class=\"string\">'left= %d'</span>%left)</div><div class=\"line\">\tprint(<span class=\"string\">'right= %d'</span>%right)</div><div class=\"line\"><span class=\"keyword\">if</span> list[mid] == number:</div><div class=\"line\">\tprint(<span class=\"string\">'找到了 是第%d个元素。'</span>%(mid+<span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"keyword\">else</span>  :</div><div class=\"line\">\tprint(<span class=\"string\">'没找到'</span>)</div></pre></td></tr></table></figure></p>\n<p>下面是书上的的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">list = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">101</span>) :</div><div class=\"line\">\tlist.append(n)</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(list,item)</span>:</span></div><div class=\"line\">\t\tlow = <span class=\"number\">0</span></div><div class=\"line\">\t\thigh = len(list) - <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> low &lt;= high:</div><div class=\"line\">\t\t\tmid =  (low + high) / <span class=\"number\">2</span></div><div class=\"line\">\t\t\tguess = list[mid]</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> guess == item :</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> mid</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> guess &gt; item:</div><div class=\"line\">\t\t\t\thigh = mid <span class=\"number\">-1</span></div><div class=\"line\">\t\t\t<span class=\"keyword\">else</span> :</div><div class=\"line\">\t\t\t\tlow = mid + <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">if</span> binary_search(list,<span class=\"number\">11</span>) != <span class=\"keyword\">None</span> :</div><div class=\"line\">\tprint(list[binary_search(list,<span class=\"number\">11</span>)])</div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/algorithm/4.png\" alt=\"Alt text\"></p>\n"},{"title":"选择排序","date":"2017-05-05T12:33:45.000Z","_content":"# 选择排序\n选择排序算法的时间复杂度是O(n2)\n很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中\n```python\n#coding=utf-8\nlist = [22,12,33,121,1,333,222]\n# 1.找出当前列表中的最小的数的下标\ndef getMinId(list):\n\tminId  = 0\n\tfor n in range(len(list)):\n\t\tif list[n] < list[minId]:\n\t\t\tminId = n\n\n\treturn minId\n# 2. 将最小的放在最前面\ndef select(list):\n\tnewList = []\n\tfor n in range(len(list)):\n\t\tnewList.append(list.pop(getMinId(list)))\n\n\treturn newList\nprint select(list)\n\n```\n这个是我自己写的\n``` python\n#coding=utf-8\nlist = [1,85,45,56,11,33,55,8,64,5]\ndef getMinId(list):\n\tminId = 0\n\tfor n in range(0,len(list)):\n\t\tif  list[n] < list[minId]:\n\t\t\tminId = n\n\treturn minId\nnewArray = []\nfor n in range(len(list)):\n\ta = getMinId(list)\n\tnewArray.append(list.pop(a))   # list.pop[a] 将下标为a的元素从列表中删除\n\t# newArray.append(list[a])     # 等同这两行代码\n\t# del list[a]\nprint newArray\n\n```\n这个是算法图解书上写的，思想上是一样的。\n","source":"_posts/algorithm/选择排序.md","raw":"---\ntitle: 选择排序\ndate: 2017-05-05 20:33:45\ntags:\ncategories: 算法\n---\n# 选择排序\n选择排序算法的时间复杂度是O(n2)\n很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中\n```python\n#coding=utf-8\nlist = [22,12,33,121,1,333,222]\n# 1.找出当前列表中的最小的数的下标\ndef getMinId(list):\n\tminId  = 0\n\tfor n in range(len(list)):\n\t\tif list[n] < list[minId]:\n\t\t\tminId = n\n\n\treturn minId\n# 2. 将最小的放在最前面\ndef select(list):\n\tnewList = []\n\tfor n in range(len(list)):\n\t\tnewList.append(list.pop(getMinId(list)))\n\n\treturn newList\nprint select(list)\n\n```\n这个是我自己写的\n``` python\n#coding=utf-8\nlist = [1,85,45,56,11,33,55,8,64,5]\ndef getMinId(list):\n\tminId = 0\n\tfor n in range(0,len(list)):\n\t\tif  list[n] < list[minId]:\n\t\t\tminId = n\n\treturn minId\nnewArray = []\nfor n in range(len(list)):\n\ta = getMinId(list)\n\tnewArray.append(list.pop(a))   # list.pop[a] 将下标为a的元素从列表中删除\n\t# newArray.append(list[a])     # 等同这两行代码\n\t# del list[a]\nprint newArray\n\n```\n这个是算法图解书上写的，思想上是一样的。\n","slug":"algorithm/选择排序","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6sz000vhhu2etrul9b5","content":"<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><p>选择排序算法的时间复杂度是O(n2)<br>很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\">list = [<span class=\"number\">22</span>,<span class=\"number\">12</span>,<span class=\"number\">33</span>,<span class=\"number\">121</span>,<span class=\"number\">1</span>,<span class=\"number\">333</span>,<span class=\"number\">222</span>]</div><div class=\"line\"><span class=\"comment\"># 1.找出当前列表中的最小的数的下标</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinId</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tminId  = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> list[n] &lt; list[minId]:</div><div class=\"line\">\t\t\tminId = n</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> minId</div><div class=\"line\"><span class=\"comment\"># 2. 将最小的放在最前面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tnewList = []</div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\t\tnewList.append(list.pop(getMinId(list)))</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> newList</div><div class=\"line\"><span class=\"keyword\">print</span> select(list)</div></pre></td></tr></table></figure></p>\n<p>这个是我自己写的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">85</span>,<span class=\"number\">45</span>,<span class=\"number\">56</span>,<span class=\"number\">11</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">8</span>,<span class=\"number\">64</span>,<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinId</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tminId = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(list)):</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>  list[n] &lt; list[minId]:</div><div class=\"line\">\t\t\tminId = n</div><div class=\"line\">\t<span class=\"keyword\">return</span> minId</div><div class=\"line\">newArray = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\ta = getMinId(list)</div><div class=\"line\">\tnewArray.append(list.pop(a))   <span class=\"comment\"># list.pop[a] 将下标为a的元素从列表中删除</span></div><div class=\"line\">\t<span class=\"comment\"># newArray.append(list[a])     # 等同这两行代码</span></div><div class=\"line\">\t<span class=\"comment\"># del list[a]</span></div><div class=\"line\"><span class=\"keyword\">print</span> newArray</div></pre></td></tr></table></figure></p>\n<p>这个是算法图解书上写的，思想上是一样的。</p>\n","excerpt":"","more":"<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><p>选择排序算法的时间复杂度是O(n2)<br>很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\">list = [<span class=\"number\">22</span>,<span class=\"number\">12</span>,<span class=\"number\">33</span>,<span class=\"number\">121</span>,<span class=\"number\">1</span>,<span class=\"number\">333</span>,<span class=\"number\">222</span>]</div><div class=\"line\"><span class=\"comment\"># 1.找出当前列表中的最小的数的下标</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinId</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tminId  = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\t\t<span class=\"keyword\">if</span> list[n] &lt; list[minId]:</div><div class=\"line\">\t\t\tminId = n</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> minId</div><div class=\"line\"><span class=\"comment\"># 2. 将最小的放在最前面</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">select</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tnewList = []</div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\t\tnewList.append(list.pop(getMinId(list)))</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> newList</div><div class=\"line\"><span class=\"keyword\">print</span> select(list)</div></pre></td></tr></table></figure></p>\n<p>这个是我自己写的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\">list = [<span class=\"number\">1</span>,<span class=\"number\">85</span>,<span class=\"number\">45</span>,<span class=\"number\">56</span>,<span class=\"number\">11</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">8</span>,<span class=\"number\">64</span>,<span class=\"number\">5</span>]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getMinId</span><span class=\"params\">(list)</span>:</span></div><div class=\"line\">\tminId = <span class=\"number\">0</span></div><div class=\"line\">\t<span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len(list)):</div><div class=\"line\">\t\t<span class=\"keyword\">if</span>  list[n] &lt; list[minId]:</div><div class=\"line\">\t\t\tminId = n</div><div class=\"line\">\t<span class=\"keyword\">return</span> minId</div><div class=\"line\">newArray = []</div><div class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> range(len(list)):</div><div class=\"line\">\ta = getMinId(list)</div><div class=\"line\">\tnewArray.append(list.pop(a))   <span class=\"comment\"># list.pop[a] 将下标为a的元素从列表中删除</span></div><div class=\"line\">\t<span class=\"comment\"># newArray.append(list[a])     # 等同这两行代码</span></div><div class=\"line\">\t<span class=\"comment\"># del list[a]</span></div><div class=\"line\"><span class=\"keyword\">print</span> newArray</div></pre></td></tr></table></figure></p>\n<p>这个是算法图解书上写的，思想上是一样的。</p>\n"},{"title":"递归","date":"2017-05-15T12:55:05.000Z","_content":"# 递归\n算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”\n我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。\n假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。\n祖母告诉你,钥匙很可能在下面这个盒子里。\n![Alt text](/images/algorithm/recursive1.png)\n这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。\n下面是一种方法。\n![Alt text](/images/algorithm/recursive2.png)\n(1) 创建一个要查找的盒子堆。\n(2) 从盒子堆取出一个盒子,在里面找。\n(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!\n(5) 回到第二步。\n下面是另一种方法。\n![Alt text](/images/algorithm/recursive3.png)\n(1) 检查盒子中的每样东西。\n(2) 如果是盒子,就回到第一步。\n(3) 如果是钥匙,就大功告成!\n在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。\n```python\ndef look_for_key(main_box):\n    pile = main_box.make_a_pile_to_look_through()\n    while pile is not empty:\n        box = pile.grab_a_box()\n        for item in box:\n            if item.is_a_box():\n                pile.append(item)\n            elif item.is_a_key():\n                print \"found the key!\"\n```\n第二种方法使用递归——函数调用自己,这种方法的伪代码如下。\n```python\ndef look_for_key(box):\n    for item in box:\n        if item.is_a_box():\n            look_for_key(item) # 递归\n        elif item.is_a_key():\n            print \"found the key!\"\n```\n这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能\n 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。\n ## 基线条件和递归条件\n 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。\n 如下：\n ```python\n def recursive(n):\n\tprint n\n\trecursive(n-1)\n\nrecursive(1)\n ```\n 会在console上打印：\n ![Alt text](/images/algorithm/recursive4.png)\n 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。\n 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。\n 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。\n 把上面的代码改一下，来给函数添加基线条件：\n ```python\n def recursive(n):\n \tprint n\n \tif n <=0 : # 基线条件\n \t\treturn\n \telse :     # 递归条件\n \t\trecursive(n-1)\n\n recursive(10)\n ```\n 输出结果：10到0\n![Alt text](/images/algorithm/recursive5.png)\n## 栈\n接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。\n栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。\n```python\ndef greet2(name):\n\tprint \"how are you, \"+name + \"!\"\ndef bye():\n\tprint \"ok bye!\"\ndef greet(name):\n\tprint \"hello, \" + name +\"!\"\n\tgreet2(name)\n\tprint \"getting ready to say bye...\"\n\tbye()\n\ngreet('jenius')\n```\n输出结果：\nhello, jenius!\nhow are you, jenius!\ngetting ready to say bye...\nok bye!\n这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。\n## 递归调用栈\n递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其\n定义如下:5! = 5 * 4 * 3 * 2 * 1。同理,factorial(3)为3 * 2 * 1。下面是计算阶乘的递归函数。\n```python\ndef fact(x):\n\tif x == 1:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\nprint fact(3)\n```\n![Alt text](/images/algorithm/recursive6.png)\n![Alt text](/images/algorithm/recursive7.png)\n **注意：** 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。\n栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。\n![Alt text](/images/algorithm/recursive8.png)\n![Alt text](/images/algorithm/recursive9.png)\n使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。\n- **1** ：重新编写代码,转而使用循环。\n- **2** ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言\n都支持尾递归。\n## 尾调用\n在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。\n尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：\n_ **调用自身函数(Self-called)；**\n_ **计算仅占用常量栈空间(Stack Space)。**\n而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。\n由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除(Tail Call Elimination)或尾调用优化(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。\n一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归取代循环而不丧失性能。\n这个是维基百科给的一个定义。\n我看别人的博客中\n写到尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n``` python\ndef f(x) :\n    return g(x)\n```\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n以下两种情况，都不属于尾调用。\n\n``` python\n# 情况一\ndef f1(x){\n  int y = g(x)\n  return y\n}\n# 情况二\ndef f2(x){\n  return g(x) + 1\n}\n\n```\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n``` python\ndef f(x) :\n  if x > 0 :\n    return m(x)\n\n  return n(x)\n\n```\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n我们知道，函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个\"调用栈\"（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n\n## 尾递归\n虽然说算法图解说尾递归不在讨论范围之内，还是想深究一下。\n我去知乎看了一下：\nfunction story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}\n\n作者：酿泉\n链接：https://www.zhihu.com/question/20761771/answer/23254340\n来源：知乎\n这个是点赞最高的179。\n这个是第二164\n参考我在Stackoverflow问的这个问题：Why does C preserves both goto and while, involving tail recursion以及：What is tail-recursion?为什么C语言同时保留‘goto’语句和‘while’，和尾递归有什么关系？尾递归是什么？尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。SICP中描述了一个内存占用曲线，用以上答案中的Python代码为例（普通递归）：\n```python\ndef recsum(x):\n  if x == 1:\n    return x\n  else:\n    return x + recsum(x - 1)\n```\n当调用recsum(5)，Python调试器中发生如下状况：\n```\nrecsum(5)\n5 + recsum(4)\n5 + (4 + recsum(3))\n5 + (4 + (3 + recsum(2)))\n5 + (4 + (3 + (2 + recsum(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。\n---------------------\n（一个替代方案：迭代）\n```python\nfor i in range(6):\n  sum += i\n```\n因为Python，Java，Pascal等等无法在语言中实现尾递归优化(Tail Call Optimization, TCO)，所以采用了for, while, goto等特殊结构代替recursive的表述。Scheme则不需要这样曲折地表达，一旦写成尾递归形式，就可以进行尾递归优化。---------------------Python中可以写（尾递归）：\n```python\ndef tailrecsum(x, running_total=0):\n  if x == 0:\n    return running_total\n  else:\n    return tailrecsum(x - 1, running_total + x)\n\n```\n理论上类似上面：\ntailrecsum(5, 0)\ntailrecsum(4, 5)\ntailrecsum(3, 9)\ntailrecsum(2, 12)\ntailrecsum(1, 14)\ntailrecsum(0, 15)\n15\n观察到，tailrecsum(x, y)中形式变量y的实际变量值是不断更新的，对比普通递归就很清楚，后者每个recsum()调用中y值不变，仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：\n```python\nreturn tailrec(x+1);\n```\n而\n```python\nreturn tailrec(x+1) + x;\n```\n则不可以。因为无法更新tailrec()函数内的实际变量，只是新建一个栈。但Python不能尾递归优化（Java不行，C可以，我不知道为什么），这里是用它做个例子。====================================如何优化尾递归：在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化\n作者：匿名用户\n链接：https://www.zhihu.com/question/20761771/answer/19996299\n来源：知乎\n最后对比一下没有用尾递归的阶乘代码和用了尾递归的阶乘代码：\n用尾递归的：\n```python\ndef fact(x,y):\n\tif x == 1:\n\t\treturn y\n\telse:\n\t\treturn fact(x-1,x*y)\nprint fact(5,1)\n```\n普通递归：\n```python\ndef fact(x):\n\tif x == 1:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\nprint fact(5)\n```\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生\"栈溢出\"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。\n用普通递归写的那个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n![Alt text](/images/algorithm/lyf.png)\n由此可见，\"尾调用优化\"对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署\"尾调用优化\"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n## 递归函数的改写\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n``` python\ndef tailFactorial(n, total) :\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n\n\ndef factorial(n) :\n  return tailFactorial(n, 1);\n\n\nfactorial(5) // 120\n```\n第二种方法就简单多了，就是采用函数默认值。(java中没有函数默认值)\n``` python\ndef factorial(n, total = 1) :\n  if n === 1 :\n      return total\n  return factorial(n - 1, n * total)\n\nfactorial(5) // 120\n```\n上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。\n","source":"_posts/algorithm/递归.md","raw":"---\ntitle: 递归\ndate: 2017-05-15 20:55:05\ntags:\ncategories: 算法\n---\n# 递归\n算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”\n我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。\n假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。\n祖母告诉你,钥匙很可能在下面这个盒子里。\n![Alt text](/images/algorithm/recursive1.png)\n这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。\n下面是一种方法。\n![Alt text](/images/algorithm/recursive2.png)\n(1) 创建一个要查找的盒子堆。\n(2) 从盒子堆取出一个盒子,在里面找。\n(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!\n(5) 回到第二步。\n下面是另一种方法。\n![Alt text](/images/algorithm/recursive3.png)\n(1) 检查盒子中的每样东西。\n(2) 如果是盒子,就回到第一步。\n(3) 如果是钥匙,就大功告成!\n在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。\n```python\ndef look_for_key(main_box):\n    pile = main_box.make_a_pile_to_look_through()\n    while pile is not empty:\n        box = pile.grab_a_box()\n        for item in box:\n            if item.is_a_box():\n                pile.append(item)\n            elif item.is_a_key():\n                print \"found the key!\"\n```\n第二种方法使用递归——函数调用自己,这种方法的伪代码如下。\n```python\ndef look_for_key(box):\n    for item in box:\n        if item.is_a_box():\n            look_for_key(item) # 递归\n        elif item.is_a_key():\n            print \"found the key!\"\n```\n这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能\n 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。\n ## 基线条件和递归条件\n 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。\n 如下：\n ```python\n def recursive(n):\n\tprint n\n\trecursive(n-1)\n\nrecursive(1)\n ```\n 会在console上打印：\n ![Alt text](/images/algorithm/recursive4.png)\n 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。\n 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。\n 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。\n 把上面的代码改一下，来给函数添加基线条件：\n ```python\n def recursive(n):\n \tprint n\n \tif n <=0 : # 基线条件\n \t\treturn\n \telse :     # 递归条件\n \t\trecursive(n-1)\n\n recursive(10)\n ```\n 输出结果：10到0\n![Alt text](/images/algorithm/recursive5.png)\n## 栈\n接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。\n栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。\n```python\ndef greet2(name):\n\tprint \"how are you, \"+name + \"!\"\ndef bye():\n\tprint \"ok bye!\"\ndef greet(name):\n\tprint \"hello, \" + name +\"!\"\n\tgreet2(name)\n\tprint \"getting ready to say bye...\"\n\tbye()\n\ngreet('jenius')\n```\n输出结果：\nhello, jenius!\nhow are you, jenius!\ngetting ready to say bye...\nok bye!\n这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。\n## 递归调用栈\n递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其\n定义如下:5! = 5 * 4 * 3 * 2 * 1。同理,factorial(3)为3 * 2 * 1。下面是计算阶乘的递归函数。\n```python\ndef fact(x):\n\tif x == 1:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\nprint fact(3)\n```\n![Alt text](/images/algorithm/recursive6.png)\n![Alt text](/images/algorithm/recursive7.png)\n **注意：** 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。\n栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。\n![Alt text](/images/algorithm/recursive8.png)\n![Alt text](/images/algorithm/recursive9.png)\n使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。\n- **1** ：重新编写代码,转而使用循环。\n- **2** ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言\n都支持尾递归。\n## 尾调用\n在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。\n尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：\n_ **调用自身函数(Self-called)；**\n_ **计算仅占用常量栈空间(Stack Space)。**\n而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。\n由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除(Tail Call Elimination)或尾调用优化(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。\n一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归取代循环而不丧失性能。\n这个是维基百科给的一个定义。\n我看别人的博客中\n写到尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n``` python\ndef f(x) :\n    return g(x)\n```\n上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。\n以下两种情况，都不属于尾调用。\n\n``` python\n# 情况一\ndef f1(x){\n  int y = g(x)\n  return y\n}\n# 情况二\ndef f2(x){\n  return g(x) + 1\n}\n\n```\n尾调用不一定出现在函数尾部，只要是最后一步操作即可。\n``` python\ndef f(x) :\n  if x > 0 :\n    return m(x)\n\n  return n(x)\n\n```\n上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。\n尾调用之所以与其他调用不同，就在于它的特殊的调用位置。\n我们知道，函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个\"调用栈\"（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n\n## 尾递归\n虽然说算法图解说尾递归不在讨论范围之内，还是想深究一下。\n我去知乎看了一下：\nfunction story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}\n\n作者：酿泉\n链接：https://www.zhihu.com/question/20761771/answer/23254340\n来源：知乎\n这个是点赞最高的179。\n这个是第二164\n参考我在Stackoverflow问的这个问题：Why does C preserves both goto and while, involving tail recursion以及：What is tail-recursion?为什么C语言同时保留‘goto’语句和‘while’，和尾递归有什么关系？尾递归是什么？尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。SICP中描述了一个内存占用曲线，用以上答案中的Python代码为例（普通递归）：\n```python\ndef recsum(x):\n  if x == 1:\n    return x\n  else:\n    return x + recsum(x - 1)\n```\n当调用recsum(5)，Python调试器中发生如下状况：\n```\nrecsum(5)\n5 + recsum(4)\n5 + (4 + recsum(3))\n5 + (4 + (3 + recsum(2)))\n5 + (4 + (3 + (2 + recsum(1))))\n5 + (4 + (3 + (2 + 1)))\n5 + (4 + (3 + 3))\n5 + (4 + 6)\n5 + 10\n15\n```\n这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。\n---------------------\n（一个替代方案：迭代）\n```python\nfor i in range(6):\n  sum += i\n```\n因为Python，Java，Pascal等等无法在语言中实现尾递归优化(Tail Call Optimization, TCO)，所以采用了for, while, goto等特殊结构代替recursive的表述。Scheme则不需要这样曲折地表达，一旦写成尾递归形式，就可以进行尾递归优化。---------------------Python中可以写（尾递归）：\n```python\ndef tailrecsum(x, running_total=0):\n  if x == 0:\n    return running_total\n  else:\n    return tailrecsum(x - 1, running_total + x)\n\n```\n理论上类似上面：\ntailrecsum(5, 0)\ntailrecsum(4, 5)\ntailrecsum(3, 9)\ntailrecsum(2, 12)\ntailrecsum(1, 14)\ntailrecsum(0, 15)\n15\n观察到，tailrecsum(x, y)中形式变量y的实际变量值是不断更新的，对比普通递归就很清楚，后者每个recsum()调用中y值不变，仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：\n```python\nreturn tailrec(x+1);\n```\n而\n```python\nreturn tailrec(x+1) + x;\n```\n则不可以。因为无法更新tailrec()函数内的实际变量，只是新建一个栈。但Python不能尾递归优化（Java不行，C可以，我不知道为什么），这里是用它做个例子。====================================如何优化尾递归：在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化\n作者：匿名用户\n链接：https://www.zhihu.com/question/20761771/answer/19996299\n来源：知乎\n最后对比一下没有用尾递归的阶乘代码和用了尾递归的阶乘代码：\n用尾递归的：\n```python\ndef fact(x,y):\n\tif x == 1:\n\t\treturn y\n\telse:\n\t\treturn fact(x-1,x*y)\nprint fact(5,1)\n```\n普通递归：\n```python\ndef fact(x):\n\tif x == 1:\n\t\treturn 1\n\telse:\n\t\treturn x * fact(x-1)\nprint fact(5)\n```\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生\"栈溢出\"错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生\"栈溢出\"错误。\n用普通递归写的那个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n![Alt text](/images/algorithm/lyf.png)\n由此可见，\"尾调用优化\"对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署\"尾调用优化\"。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。\n## 递归函数的改写\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？\n两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。\n``` python\ndef tailFactorial(n, total) :\n  if (n === 1) return total;\n  return tailFactorial(n - 1, n * total);\n\n\ndef factorial(n) :\n  return tailFactorial(n, 1);\n\n\nfactorial(5) // 120\n```\n第二种方法就简单多了，就是采用函数默认值。(java中没有函数默认值)\n``` python\ndef factorial(n, total = 1) :\n  if n === 1 :\n      return total\n  return factorial(n - 1, n * total)\n\nfactorial(5) // 120\n```\n上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。\n","slug":"algorithm/递归","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6t0000xhhu2sjjpje8n","content":"<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”<br>我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。<br>假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。<br>祖母告诉你,钥匙很可能在下面这个盒子里。<br><img src=\"/images/algorithm/recursive1.png\" alt=\"Alt text\"><br>这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。<br>下面是一种方法。<br><img src=\"/images/algorithm/recursive2.png\" alt=\"Alt text\"><br>(1) 创建一个要查找的盒子堆。<br>(2) 从盒子堆取出一个盒子,在里面找。<br>(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!<br>(5) 回到第二步。<br>下面是另一种方法。<br><img src=\"/images/algorithm/recursive3.png\" alt=\"Alt text\"><br>(1) 检查盒子中的每样东西。<br>(2) 如果是盒子,就回到第一步。<br>(3) 如果是钥匙,就大功告成!<br>在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">look_for_key</span><span class=\"params\">(main_box)</span>:</span></div><div class=\"line\">    pile = main_box.make_a_pile_to_look_through()</div><div class=\"line\">    <span class=\"keyword\">while</span> pile <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> empty:</div><div class=\"line\">        box = pile.grab_a_box()</div><div class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> box:</div><div class=\"line\">            <span class=\"keyword\">if</span> item.is_a_box():</div><div class=\"line\">                pile.append(item)</div><div class=\"line\">            <span class=\"keyword\">elif</span> item.is_a_key():</div><div class=\"line\">                <span class=\"keyword\">print</span> <span class=\"string\">\"found the key!\"</span></div></pre></td></tr></table></figure></p>\n<p>第二种方法使用递归——函数调用自己,这种方法的伪代码如下。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">look_for_key</span><span class=\"params\">(box)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> box:</div><div class=\"line\">        <span class=\"keyword\">if</span> item.is_a_box():</div><div class=\"line\">            look_for_key(item) <span class=\"comment\"># 递归</span></div><div class=\"line\">        <span class=\"keyword\">elif</span> item.is_a_key():</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"found the key!\"</span></div></pre></td></tr></table></figure></p>\n<p>这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能<br> 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。</p>\n<h2 id=\"基线条件和递归条件\"><a href=\"#基线条件和递归条件\" class=\"headerlink\" title=\"基线条件和递归条件\"></a>基线条件和递归条件</h2><p> 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。<br> 如下：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recursive</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> n</div><div class=\"line\">\trecursive(n<span class=\"number\">-1</span>)</div><div class=\"line\"></div><div class=\"line\">recursive(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p> 会在console上打印：<br> <img src=\"/images/algorithm/recursive4.png\" alt=\"Alt text\"><br> 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。<br> 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。<br> 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。<br> 把上面的代码改一下，来给函数添加基线条件：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recursive</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> n</div><div class=\"line\">\t<span class=\"keyword\">if</span> n &lt;=<span class=\"number\">0</span> : <span class=\"comment\"># 基线条件</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :     <span class=\"comment\"># 递归条件</span></div><div class=\"line\">\t\trecursive(n<span class=\"number\">-1</span>)</div><div class=\"line\"></div><div class=\"line\">recursive(<span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p> 输出结果：10到0<br><img src=\"/images/algorithm/recursive5.png\" alt=\"Alt text\"></p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。<br>栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet2</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"how are you, \"</span>+name + <span class=\"string\">\"!\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bye</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"ok bye!\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"hello, \"</span> + name +<span class=\"string\">\"!\"</span></div><div class=\"line\">\tgreet2(name)</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"getting ready to say bye...\"</span></div><div class=\"line\">\tbye()</div><div class=\"line\"></div><div class=\"line\">greet(<span class=\"string\">'jenius'</span>)</div></pre></td></tr></table></figure></p>\n<p>输出结果：<br>hello, jenius!<br>how are you, jenius!<br>getting ready to say bye…<br>ok bye!<br>这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。</p>\n<h2 id=\"递归调用栈\"><a href=\"#递归调用栈\" class=\"headerlink\" title=\"递归调用栈\"></a>递归调用栈</h2><p>递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其<br>定义如下:5! = 5 <em> 4 </em> 3 <em> 2 </em> 1。同理,factorial(3)为3 <em> 2 </em> 1。下面是计算阶乘的递归函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> x * fact(x<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">3</span>)</div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/algorithm/recursive6.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/recursive7.png\" alt=\"Alt text\"><br> <strong>注意：</strong> 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。<br>栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。<br><img src=\"/images/algorithm/recursive8.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/recursive9.png\" alt=\"Alt text\"><br>使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。</p>\n<ul>\n<li><strong>1</strong> ：重新编写代码,转而使用循环。</li>\n<li><strong>2</strong> ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言<br>都支持尾递归。<h2 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h2>在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。<br>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：<br><em> <strong>调用自身函数(Self-called)；</strong>\n</em> <strong>计算仅占用常量栈空间(Stack Space)。</strong><br>而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。<br>由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除(Tail Call Elimination)或尾调用优化(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。<br>一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归取代循环而不丧失性能。<br>这个是维基百科给的一个定义。<br>我看别人的博客中<br>写到尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span> :</span></div><div class=\"line\">    <span class=\"keyword\">return</span> g(x)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。<br>以下两种情况，都不属于尾调用。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 情况一</div><div class=\"line\">def f1(x)&#123;</div><div class=\"line\">  int y = g(x)</div><div class=\"line\">  return y</div><div class=\"line\">&#125;</div><div class=\"line\"># 情况二</div><div class=\"line\">def f2(x)&#123;</div><div class=\"line\">  return g(x) + 1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> :</div><div class=\"line\">    <span class=\"keyword\">return</span> m(x)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> n(x)</div></pre></td></tr></table></figure></p>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。<br>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。<br>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>\n<h2 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h2><p>虽然说算法图解说尾递归不在讨论范围之内，还是想深究一下。<br>我去知乎看了一下：<br>function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}</p>\n<p>作者：酿泉<br>链接：<a href=\"https://www.zhihu.com/question/20761771/answer/23254340\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/20761771/answer/23254340</a><br>来源：知乎<br>这个是点赞最高的179。<br>这个是第二164<br>参考我在Stackoverflow问的这个问题：Why does C preserves both goto and while, involving tail recursion以及：What is tail-recursion?为什么C语言同时保留‘goto’语句和‘while’，和尾递归有什么关系？尾递归是什么？尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。SICP中描述了一个内存占用曲线，用以上答案中的Python代码为例（普通递归）：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recsum</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">  <span class=\"keyword\">else</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> x + recsum(x - <span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p>当调用recsum(5)，Python调试器中发生如下状况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">recsum(5)</div><div class=\"line\">5 + recsum(4)</div><div class=\"line\">5 + (4 + recsum(3))</div><div class=\"line\">5 + (4 + (3 + recsum(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + recsum(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure></p>\n<h2 id=\"这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。\"><a href=\"#这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。\" class=\"headerlink\" title=\"这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。\"></a>这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。</h2><p>（一个替代方案：迭代）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">6</span>):</div><div class=\"line\">  sum += i</div></pre></td></tr></table></figure></p>\n<p>因为Python，Java，Pascal等等无法在语言中实现尾递归优化(Tail Call Optimization, TCO)，所以采用了for, while, goto等特殊结构代替recursive的表述。Scheme则不需要这样曲折地表达，一旦写成尾递归形式，就可以进行尾递归优化。———————Python中可以写（尾递归）：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tailrecsum</span><span class=\"params\">(x, running_total=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> running_total</div><div class=\"line\">  <span class=\"keyword\">else</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> tailrecsum(x - <span class=\"number\">1</span>, running_total + x)</div></pre></td></tr></table></figure></p>\n<p>理论上类似上面：<br>tailrecsum(5, 0)<br>tailrecsum(4, 5)<br>tailrecsum(3, 9)<br>tailrecsum(2, 12)<br>tailrecsum(1, 14)<br>tailrecsum(0, 15)<br>15<br>观察到，tailrecsum(x, y)中形式变量y的实际变量值是不断更新的，对比普通递归就很清楚，后者每个recsum()调用中y值不变，仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> tailrec(x+<span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>而<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> tailrec(x+<span class=\"number\">1</span>) + x;</div></pre></td></tr></table></figure></p>\n<p>则不可以。因为无法更新tailrec()函数内的实际变量，只是新建一个栈。但Python不能尾递归优化（Java不行，C可以，我不知道为什么），这里是用它做个例子。====================================如何优化尾递归：在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化<br>作者：匿名用户<br>链接：<a href=\"https://www.zhihu.com/question/20761771/answer/19996299\" target=\"_blank\" rel=\"external\">https://www.zhihu.com/question/20761771/answer/19996299</a><br>来源：知乎<br>最后对比一下没有用尾递归的阶乘代码和用了尾递归的阶乘代码：<br>用尾递归的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x,y)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> y</div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> fact(x<span class=\"number\">-1</span>,x*y)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">5</span>,<span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p>普通递归：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> x * fact(x<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">5</span>)</div></pre></td></tr></table></figure></p>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>用普通递归写的那个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。<br><img src=\"/images/algorithm/lyf.png\" alt=\"Alt text\"><br>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<h2 id=\"递归函数的改写\"><a href=\"#递归函数的改写\" class=\"headerlink\" title=\"递归函数的改写\"></a>递归函数的改写</h2><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？<br>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tailFactorial</span><span class=\"params\">(n, total)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) // <span class=\"number\">120</span></div></pre></td></tr></table></figure></p>\n<p>第二种方法就简单多了，就是采用函数默认值。(java中没有函数默认值)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n, total = <span class=\"number\">1</span>)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> n === <span class=\"number\">1</span> :</div><div class=\"line\">      <span class=\"keyword\">return</span> total</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total)</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) // <span class=\"number\">120</span></div></pre></td></tr></table></figure></p>\n<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>\n","excerpt":"","more":"<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”<br>我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。<br>假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。<br>祖母告诉你,钥匙很可能在下面这个盒子里。<br><img src=\"/images/algorithm/recursive1.png\" alt=\"Alt text\"><br>这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。<br>下面是一种方法。<br><img src=\"/images/algorithm/recursive2.png\" alt=\"Alt text\"><br>(1) 创建一个要查找的盒子堆。<br>(2) 从盒子堆取出一个盒子,在里面找。<br>(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!<br>(5) 回到第二步。<br>下面是另一种方法。<br><img src=\"/images/algorithm/recursive3.png\" alt=\"Alt text\"><br>(1) 检查盒子中的每样东西。<br>(2) 如果是盒子,就回到第一步。<br>(3) 如果是钥匙,就大功告成!<br>在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">look_for_key</span><span class=\"params\">(main_box)</span>:</span></div><div class=\"line\">    pile = main_box.make_a_pile_to_look_through()</div><div class=\"line\">    <span class=\"keyword\">while</span> pile <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> empty:</div><div class=\"line\">        box = pile.grab_a_box()</div><div class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> box:</div><div class=\"line\">            <span class=\"keyword\">if</span> item.is_a_box():</div><div class=\"line\">                pile.append(item)</div><div class=\"line\">            <span class=\"keyword\">elif</span> item.is_a_key():</div><div class=\"line\">                <span class=\"keyword\">print</span> <span class=\"string\">\"found the key!\"</span></div></pre></td></tr></table></figure></p>\n<p>第二种方法使用递归——函数调用自己,这种方法的伪代码如下。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">look_for_key</span><span class=\"params\">(box)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> box:</div><div class=\"line\">        <span class=\"keyword\">if</span> item.is_a_box():</div><div class=\"line\">            look_for_key(item) <span class=\"comment\"># 递归</span></div><div class=\"line\">        <span class=\"keyword\">elif</span> item.is_a_key():</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"found the key!\"</span></div></pre></td></tr></table></figure></p>\n<p>这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能<br> 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。</p>\n<h2 id=\"基线条件和递归条件\"><a href=\"#基线条件和递归条件\" class=\"headerlink\" title=\"基线条件和递归条件\"></a>基线条件和递归条件</h2><p> 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。<br> 如下：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recursive</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> n</div><div class=\"line\">\trecursive(n<span class=\"number\">-1</span>)</div><div class=\"line\"></div><div class=\"line\">recursive(<span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p> 会在console上打印：<br> <img src=\"/images/algorithm/recursive4.png\" alt=\"Alt text\"><br> 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。<br> 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。<br> 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。<br> 把上面的代码改一下，来给函数添加基线条件：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recursive</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> n</div><div class=\"line\">\t<span class=\"keyword\">if</span> n &lt;=<span class=\"number\">0</span> : <span class=\"comment\"># 基线条件</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span></div><div class=\"line\">\t<span class=\"keyword\">else</span> :     <span class=\"comment\"># 递归条件</span></div><div class=\"line\">\t\trecursive(n<span class=\"number\">-1</span>)</div><div class=\"line\"></div><div class=\"line\">recursive(<span class=\"number\">10</span>)</div></pre></td></tr></table></figure></p>\n<p> 输出结果：10到0<br><img src=\"/images/algorithm/recursive5.png\" alt=\"Alt text\"></p>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><p>接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。<br>栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet2</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"how are you, \"</span>+name + <span class=\"string\">\"!\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bye</span><span class=\"params\">()</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"ok bye!\"</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet</span><span class=\"params\">(name)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"hello, \"</span> + name +<span class=\"string\">\"!\"</span></div><div class=\"line\">\tgreet2(name)</div><div class=\"line\">\t<span class=\"keyword\">print</span> <span class=\"string\">\"getting ready to say bye...\"</span></div><div class=\"line\">\tbye()</div><div class=\"line\"></div><div class=\"line\">greet(<span class=\"string\">'jenius'</span>)</div></pre></td></tr></table></figure></p>\n<p>输出结果：<br>hello, jenius!<br>how are you, jenius!<br>getting ready to say bye…<br>ok bye!<br>这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。</p>\n<h2 id=\"递归调用栈\"><a href=\"#递归调用栈\" class=\"headerlink\" title=\"递归调用栈\"></a>递归调用栈</h2><p>递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其<br>定义如下:5! = 5 <em> 4 </em> 3 <em> 2 </em> 1。同理,factorial(3)为3 <em> 2 </em> 1。下面是计算阶乘的递归函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> x * fact(x<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">3</span>)</div></pre></td></tr></table></figure></p>\n<p><img src=\"/images/algorithm/recursive6.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/recursive7.png\" alt=\"Alt text\"><br> <strong>注意：</strong> 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。<br>栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。<br><img src=\"/images/algorithm/recursive8.png\" alt=\"Alt text\"><br><img src=\"/images/algorithm/recursive9.png\" alt=\"Alt text\"><br>使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。</p>\n<ul>\n<li><strong>1</strong> ：重新编写代码,转而使用循环。</li>\n<li><strong>2</strong> ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言<br>都支持尾递归。<h2 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h2>在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。<br>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：<br><em> <strong>调用自身函数(Self-called)；</strong>\n</em> <strong>计算仅占用常量栈空间(Stack Space)。</strong><br>而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。<br>由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除(Tail Call Elimination)或尾调用优化(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。<br>一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归取代循环而不丧失性能。<br>这个是维基百科给的一个定义。<br>我看别人的博客中<br>写到尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span> :</span></div><div class=\"line\">    <span class=\"keyword\">return</span> g(x)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。<br>以下两种情况，都不属于尾调用。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 情况一</div><div class=\"line\">def f1(x)&#123;</div><div class=\"line\">  int y = g(x)</div><div class=\"line\">  return y</div><div class=\"line\">&#125;</div><div class=\"line\"># 情况二</div><div class=\"line\">def f2(x)&#123;</div><div class=\"line\">  return g(x) + 1</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x &gt; <span class=\"number\">0</span> :</div><div class=\"line\">    <span class=\"keyword\">return</span> m(x)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> n(x)</div></pre></td></tr></table></figure></p>\n<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。<br>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。<br>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>\n<h2 id=\"尾递归\"><a href=\"#尾递归\" class=\"headerlink\" title=\"尾递归\"></a>尾递归</h2><p>虽然说算法图解说尾递归不在讨论范围之内，还是想深究一下。<br>我去知乎看了一下：<br>function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}</p>\n<p>作者：酿泉<br>链接：<a href=\"https://www.zhihu.com/question/20761771/answer/23254340\">https://www.zhihu.com/question/20761771/answer/23254340</a><br>来源：知乎<br>这个是点赞最高的179。<br>这个是第二164<br>参考我在Stackoverflow问的这个问题：Why does C preserves both goto and while, involving tail recursion以及：What is tail-recursion?为什么C语言同时保留‘goto’语句和‘while’，和尾递归有什么关系？尾递归是什么？尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。SICP中描述了一个内存占用曲线，用以上答案中的Python代码为例（普通递归）：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recsum</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> x</div><div class=\"line\">  <span class=\"keyword\">else</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> x + recsum(x - <span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p>当调用recsum(5)，Python调试器中发生如下状况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">recsum(5)</div><div class=\"line\">5 + recsum(4)</div><div class=\"line\">5 + (4 + recsum(3))</div><div class=\"line\">5 + (4 + (3 + recsum(2)))</div><div class=\"line\">5 + (4 + (3 + (2 + recsum(1))))</div><div class=\"line\">5 + (4 + (3 + (2 + 1)))</div><div class=\"line\">5 + (4 + (3 + 3))</div><div class=\"line\">5 + (4 + 6)</div><div class=\"line\">5 + 10</div><div class=\"line\">15</div></pre></td></tr></table></figure></p>\n<h2 id=\"这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。\"><a href=\"#这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。\" class=\"headerlink\" title=\"这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。\"></a>这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。</h2><p>（一个替代方案：迭代）<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">6</span>):</div><div class=\"line\">  sum += i</div></pre></td></tr></table></figure></p>\n<p>因为Python，Java，Pascal等等无法在语言中实现尾递归优化(Tail Call Optimization, TCO)，所以采用了for, while, goto等特殊结构代替recursive的表述。Scheme则不需要这样曲折地表达，一旦写成尾递归形式，就可以进行尾递归优化。———————Python中可以写（尾递归）：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tailrecsum</span><span class=\"params\">(x, running_total=<span class=\"number\">0</span>)</span>:</span></div><div class=\"line\">  <span class=\"keyword\">if</span> x == <span class=\"number\">0</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> running_total</div><div class=\"line\">  <span class=\"keyword\">else</span>:</div><div class=\"line\">    <span class=\"keyword\">return</span> tailrecsum(x - <span class=\"number\">1</span>, running_total + x)</div></pre></td></tr></table></figure></p>\n<p>理论上类似上面：<br>tailrecsum(5, 0)<br>tailrecsum(4, 5)<br>tailrecsum(3, 9)<br>tailrecsum(2, 12)<br>tailrecsum(1, 14)<br>tailrecsum(0, 15)<br>15<br>观察到，tailrecsum(x, y)中形式变量y的实际变量值是不断更新的，对比普通递归就很清楚，后者每个recsum()调用中y值不变，仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> tailrec(x+<span class=\"number\">1</span>);</div></pre></td></tr></table></figure></p>\n<p>而<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> tailrec(x+<span class=\"number\">1</span>) + x;</div></pre></td></tr></table></figure></p>\n<p>则不可以。因为无法更新tailrec()函数内的实际变量，只是新建一个栈。但Python不能尾递归优化（Java不行，C可以，我不知道为什么），这里是用它做个例子。====================================如何优化尾递归：在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化<br>作者：匿名用户<br>链接：<a href=\"https://www.zhihu.com/question/20761771/answer/19996299\">https://www.zhihu.com/question/20761771/answer/19996299</a><br>来源：知乎<br>最后对比一下没有用尾递归的阶乘代码和用了尾递归的阶乘代码：<br>用尾递归的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x,y)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> y</div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> fact(x<span class=\"number\">-1</span>,x*y)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">5</span>,<span class=\"number\">1</span>)</div></pre></td></tr></table></figure></p>\n<p>普通递归：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(x)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">\t<span class=\"keyword\">else</span>:</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> x * fact(x<span class=\"number\">-1</span>)</div><div class=\"line\"><span class=\"keyword\">print</span> fact(<span class=\"number\">5</span>)</div></pre></td></tr></table></figure></p>\n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>用普通递归写的那个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。<br><img src=\"/images/algorithm/lyf.png\" alt=\"Alt text\"><br>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>\n<h2 id=\"递归函数的改写\"><a href=\"#递归函数的改写\" class=\"headerlink\" title=\"递归函数的改写\"></a>递归函数的改写</h2><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？<br>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tailFactorial</span><span class=\"params\">(n, total)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n - <span class=\"number\">1</span>, n * total);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">return</span> tailFactorial(n, <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) // <span class=\"number\">120</span></div></pre></td></tr></table></figure></p>\n<p>第二种方法就简单多了，就是采用函数默认值。(java中没有函数默认值)<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n, total = <span class=\"number\">1</span>)</span> :</span></div><div class=\"line\">  <span class=\"keyword\">if</span> n === <span class=\"number\">1</span> :</div><div class=\"line\">      <span class=\"keyword\">return</span> total</div><div class=\"line\">  <span class=\"keyword\">return</span> factorial(n - <span class=\"number\">1</span>, n * total)</div><div class=\"line\"></div><div class=\"line\">factorial(<span class=\"number\">5</span>) // <span class=\"number\">120</span></div></pre></td></tr></table></figure></p>\n<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>\n"},{"title":"第二章创建和销毁对象","date":"2018-01-15T10:58:27.000Z","_content":"# 这段时间打算读java方面经典著作<<Effective Java>> 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\n## 第1条：考虑用静态工程方法代替构造器\n``` Java\npublic class MyObject {\n       private String objectId;\n       private MyObject(String objectId) {//私有构造器\n         this.objectId = objectId;\n       }\n\n       public static MyObject newInstance(String objectId){//静态工厂方法\n         return new MyObject(objectId);\n       }\n}\n\n```\n最好不用\n``` Java\npublic class MyObject {\n       private String objectId;\n       public MyObject(String objectId) {//共有构造器\n         this.objectId = objectId;\n       }\n}\n```\n### 静态工厂方法与构造器不同的第一大优势在于，它们有名称。\n构造器只有参数的个数和数目，对于每个构造器的含义模糊不清，使用静态工厂方法可以根据名称更好的确定其含义。\n``` Java\npublic class MyObject {\n\n    private static MyObject myObject = new MyObject();\n    public static MyObject newInstance() {\n        return myObject;\n    }\n}\n\n```\n### 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\n## 有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\n### 说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\n``` Java\npublic static void main(String[] args) {\n        Integer var1 = 128;\n        Integer var2 = 128;\n        // result true\n        System.out.println(var1.equals(var2));\n        // result false\n        System.out.println(var1 == var2);\n    }\n```\n果然，这个的确是个大坑。\n","source":"_posts/java/第二章创建和销毁对象.md","raw":"---\ntitle: 第二章创建和销毁对象\ndate: 2018-01-15 18:58:27\ntags:\ncategories: Java\n---\n# 这段时间打算读java方面经典著作<<Effective Java>> 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\n## 第1条：考虑用静态工程方法代替构造器\n``` Java\npublic class MyObject {\n       private String objectId;\n       private MyObject(String objectId) {//私有构造器\n         this.objectId = objectId;\n       }\n\n       public static MyObject newInstance(String objectId){//静态工厂方法\n         return new MyObject(objectId);\n       }\n}\n\n```\n最好不用\n``` Java\npublic class MyObject {\n       private String objectId;\n       public MyObject(String objectId) {//共有构造器\n         this.objectId = objectId;\n       }\n}\n```\n### 静态工厂方法与构造器不同的第一大优势在于，它们有名称。\n构造器只有参数的个数和数目，对于每个构造器的含义模糊不清，使用静态工厂方法可以根据名称更好的确定其含义。\n``` Java\npublic class MyObject {\n\n    private static MyObject myObject = new MyObject();\n    public static MyObject newInstance() {\n        return myObject;\n    }\n}\n\n```\n### 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\n## 有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\n### 说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\n``` Java\npublic static void main(String[] args) {\n        Integer var1 = 128;\n        Integer var2 = 128;\n        // result true\n        System.out.println(var1.equals(var2));\n        // result false\n        System.out.println(var1 == var2);\n    }\n```\n果然，这个的确是个大坑。\n","slug":"java/第二章创建和销毁对象","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6t30010hhu2pucbwgcx","content":"<h1 id=\"这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\"><a href=\"#这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\" class=\"headerlink\" title=\"这段时间打算读java方面经典著作&lt;&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\"></a>这段时间打算读java方面经典著作&lt;<effective java=\"\">&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。</effective></h1><h2 id=\"第1条：考虑用静态工程方法代替构造器\"><a href=\"#第1条：考虑用静态工程方法代替构造器\" class=\"headerlink\" title=\"第1条：考虑用静态工程方法代替构造器\"></a>第1条：考虑用静态工程方法代替构造器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">private</span> String objectId;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">MyObject</span><span class=\"params\">(String objectId)</span> </span>&#123;<span class=\"comment\">//私有构造器</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.objectId = objectId;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyObject <span class=\"title\">newInstance</span><span class=\"params\">(String objectId)</span></span>&#123;<span class=\"comment\">//静态工厂方法</span></div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyObject(objectId);</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最好不用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">private</span> String objectId;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyObject</span><span class=\"params\">(String objectId)</span> </span>&#123;<span class=\"comment\">//共有构造器</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.objectId = objectId;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"静态工厂方法与构造器不同的第一大优势在于，它们有名称。\"><a href=\"#静态工厂方法与构造器不同的第一大优势在于，它们有名称。\" class=\"headerlink\" title=\"静态工厂方法与构造器不同的第一大优势在于，它们有名称。\"></a>静态工厂方法与构造器不同的第一大优势在于，它们有名称。</h3><p>构造器只有参数的个数和数目，对于每个构造器的含义模糊不清，使用静态工厂方法可以根据名称更好的确定其含义。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MyObject myObject = <span class=\"keyword\">new</span> MyObject();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyObject <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> myObject;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\"><a href=\"#静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\" class=\"headerlink\" title=\"静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\"></a>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。</h3><h2 id=\"有一个小插曲我最近再看阿里巴巴Java开发手册Effective-CodingP15-7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\"><a href=\"#有一个小插曲我最近再看阿里巴巴Java开发手册Effective-CodingP15-7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\" class=\"headerlink\" title=\"有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\"></a>有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。</h2><h3 id=\"说明：对于Integer-var-在-128-127范围内的赋值，Integer对象是在IntegerCache-cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用-进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\"><a href=\"#说明：对于Integer-var-在-128-127范围内的赋值，Integer对象是在IntegerCache-cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用-进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\" class=\"headerlink\" title=\"说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\"></a>说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        Integer var1 = <span class=\"number\">128</span>;</div><div class=\"line\">        Integer var2 = <span class=\"number\">128</span>;</div><div class=\"line\">        <span class=\"comment\">// result true</span></div><div class=\"line\">        System.out.println(var1.equals(var2));</div><div class=\"line\">        <span class=\"comment\">// result false</span></div><div class=\"line\">        System.out.println(var1 == var2);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>果然，这个的确是个大坑。</p>\n","excerpt":"","more":"<h1 id=\"这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\"><a href=\"#这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\" class=\"headerlink\" title=\"这段时间打算读java方面经典著作&lt;&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。\"></a>这段时间打算读java方面经典著作&lt;<Effective Java>&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。</h1><h2 id=\"第1条：考虑用静态工程方法代替构造器\"><a href=\"#第1条：考虑用静态工程方法代替构造器\" class=\"headerlink\" title=\"第1条：考虑用静态工程方法代替构造器\"></a>第1条：考虑用静态工程方法代替构造器</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">private</span> String objectId;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">MyObject</span><span class=\"params\">(String objectId)</span> </span>&#123;<span class=\"comment\">//私有构造器</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.objectId = objectId;</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyObject <span class=\"title\">newInstance</span><span class=\"params\">(String objectId)</span></span>&#123;<span class=\"comment\">//静态工厂方法</span></div><div class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyObject(objectId);</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最好不用<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\">       <span class=\"keyword\">private</span> String objectId;</div><div class=\"line\">       <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyObject</span><span class=\"params\">(String objectId)</span> </span>&#123;<span class=\"comment\">//共有构造器</span></div><div class=\"line\">         <span class=\"keyword\">this</span>.objectId = objectId;</div><div class=\"line\">       &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"静态工厂方法与构造器不同的第一大优势在于，它们有名称。\"><a href=\"#静态工厂方法与构造器不同的第一大优势在于，它们有名称。\" class=\"headerlink\" title=\"静态工厂方法与构造器不同的第一大优势在于，它们有名称。\"></a>静态工厂方法与构造器不同的第一大优势在于，它们有名称。</h3><p>构造器只有参数的个数和数目，对于每个构造器的含义模糊不清，使用静态工厂方法可以根据名称更好的确定其含义。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> MyObject myObject = <span class=\"keyword\">new</span> MyObject();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> MyObject <span class=\"title\">newInstance</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> myObject;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\"><a href=\"#静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\" class=\"headerlink\" title=\"静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。\"></a>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。</h3><h2 id=\"有一个小插曲我最近再看阿里巴巴Java开发手册Effective-CodingP15-7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\"><a href=\"#有一个小插曲我最近再看阿里巴巴Java开发手册Effective-CodingP15-7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\" class=\"headerlink\" title=\"有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。\"></a>有一个小插曲我最近再看阿里巴巴Java开发手册Effective CodingP15 7【强制】所有相同类型的包装类对象之间值的对象之间的比较，全部使用equals方法。</h2><h3 id=\"说明：对于Integer-var-在-128-127范围内的赋值，Integer对象是在IntegerCache-cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用-进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\"><a href=\"#说明：对于Integer-var-在-128-127范围内的赋值，Integer对象是在IntegerCache-cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用-进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\" class=\"headerlink\" title=\"说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。\"></a>说明：对于Integer var = ? 在-128~127范围内的赋值，Integer对象是在IntegerCache.cache中产生的回复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间外的所有数据，都会在堆上产生，且不会复用已有对象。这是一个大坑，推荐适应equals方法进行判断。</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        Integer var1 = <span class=\"number\">128</span>;</div><div class=\"line\">        Integer var2 = <span class=\"number\">128</span>;</div><div class=\"line\">        <span class=\"comment\">// result true</span></div><div class=\"line\">        System.out.println(var1.equals(var2));</div><div class=\"line\">        <span class=\"comment\">// result false</span></div><div class=\"line\">        System.out.println(var1 == var2);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>果然，这个的确是个大坑。</p>\n"},{"title":"SSHClient","date":"2017-04-24T10:56:22.000Z","_content":"# SSHClient\n用于连接远程服务器并执行基本命令\n## 基于用户名密码连接：\n``` python\nimport paramiko\n\n# 创建SSH对象\nssh = paramiko.SSHClient()\n# 允许连接不在know_hosts文件中的主机\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n# 连接服务器\nssh.connect(hostname='10.10.39.213', port=22, username='username', password='password')\n\n# 执行命令\nstdin, stdout, stderr = ssh.exec_command('ls ./aa')\n# 获取命令结果\nresult = stdout.read()\nprint(result)\n# 关闭连接\nssh.close()\n```\n输出结果：\nb'redis-3.2.8\\nredis-3.2.8.tar.gz\\n'\n我用的是我们实验室里面的一台主机，\\n是换行。\n## Linux中ssh 第一次登陆某台主机的时候会出现：\n![Alt text](/images/python/ssh6.png)\n如果输入yes就会在,该用户的根目录下.ssh/known_hosts，这个文件中多了一条\n![Alt text](/images/python/ssh7.png)\n所以\n``` python  \nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n ```\n 这句话就是相当于把那个密钥加到.ssh/known_hosts 这里面\n顺便Linux之间可以用scp这个命令来上传下载文件。\n``` Linux\nscp -rp ssh.py ssh_oj@10.10.39.213:/tmp/\n```\n上面是带两个参数，第一个参数r，是指目录，就是它是个目录也可以copy。\n第二个参数是p，p是权限。就是说copy到另外一台主机之后，这个文件也会拥有在本机相同的权限。\nssh_oj指的是用户名，10.10.39.213是指主机的ip地址\n/tmp/ 是将文件copy到那个目录。\n结果:\n![Alt text](/images/python/ssh1.png)\n在登上该主机：\n![Alt text](/images/python/ssh2.png)\n有了这个文件\n如果ssh的默认端口号不是22，可以改端口号通过-P\n![Alt text](/images/python/ssh3.png)\n上面的端口是52113\n## 在SSHClient实现文件上长传下载\n``` python\nimport paramiko\n\ntransport = paramiko.Transport(('hostname',22))\ntransport.connect(username='username',password='password')\n\nsftp = paramiko.SFTPClient.from_transport(transport)\n# 将location.py 上传至服务器 /tmp/test.py\nsftp.put('/Volumes/ziyan/pythonworkspace/ssh.py', '/tmp/ssh.py')\n# 将remove_path 下载到本地 local_path\nsftp.get('remove_path', 'local_path')\n\ntransport.close()\n```\n结果：\n![Alt text](/images/python/ssh4.png)\n## 使用ssh公钥密钥自动登陆linux服务器\n```linux\n[root@server ~]# ssh-keygen -b 1024 -t rsa\nGenerating public/private rsa key pair.     #提示正在生成rsa密钥对\nEnter file in which to save the key (/home/usrname/.ssh/id_dsa):     #询问公钥和私钥存放的位置，回车用默认位置即可\nEnter passphrase (empty for no passphrase):     #询问输入私钥密语，输入密语\nEnter same passphrase again:     #再次提示输入密语确认\nYour identification has been saved in /home/usrname/.ssh/id_dsa.     #提示公钥和私钥已经存放在/root/.ssh/目录下\nYour public key has been saved in /home/usrname/.ssh/id_dsa.pub.\nThe key fingerprint is:\nx6:68:xx:93:98:8x:87:95:7x:2x:4x:x9:81:xx:56:94 root@server     #提示key的指纹\n```\n简单说明一下：\n-b 1024　采用长度为1024字节的公钥/私钥对，最长4096字节，一般1024或2048就足够满足安全需要了，太长的话加密解密需要的时间也增长。\n-t rsa　 采用rsa加密方式的公钥/私钥对，除了rsa还有dsa方式，rsa方式最短不能小于768字节长度。\n如果还需要使用更多其他参数请参考man ssh-keygen。\n         在生成密钥对的过程中你被询问：输入密码短句 Enter passphrase (empty for no passphrase) ，密码短句（passphrase）是你使用一个短语或者一句话作为密码输入，再由系统内部的加密或是散列算法生成虚拟密码后，进行下一步的认证。好处是增强了安全性不易被破解。看过很多文章，里面都把这个短句输入为空，也就是代表不使用密码短句。在这里我强烈要求你输入密码短句。有人会说使用密码短句后，登陆还要输入密码短句这样使用没有比使用用户名和密码登陆方便多少，我说请你不要急，接着看我的文章。\n### 注意：\n如果你生成密钥对而不设置密码短语，那么如果你的私钥丢失了，那么就你的麻烦可能会比丢失用户名密码还严重。\n第二步：拷贝你的公钥到被管理的服务器上\n在你的管理服务器上把你的公钥拷贝到被管理服务器上要进行自动登陆的用户目录下。\n```Linux\n[root@server ~]# scp .ssh/id_dsa.pub remote_usrname@192.168.0.2:      #比如你想使用用户peter登陆，则remote_usrname请以peter代替\n```\n改名和进行权限设置\n    登陆被管理的服务器，进入需要远程登陆的用户目录，把公钥放到用户目录的 .ssh 这个目录下（如果目录不存在，需要创建~/.ssh目录，并把目录权限设置为700），把公钥改名为authorized_keys2，并且把它的用户权限设成600。\n```Linux\n[peter@client ~]$ ls\nid_rsa.pub\n[peter@client ~]$ mkdir ~/.ssh     #如果当前用户目录下没有 .ssh 目录，请先创建目录\n[peter@client ~]$ chmod 700 ~/.ssh\n[peter@client ~]$ mv id_rsa.pub ~/.ssh\n[peter@client ~]$ cd ~/.ssh\n[peter@client ~]$ cat id_rsa.pub >> authorized_keys2\n[peter@client ~]$ rm -f id_rsa.pub\n[peter@client ~]$ chmod 600 authorized_keys2\n[peter@client ~]$ ls -l\ntotal 4\n-rw-------  1 peter peter 225 Oct 10 11:28 authorized_keys2\n```    \n测试使用密钥对进行远程登陆\n```Linux\n[root@server ~]# ssh peter@192.168.0.2\nEnter passphrase for key '/root/.ssh/id_rsa':      #提示输入密码短语，请输入刚才设置的密码短语\nLast login: Sun Oct 10 11:32:14 2010 from 192.168.0.1\n[peter@client ~]$\n```\n如果你不能用正确的登录，应该重新检查一下你的authorized_keys2的权限。也可能要检查.ssh目录的权限。\n使用 ssh-agent（ssh代理）自动输入密码短语\n牢记你的“密码短句”，现在你可以用你的密钥而不是密码来登录你的服务器了，但是这样仍然没有省什么事，你还是要输入密钥的“密码短语”。有更简便的方法吗？答案就是采用SSH代理（ssh-agent），一个用来帮你记住“密码短语”的程序。 ssh-agent是OpenSSH中默认包括的ssh代理程序。\n登陆管理服务器\n```Linux\n[root@server ~]# ssh-agent\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;\nSSH_AGENT_PID=2148; export SSH_AGENT_PID;\necho Agent pid 2148;\n```\n当你运行ssh-agent，它会打印出来它使用的 ssh 的环境和变量。要使用这些变量，有两种方法，一种是手动进行声明环境变量，另一种是运行eval命令自动声明环境变量。\n方法一：手动声明环境变量\n``` Linux\n[root@server ~]# SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;\n[root@server ~]# SSH_AGENT_PID=2148; export SSH_AGENT_PID;\n[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量\nSSH_AGENT_PID=2148\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147\n```\n方法二：运行eval命令自动声明环境变量\n``` Linux\n[root@server ~]# eval `ssh-agent`\nAgent pid 2157\n[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量\nSSH_AGENT_PID=2148\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147\n```\n现在 ssh-agent 已经在运行了，但是 ssh-agent 里面是空白的不会有解密的专用密钥。我们要告诉它我们有私钥和这个私钥在哪儿。这就需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。\n``` Linux\n[root@server ~]# ssh-add ~/.ssh/id_dsa\nEnter passphrase for /home/user/.ssh/id_dsa:     #输入你的密码短语\nIdentity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)\n[root@server ~]# ssh-add -l     #查看 ssh代理的缓存内容\n1024 72:78:5e:6b:16:fd:f2:8c:81:b1:18:e6:9f:77:6e:be /root/.ssh/id_rsa (RSA)\n```\n输入了密码短句，现在好了，你可以登录你的远程服务器而不用输入你的密码短语了，而且你的私钥是密码保护的。试试看是不是很爽！\n``` Linux\n\n[root@server ~]# ssh peter@192.168.0.2\nLast login: Sun Oct 10 11:32:45 2010 from 192.168.0.1\n[peter@client ~]$\n```\n登陆服务器进行操作结束后，记得还要把 ssh-agent 关掉，不然其他人登陆后也可以远程了。\n``` Linux\n[root@server ~]# ssh-agent -k\nunset SSH_AUTH_SOCK;\nunset SSH_AGENT_PID;\necho Agent pid 2148 killed;\n[root@server ~]# ssh-add -l     #查看一下，缓存里已经没有了密钥了\nThe agent has no identities.\n```\n## 基于公钥密钥连接：\n``` python\nimport paramiko\n\nprivate_key = paramiko.RSAKey.from_private_key_file('/Users/liyongjun/.ssh/id_rsa')\n\n# 创建SSH对象\nssh = paramiko.SSHClient()\n# 允许连接不在know_hosts文件中的主机\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n# 连接服务器\nssh.connect(hostname='hostname', port=22, username='username',pkey=private_key)\n# 执行命令\nstdin, stdout, stderr = ssh.exec_command('df')\n# 获取命令结果\nresult = stdout.read()\nprint(result.decode())\n# 关闭连接\nssh.close()\n```\n结果：\n文件系统           1K-块    已用      可用 已用% 挂载点\nudev             1006620       0   1006620    0% /dev\ntmpfs             204796    5264    199532    3% /run\n/dev/sda1      136750208 5922700 123857960    5% /\ntmpfs            1023964     148   1023816    1% /dev/shm\ntmpfs               5120       0      5120    0% /run/lock\ntmpfs            1023964       0   1023964    0% /sys/fs/cgroup\ncgmfs                100       0       100    0% /run/cgmanager/fs\ntmpfs             204796      28    204768    1% /run/user/119\ntmpfs             204796       0    204796    0% /run/user/1001\n## 基于公钥密钥上传下载\n``` python\nimport paramiko\n\nprivate_key = paramiko.RSAKey.from_private_key_file('/Users/liyongjun/.ssh/id_rsa')\n\ntransport = paramiko.Transport(('hostname', 22))\ntransport.connect(username='username', pkey=private_key )\n\nsftp = paramiko.SFTPClient.from_transport(transport)\n# 将location.py 上传至服务器 /tmp/test.py\nsftp.put('/Volumes/ziyan/pythonworkspace/ssh.py', '/tmp/test.py')\n# 将remove_path 下载到本地 local_path\n# sftp.get('remove_path', 'local_path')\n\ntransport.close()\n```\n结果：\n![Alt text](/images/python/ssh8.png)\n","source":"_posts/python/SSHClient.md","raw":"---\ntitle: SSHClient\ndate: 2017-04-24 18:56:22\ntags:\ncategories: python\n---\n# SSHClient\n用于连接远程服务器并执行基本命令\n## 基于用户名密码连接：\n``` python\nimport paramiko\n\n# 创建SSH对象\nssh = paramiko.SSHClient()\n# 允许连接不在know_hosts文件中的主机\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n# 连接服务器\nssh.connect(hostname='10.10.39.213', port=22, username='username', password='password')\n\n# 执行命令\nstdin, stdout, stderr = ssh.exec_command('ls ./aa')\n# 获取命令结果\nresult = stdout.read()\nprint(result)\n# 关闭连接\nssh.close()\n```\n输出结果：\nb'redis-3.2.8\\nredis-3.2.8.tar.gz\\n'\n我用的是我们实验室里面的一台主机，\\n是换行。\n## Linux中ssh 第一次登陆某台主机的时候会出现：\n![Alt text](/images/python/ssh6.png)\n如果输入yes就会在,该用户的根目录下.ssh/known_hosts，这个文件中多了一条\n![Alt text](/images/python/ssh7.png)\n所以\n``` python  \nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n ```\n 这句话就是相当于把那个密钥加到.ssh/known_hosts 这里面\n顺便Linux之间可以用scp这个命令来上传下载文件。\n``` Linux\nscp -rp ssh.py ssh_oj@10.10.39.213:/tmp/\n```\n上面是带两个参数，第一个参数r，是指目录，就是它是个目录也可以copy。\n第二个参数是p，p是权限。就是说copy到另外一台主机之后，这个文件也会拥有在本机相同的权限。\nssh_oj指的是用户名，10.10.39.213是指主机的ip地址\n/tmp/ 是将文件copy到那个目录。\n结果:\n![Alt text](/images/python/ssh1.png)\n在登上该主机：\n![Alt text](/images/python/ssh2.png)\n有了这个文件\n如果ssh的默认端口号不是22，可以改端口号通过-P\n![Alt text](/images/python/ssh3.png)\n上面的端口是52113\n## 在SSHClient实现文件上长传下载\n``` python\nimport paramiko\n\ntransport = paramiko.Transport(('hostname',22))\ntransport.connect(username='username',password='password')\n\nsftp = paramiko.SFTPClient.from_transport(transport)\n# 将location.py 上传至服务器 /tmp/test.py\nsftp.put('/Volumes/ziyan/pythonworkspace/ssh.py', '/tmp/ssh.py')\n# 将remove_path 下载到本地 local_path\nsftp.get('remove_path', 'local_path')\n\ntransport.close()\n```\n结果：\n![Alt text](/images/python/ssh4.png)\n## 使用ssh公钥密钥自动登陆linux服务器\n```linux\n[root@server ~]# ssh-keygen -b 1024 -t rsa\nGenerating public/private rsa key pair.     #提示正在生成rsa密钥对\nEnter file in which to save the key (/home/usrname/.ssh/id_dsa):     #询问公钥和私钥存放的位置，回车用默认位置即可\nEnter passphrase (empty for no passphrase):     #询问输入私钥密语，输入密语\nEnter same passphrase again:     #再次提示输入密语确认\nYour identification has been saved in /home/usrname/.ssh/id_dsa.     #提示公钥和私钥已经存放在/root/.ssh/目录下\nYour public key has been saved in /home/usrname/.ssh/id_dsa.pub.\nThe key fingerprint is:\nx6:68:xx:93:98:8x:87:95:7x:2x:4x:x9:81:xx:56:94 root@server     #提示key的指纹\n```\n简单说明一下：\n-b 1024　采用长度为1024字节的公钥/私钥对，最长4096字节，一般1024或2048就足够满足安全需要了，太长的话加密解密需要的时间也增长。\n-t rsa　 采用rsa加密方式的公钥/私钥对，除了rsa还有dsa方式，rsa方式最短不能小于768字节长度。\n如果还需要使用更多其他参数请参考man ssh-keygen。\n         在生成密钥对的过程中你被询问：输入密码短句 Enter passphrase (empty for no passphrase) ，密码短句（passphrase）是你使用一个短语或者一句话作为密码输入，再由系统内部的加密或是散列算法生成虚拟密码后，进行下一步的认证。好处是增强了安全性不易被破解。看过很多文章，里面都把这个短句输入为空，也就是代表不使用密码短句。在这里我强烈要求你输入密码短句。有人会说使用密码短句后，登陆还要输入密码短句这样使用没有比使用用户名和密码登陆方便多少，我说请你不要急，接着看我的文章。\n### 注意：\n如果你生成密钥对而不设置密码短语，那么如果你的私钥丢失了，那么就你的麻烦可能会比丢失用户名密码还严重。\n第二步：拷贝你的公钥到被管理的服务器上\n在你的管理服务器上把你的公钥拷贝到被管理服务器上要进行自动登陆的用户目录下。\n```Linux\n[root@server ~]# scp .ssh/id_dsa.pub remote_usrname@192.168.0.2:      #比如你想使用用户peter登陆，则remote_usrname请以peter代替\n```\n改名和进行权限设置\n    登陆被管理的服务器，进入需要远程登陆的用户目录，把公钥放到用户目录的 .ssh 这个目录下（如果目录不存在，需要创建~/.ssh目录，并把目录权限设置为700），把公钥改名为authorized_keys2，并且把它的用户权限设成600。\n```Linux\n[peter@client ~]$ ls\nid_rsa.pub\n[peter@client ~]$ mkdir ~/.ssh     #如果当前用户目录下没有 .ssh 目录，请先创建目录\n[peter@client ~]$ chmod 700 ~/.ssh\n[peter@client ~]$ mv id_rsa.pub ~/.ssh\n[peter@client ~]$ cd ~/.ssh\n[peter@client ~]$ cat id_rsa.pub >> authorized_keys2\n[peter@client ~]$ rm -f id_rsa.pub\n[peter@client ~]$ chmod 600 authorized_keys2\n[peter@client ~]$ ls -l\ntotal 4\n-rw-------  1 peter peter 225 Oct 10 11:28 authorized_keys2\n```    \n测试使用密钥对进行远程登陆\n```Linux\n[root@server ~]# ssh peter@192.168.0.2\nEnter passphrase for key '/root/.ssh/id_rsa':      #提示输入密码短语，请输入刚才设置的密码短语\nLast login: Sun Oct 10 11:32:14 2010 from 192.168.0.1\n[peter@client ~]$\n```\n如果你不能用正确的登录，应该重新检查一下你的authorized_keys2的权限。也可能要检查.ssh目录的权限。\n使用 ssh-agent（ssh代理）自动输入密码短语\n牢记你的“密码短句”，现在你可以用你的密钥而不是密码来登录你的服务器了，但是这样仍然没有省什么事，你还是要输入密钥的“密码短语”。有更简便的方法吗？答案就是采用SSH代理（ssh-agent），一个用来帮你记住“密码短语”的程序。 ssh-agent是OpenSSH中默认包括的ssh代理程序。\n登陆管理服务器\n```Linux\n[root@server ~]# ssh-agent\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;\nSSH_AGENT_PID=2148; export SSH_AGENT_PID;\necho Agent pid 2148;\n```\n当你运行ssh-agent，它会打印出来它使用的 ssh 的环境和变量。要使用这些变量，有两种方法，一种是手动进行声明环境变量，另一种是运行eval命令自动声明环境变量。\n方法一：手动声明环境变量\n``` Linux\n[root@server ~]# SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;\n[root@server ~]# SSH_AGENT_PID=2148; export SSH_AGENT_PID;\n[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量\nSSH_AGENT_PID=2148\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147\n```\n方法二：运行eval命令自动声明环境变量\n``` Linux\n[root@server ~]# eval `ssh-agent`\nAgent pid 2157\n[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量\nSSH_AGENT_PID=2148\nSSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147\n```\n现在 ssh-agent 已经在运行了，但是 ssh-agent 里面是空白的不会有解密的专用密钥。我们要告诉它我们有私钥和这个私钥在哪儿。这就需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。\n``` Linux\n[root@server ~]# ssh-add ~/.ssh/id_dsa\nEnter passphrase for /home/user/.ssh/id_dsa:     #输入你的密码短语\nIdentity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)\n[root@server ~]# ssh-add -l     #查看 ssh代理的缓存内容\n1024 72:78:5e:6b:16:fd:f2:8c:81:b1:18:e6:9f:77:6e:be /root/.ssh/id_rsa (RSA)\n```\n输入了密码短句，现在好了，你可以登录你的远程服务器而不用输入你的密码短语了，而且你的私钥是密码保护的。试试看是不是很爽！\n``` Linux\n\n[root@server ~]# ssh peter@192.168.0.2\nLast login: Sun Oct 10 11:32:45 2010 from 192.168.0.1\n[peter@client ~]$\n```\n登陆服务器进行操作结束后，记得还要把 ssh-agent 关掉，不然其他人登陆后也可以远程了。\n``` Linux\n[root@server ~]# ssh-agent -k\nunset SSH_AUTH_SOCK;\nunset SSH_AGENT_PID;\necho Agent pid 2148 killed;\n[root@server ~]# ssh-add -l     #查看一下，缓存里已经没有了密钥了\nThe agent has no identities.\n```\n## 基于公钥密钥连接：\n``` python\nimport paramiko\n\nprivate_key = paramiko.RSAKey.from_private_key_file('/Users/liyongjun/.ssh/id_rsa')\n\n# 创建SSH对象\nssh = paramiko.SSHClient()\n# 允许连接不在know_hosts文件中的主机\nssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n# 连接服务器\nssh.connect(hostname='hostname', port=22, username='username',pkey=private_key)\n# 执行命令\nstdin, stdout, stderr = ssh.exec_command('df')\n# 获取命令结果\nresult = stdout.read()\nprint(result.decode())\n# 关闭连接\nssh.close()\n```\n结果：\n文件系统           1K-块    已用      可用 已用% 挂载点\nudev             1006620       0   1006620    0% /dev\ntmpfs             204796    5264    199532    3% /run\n/dev/sda1      136750208 5922700 123857960    5% /\ntmpfs            1023964     148   1023816    1% /dev/shm\ntmpfs               5120       0      5120    0% /run/lock\ntmpfs            1023964       0   1023964    0% /sys/fs/cgroup\ncgmfs                100       0       100    0% /run/cgmanager/fs\ntmpfs             204796      28    204768    1% /run/user/119\ntmpfs             204796       0    204796    0% /run/user/1001\n## 基于公钥密钥上传下载\n``` python\nimport paramiko\n\nprivate_key = paramiko.RSAKey.from_private_key_file('/Users/liyongjun/.ssh/id_rsa')\n\ntransport = paramiko.Transport(('hostname', 22))\ntransport.connect(username='username', pkey=private_key )\n\nsftp = paramiko.SFTPClient.from_transport(transport)\n# 将location.py 上传至服务器 /tmp/test.py\nsftp.put('/Volumes/ziyan/pythonworkspace/ssh.py', '/tmp/test.py')\n# 将remove_path 下载到本地 local_path\n# sftp.get('remove_path', 'local_path')\n\ntransport.close()\n```\n结果：\n![Alt text](/images/python/ssh8.png)\n","slug":"python/SSHClient","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6t40012hhu2kcmtti7v","content":"<h1 id=\"SSHClient\"><a href=\"#SSHClient\" class=\"headerlink\" title=\"SSHClient\"></a>SSHClient</h1><p>用于连接远程服务器并执行基本命令</p>\n<h2 id=\"基于用户名密码连接：\"><a href=\"#基于用户名密码连接：\" class=\"headerlink\" title=\"基于用户名密码连接：\"></a>基于用户名密码连接：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建SSH对象</span></div><div class=\"line\">ssh = paramiko.SSHClient()</div><div class=\"line\"><span class=\"comment\"># 允许连接不在know_hosts文件中的主机</span></div><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class=\"line\"><span class=\"comment\"># 连接服务器</span></div><div class=\"line\">ssh.connect(hostname=<span class=\"string\">'10.10.39.213'</span>, port=<span class=\"number\">22</span>, username=<span class=\"string\">'username'</span>, password=<span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">stdin, stdout, stderr = ssh.exec_command(<span class=\"string\">'ls ./aa'</span>)</div><div class=\"line\"><span class=\"comment\"># 获取命令结果</span></div><div class=\"line\">result = stdout.read()</div><div class=\"line\">print(result)</div><div class=\"line\"><span class=\"comment\"># 关闭连接</span></div><div class=\"line\">ssh.close()</div></pre></td></tr></table></figure>\n<p>输出结果：<br>b’redis-3.2.8\\nredis-3.2.8.tar.gz\\n’<br>我用的是我们实验室里面的一台主机，\\n是换行。</p>\n<h2 id=\"Linux中ssh-第一次登陆某台主机的时候会出现：\"><a href=\"#Linux中ssh-第一次登陆某台主机的时候会出现：\" class=\"headerlink\" title=\"Linux中ssh 第一次登陆某台主机的时候会出现：\"></a>Linux中ssh 第一次登陆某台主机的时候会出现：</h2><p><img src=\"/images/python/ssh6.png\" alt=\"Alt text\"><br>如果输入yes就会在,该用户的根目录下.ssh/known_hosts，这个文件中多了一条<br><img src=\"/images/python/ssh7.png\" alt=\"Alt text\"><br>所以<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div></pre></td></tr></table></figure></p>\n<p> 这句话就是相当于把那个密钥加到.ssh/known_hosts 这里面<br>顺便Linux之间可以用scp这个命令来上传下载文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp -rp ssh.py ssh_oj@10.10.39.213:/tmp/</div></pre></td></tr></table></figure></p>\n<p>上面是带两个参数，第一个参数r，是指目录，就是它是个目录也可以copy。<br>第二个参数是p，p是权限。就是说copy到另外一台主机之后，这个文件也会拥有在本机相同的权限。<br>ssh_oj指的是用户名，10.10.39.213是指主机的ip地址<br>/tmp/ 是将文件copy到那个目录。<br>结果:<br><img src=\"/images/python/ssh1.png\" alt=\"Alt text\"><br>在登上该主机：<br><img src=\"/images/python/ssh2.png\" alt=\"Alt text\"><br>有了这个文件<br>如果ssh的默认端口号不是22，可以改端口号通过-P<br><img src=\"/images/python/ssh3.png\" alt=\"Alt text\"><br>上面的端口是52113</p>\n<h2 id=\"在SSHClient实现文件上长传下载\"><a href=\"#在SSHClient实现文件上长传下载\" class=\"headerlink\" title=\"在SSHClient实现文件上长传下载\"></a>在SSHClient实现文件上长传下载</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">transport = paramiko.Transport((<span class=\"string\">'hostname'</span>,<span class=\"number\">22</span>))</div><div class=\"line\">transport.connect(username=<span class=\"string\">'username'</span>,password=<span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class=\"line\"><span class=\"comment\"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class=\"line\">sftp.put(<span class=\"string\">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class=\"string\">'/tmp/ssh.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 将remove_path 下载到本地 local_path</span></div><div class=\"line\">sftp.get(<span class=\"string\">'remove_path'</span>, <span class=\"string\">'local_path'</span>)</div><div class=\"line\"></div><div class=\"line\">transport.close()</div></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"/images/python/ssh4.png\" alt=\"Alt text\"></p>\n<h2 id=\"使用ssh公钥密钥自动登陆linux服务器\"><a href=\"#使用ssh公钥密钥自动登陆linux服务器\" class=\"headerlink\" title=\"使用ssh公钥密钥自动登陆linux服务器\"></a>使用ssh公钥密钥自动登陆linux服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-keygen -b 1024 -t rsa</div><div class=\"line\">Generating public/private rsa key pair.     #提示正在生成rsa密钥对</div><div class=\"line\">Enter file in which to save the key (/home/usrname/.ssh/id_dsa):     #询问公钥和私钥存放的位置，回车用默认位置即可</div><div class=\"line\">Enter passphrase (empty for no passphrase):     #询问输入私钥密语，输入密语</div><div class=\"line\">Enter same passphrase again:     #再次提示输入密语确认</div><div class=\"line\">Your identification has been saved in /home/usrname/.ssh/id_dsa.     #提示公钥和私钥已经存放在/root/.ssh/目录下</div><div class=\"line\">Your public key has been saved in /home/usrname/.ssh/id_dsa.pub.</div><div class=\"line\">The key fingerprint is:</div><div class=\"line\">x6:68:xx:93:98:8x:87:95:7x:2x:4x:x9:81:xx:56:94 root@server     #提示key的指纹</div></pre></td></tr></table></figure>\n<p>简单说明一下：<br>-b 1024　采用长度为1024字节的公钥/私钥对，最长4096字节，一般1024或2048就足够满足安全需要了，太长的话加密解密需要的时间也增长。<br>-t rsa　 采用rsa加密方式的公钥/私钥对，除了rsa还有dsa方式，rsa方式最短不能小于768字节长度。<br>如果还需要使用更多其他参数请参考man ssh-keygen。<br>         在生成密钥对的过程中你被询问：输入密码短句 Enter passphrase (empty for no passphrase) ，密码短句（passphrase）是你使用一个短语或者一句话作为密码输入，再由系统内部的加密或是散列算法生成虚拟密码后，进行下一步的认证。好处是增强了安全性不易被破解。看过很多文章，里面都把这个短句输入为空，也就是代表不使用密码短句。在这里我强烈要求你输入密码短句。有人会说使用密码短句后，登陆还要输入密码短句这样使用没有比使用用户名和密码登陆方便多少，我说请你不要急，接着看我的文章。</p>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>如果你生成密钥对而不设置密码短语，那么如果你的私钥丢失了，那么就你的麻烦可能会比丢失用户名密码还严重。<br>第二步：拷贝你的公钥到被管理的服务器上<br>在你的管理服务器上把你的公钥拷贝到被管理服务器上要进行自动登陆的用户目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# scp .ssh/id_dsa.pub remote_usrname@192.168.0.2:      #比如你想使用用户peter登陆，则remote_usrname请以peter代替</div></pre></td></tr></table></figure></p>\n<p>改名和进行权限设置<br>    登陆被管理的服务器，进入需要远程登陆的用户目录，把公钥放到用户目录的 .ssh 这个目录下（如果目录不存在，需要创建~/.ssh目录，并把目录权限设置为700），把公钥改名为authorized_keys2，并且把它的用户权限设成600。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">[peter@client ~]$ ls</div><div class=\"line\">id_rsa.pub</div><div class=\"line\">[peter@client ~]$ mkdir ~/.ssh     #如果当前用户目录下没有 .ssh 目录，请先创建目录</div><div class=\"line\">[peter@client ~]$ chmod 700 ~/.ssh</div><div class=\"line\">[peter@client ~]$ mv id_rsa.pub ~/.ssh</div><div class=\"line\">[peter@client ~]$ cd ~/.ssh</div><div class=\"line\">[peter@client ~]$ cat id_rsa.pub &gt;&gt; authorized_keys2</div><div class=\"line\">[peter@client ~]$ rm -f id_rsa.pub</div><div class=\"line\">[peter@client ~]$ chmod 600 authorized_keys2</div><div class=\"line\">[peter@client ~]$ ls -l</div><div class=\"line\">total 4</div><div class=\"line\">-rw-------  1 peter peter 225 Oct 10 11:28 authorized_keys2</div><div class=\"line\">```    </div><div class=\"line\">测试使用密钥对进行远程登陆</div><div class=\"line\">```Linux</div><div class=\"line\">[root@server ~]# ssh peter@192.168.0.2</div><div class=\"line\">Enter passphrase for key &apos;/root/.ssh/id_rsa&apos;:      #提示输入密码短语，请输入刚才设置的密码短语</div><div class=\"line\">Last login: Sun Oct 10 11:32:14 2010 from 192.168.0.1</div><div class=\"line\">[peter@client ~]$</div></pre></td></tr></table></figure></p>\n<p>如果你不能用正确的登录，应该重新检查一下你的authorized_keys2的权限。也可能要检查.ssh目录的权限。<br>使用 ssh-agent（ssh代理）自动输入密码短语<br>牢记你的“密码短句”，现在你可以用你的密钥而不是密码来登录你的服务器了，但是这样仍然没有省什么事，你还是要输入密钥的“密码短语”。有更简便的方法吗？答案就是采用SSH代理（ssh-agent），一个用来帮你记住“密码短语”的程序。 ssh-agent是OpenSSH中默认包括的ssh代理程序。<br>登陆管理服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-agent</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class=\"line\">SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class=\"line\">echo Agent pid 2148;</div></pre></td></tr></table></figure></p>\n<p>当你运行ssh-agent，它会打印出来它使用的 ssh 的环境和变量。要使用这些变量，有两种方法，一种是手动进行声明环境变量，另一种是运行eval命令自动声明环境变量。<br>方法一：手动声明环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class=\"line\">[root@server ~]# SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class=\"line\">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class=\"line\">SSH_AGENT_PID=2148</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>\n<p>方法二：运行eval命令自动声明环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# eval `ssh-agent`</div><div class=\"line\">Agent pid 2157</div><div class=\"line\">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class=\"line\">SSH_AGENT_PID=2148</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>\n<p>现在 ssh-agent 已经在运行了，但是 ssh-agent 里面是空白的不会有解密的专用密钥。我们要告诉它我们有私钥和这个私钥在哪儿。这就需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-add ~/.ssh/id_dsa</div><div class=\"line\">Enter passphrase for /home/user/.ssh/id_dsa:     #输入你的密码短语</div><div class=\"line\">Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)</div><div class=\"line\">[root@server ~]# ssh-add -l     #查看 ssh代理的缓存内容</div><div class=\"line\">1024 72:78:5e:6b:16:fd:f2:8c:81:b1:18:e6:9f:77:6e:be /root/.ssh/id_rsa (RSA)</div></pre></td></tr></table></figure></p>\n<p>输入了密码短句，现在好了，你可以登录你的远程服务器而不用输入你的密码短语了，而且你的私钥是密码保护的。试试看是不是很爽！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[root@server ~]# ssh peter@192.168.0.2</div><div class=\"line\">Last login: Sun Oct 10 11:32:45 2010 from 192.168.0.1</div><div class=\"line\">[peter@client ~]$</div></pre></td></tr></table></figure></p>\n<p>登陆服务器进行操作结束后，记得还要把 ssh-agent 关掉，不然其他人登陆后也可以远程了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-agent -k</div><div class=\"line\">unset SSH_AUTH_SOCK;</div><div class=\"line\">unset SSH_AGENT_PID;</div><div class=\"line\">echo Agent pid 2148 killed;</div><div class=\"line\">[root@server ~]# ssh-add -l     #查看一下，缓存里已经没有了密钥了</div><div class=\"line\">The agent has no identities.</div></pre></td></tr></table></figure></p>\n<h2 id=\"基于公钥密钥连接：\"><a href=\"#基于公钥密钥连接：\" class=\"headerlink\" title=\"基于公钥密钥连接：\"></a>基于公钥密钥连接：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">private_key = paramiko.RSAKey.from_private_key_file(<span class=\"string\">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建SSH对象</span></div><div class=\"line\">ssh = paramiko.SSHClient()</div><div class=\"line\"><span class=\"comment\"># 允许连接不在know_hosts文件中的主机</span></div><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class=\"line\"><span class=\"comment\"># 连接服务器</span></div><div class=\"line\">ssh.connect(hostname=<span class=\"string\">'hostname'</span>, port=<span class=\"number\">22</span>, username=<span class=\"string\">'username'</span>,pkey=private_key)</div><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">stdin, stdout, stderr = ssh.exec_command(<span class=\"string\">'df'</span>)</div><div class=\"line\"><span class=\"comment\"># 获取命令结果</span></div><div class=\"line\">result = stdout.read()</div><div class=\"line\">print(result.decode())</div><div class=\"line\"><span class=\"comment\"># 关闭连接</span></div><div class=\"line\">ssh.close()</div></pre></td></tr></table></figure>\n<p>结果：<br>文件系统           1K-块    已用      可用 已用% 挂载点<br>udev             1006620       0   1006620    0% /dev<br>tmpfs             204796    5264    199532    3% /run<br>/dev/sda1      136750208 5922700 123857960    5% /<br>tmpfs            1023964     148   1023816    1% /dev/shm<br>tmpfs               5120       0      5120    0% /run/lock<br>tmpfs            1023964       0   1023964    0% /sys/fs/cgroup<br>cgmfs                100       0       100    0% /run/cgmanager/fs<br>tmpfs             204796      28    204768    1% /run/user/119<br>tmpfs             204796       0    204796    0% /run/user/1001</p>\n<h2 id=\"基于公钥密钥上传下载\"><a href=\"#基于公钥密钥上传下载\" class=\"headerlink\" title=\"基于公钥密钥上传下载\"></a>基于公钥密钥上传下载</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">private_key = paramiko.RSAKey.from_private_key_file(<span class=\"string\">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class=\"line\"></div><div class=\"line\">transport = paramiko.Transport((<span class=\"string\">'hostname'</span>, <span class=\"number\">22</span>))</div><div class=\"line\">transport.connect(username=<span class=\"string\">'username'</span>, pkey=private_key )</div><div class=\"line\"></div><div class=\"line\">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class=\"line\"><span class=\"comment\"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class=\"line\">sftp.put(<span class=\"string\">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class=\"string\">'/tmp/test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 将remove_path 下载到本地 local_path</span></div><div class=\"line\"><span class=\"comment\"># sftp.get('remove_path', 'local_path')</span></div><div class=\"line\"></div><div class=\"line\">transport.close()</div></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"/images/python/ssh8.png\" alt=\"Alt text\"></p>\n","excerpt":"","more":"<h1 id=\"SSHClient\"><a href=\"#SSHClient\" class=\"headerlink\" title=\"SSHClient\"></a>SSHClient</h1><p>用于连接远程服务器并执行基本命令</p>\n<h2 id=\"基于用户名密码连接：\"><a href=\"#基于用户名密码连接：\" class=\"headerlink\" title=\"基于用户名密码连接：\"></a>基于用户名密码连接：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建SSH对象</span></div><div class=\"line\">ssh = paramiko.SSHClient()</div><div class=\"line\"><span class=\"comment\"># 允许连接不在know_hosts文件中的主机</span></div><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class=\"line\"><span class=\"comment\"># 连接服务器</span></div><div class=\"line\">ssh.connect(hostname=<span class=\"string\">'10.10.39.213'</span>, port=<span class=\"number\">22</span>, username=<span class=\"string\">'username'</span>, password=<span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">stdin, stdout, stderr = ssh.exec_command(<span class=\"string\">'ls ./aa'</span>)</div><div class=\"line\"><span class=\"comment\"># 获取命令结果</span></div><div class=\"line\">result = stdout.read()</div><div class=\"line\">print(result)</div><div class=\"line\"><span class=\"comment\"># 关闭连接</span></div><div class=\"line\">ssh.close()</div></pre></td></tr></table></figure>\n<p>输出结果：<br>b’redis-3.2.8\\nredis-3.2.8.tar.gz\\n’<br>我用的是我们实验室里面的一台主机，\\n是换行。</p>\n<h2 id=\"Linux中ssh-第一次登陆某台主机的时候会出现：\"><a href=\"#Linux中ssh-第一次登陆某台主机的时候会出现：\" class=\"headerlink\" title=\"Linux中ssh 第一次登陆某台主机的时候会出现：\"></a>Linux中ssh 第一次登陆某台主机的时候会出现：</h2><p><img src=\"/images/python/ssh6.png\" alt=\"Alt text\"><br>如果输入yes就会在,该用户的根目录下.ssh/known_hosts，这个文件中多了一条<br><img src=\"/images/python/ssh7.png\" alt=\"Alt text\"><br>所以<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div></pre></td></tr></table></figure></p>\n<p> 这句话就是相当于把那个密钥加到.ssh/known_hosts 这里面<br>顺便Linux之间可以用scp这个命令来上传下载文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">scp -rp ssh.py ssh_oj@10.10.39.213:/tmp/</div></pre></td></tr></table></figure></p>\n<p>上面是带两个参数，第一个参数r，是指目录，就是它是个目录也可以copy。<br>第二个参数是p，p是权限。就是说copy到另外一台主机之后，这个文件也会拥有在本机相同的权限。<br>ssh_oj指的是用户名，10.10.39.213是指主机的ip地址<br>/tmp/ 是将文件copy到那个目录。<br>结果:<br><img src=\"/images/python/ssh1.png\" alt=\"Alt text\"><br>在登上该主机：<br><img src=\"/images/python/ssh2.png\" alt=\"Alt text\"><br>有了这个文件<br>如果ssh的默认端口号不是22，可以改端口号通过-P<br><img src=\"/images/python/ssh3.png\" alt=\"Alt text\"><br>上面的端口是52113</p>\n<h2 id=\"在SSHClient实现文件上长传下载\"><a href=\"#在SSHClient实现文件上长传下载\" class=\"headerlink\" title=\"在SSHClient实现文件上长传下载\"></a>在SSHClient实现文件上长传下载</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">transport = paramiko.Transport((<span class=\"string\">'hostname'</span>,<span class=\"number\">22</span>))</div><div class=\"line\">transport.connect(username=<span class=\"string\">'username'</span>,password=<span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class=\"line\"><span class=\"comment\"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class=\"line\">sftp.put(<span class=\"string\">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class=\"string\">'/tmp/ssh.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 将remove_path 下载到本地 local_path</span></div><div class=\"line\">sftp.get(<span class=\"string\">'remove_path'</span>, <span class=\"string\">'local_path'</span>)</div><div class=\"line\"></div><div class=\"line\">transport.close()</div></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"/images/python/ssh4.png\" alt=\"Alt text\"></p>\n<h2 id=\"使用ssh公钥密钥自动登陆linux服务器\"><a href=\"#使用ssh公钥密钥自动登陆linux服务器\" class=\"headerlink\" title=\"使用ssh公钥密钥自动登陆linux服务器\"></a>使用ssh公钥密钥自动登陆linux服务器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-keygen -b 1024 -t rsa</div><div class=\"line\">Generating public/private rsa key pair.     #提示正在生成rsa密钥对</div><div class=\"line\">Enter file in which to save the key (/home/usrname/.ssh/id_dsa):     #询问公钥和私钥存放的位置，回车用默认位置即可</div><div class=\"line\">Enter passphrase (empty for no passphrase):     #询问输入私钥密语，输入密语</div><div class=\"line\">Enter same passphrase again:     #再次提示输入密语确认</div><div class=\"line\">Your identification has been saved in /home/usrname/.ssh/id_dsa.     #提示公钥和私钥已经存放在/root/.ssh/目录下</div><div class=\"line\">Your public key has been saved in /home/usrname/.ssh/id_dsa.pub.</div><div class=\"line\">The key fingerprint is:</div><div class=\"line\">x6:68:xx:93:98:8x:87:95:7x:2x:4x:x9:81:xx:56:94 root@server     #提示key的指纹</div></pre></td></tr></table></figure>\n<p>简单说明一下：<br>-b 1024　采用长度为1024字节的公钥/私钥对，最长4096字节，一般1024或2048就足够满足安全需要了，太长的话加密解密需要的时间也增长。<br>-t rsa　 采用rsa加密方式的公钥/私钥对，除了rsa还有dsa方式，rsa方式最短不能小于768字节长度。<br>如果还需要使用更多其他参数请参考man ssh-keygen。<br>         在生成密钥对的过程中你被询问：输入密码短句 Enter passphrase (empty for no passphrase) ，密码短句（passphrase）是你使用一个短语或者一句话作为密码输入，再由系统内部的加密或是散列算法生成虚拟密码后，进行下一步的认证。好处是增强了安全性不易被破解。看过很多文章，里面都把这个短句输入为空，也就是代表不使用密码短句。在这里我强烈要求你输入密码短句。有人会说使用密码短句后，登陆还要输入密码短句这样使用没有比使用用户名和密码登陆方便多少，我说请你不要急，接着看我的文章。</p>\n<h3 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h3><p>如果你生成密钥对而不设置密码短语，那么如果你的私钥丢失了，那么就你的麻烦可能会比丢失用户名密码还严重。<br>第二步：拷贝你的公钥到被管理的服务器上<br>在你的管理服务器上把你的公钥拷贝到被管理服务器上要进行自动登陆的用户目录下。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# scp .ssh/id_dsa.pub remote_usrname@192.168.0.2:      #比如你想使用用户peter登陆，则remote_usrname请以peter代替</div></pre></td></tr></table></figure></p>\n<p>改名和进行权限设置<br>    登陆被管理的服务器，进入需要远程登陆的用户目录，把公钥放到用户目录的 .ssh 这个目录下（如果目录不存在，需要创建~/.ssh目录，并把目录权限设置为700），把公钥改名为authorized_keys2，并且把它的用户权限设成600。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">[peter@client ~]$ ls</div><div class=\"line\">id_rsa.pub</div><div class=\"line\">[peter@client ~]$ mkdir ~/.ssh     #如果当前用户目录下没有 .ssh 目录，请先创建目录</div><div class=\"line\">[peter@client ~]$ chmod 700 ~/.ssh</div><div class=\"line\">[peter@client ~]$ mv id_rsa.pub ~/.ssh</div><div class=\"line\">[peter@client ~]$ cd ~/.ssh</div><div class=\"line\">[peter@client ~]$ cat id_rsa.pub &gt;&gt; authorized_keys2</div><div class=\"line\">[peter@client ~]$ rm -f id_rsa.pub</div><div class=\"line\">[peter@client ~]$ chmod 600 authorized_keys2</div><div class=\"line\">[peter@client ~]$ ls -l</div><div class=\"line\">total 4</div><div class=\"line\">-rw-------  1 peter peter 225 Oct 10 11:28 authorized_keys2</div><div class=\"line\">```    </div><div class=\"line\">测试使用密钥对进行远程登陆</div><div class=\"line\">```Linux</div><div class=\"line\">[root@server ~]# ssh peter@192.168.0.2</div><div class=\"line\">Enter passphrase for key &apos;/root/.ssh/id_rsa&apos;:      #提示输入密码短语，请输入刚才设置的密码短语</div><div class=\"line\">Last login: Sun Oct 10 11:32:14 2010 from 192.168.0.1</div><div class=\"line\">[peter@client ~]$</div></pre></td></tr></table></figure></p>\n<p>如果你不能用正确的登录，应该重新检查一下你的authorized_keys2的权限。也可能要检查.ssh目录的权限。<br>使用 ssh-agent（ssh代理）自动输入密码短语<br>牢记你的“密码短句”，现在你可以用你的密钥而不是密码来登录你的服务器了，但是这样仍然没有省什么事，你还是要输入密钥的“密码短语”。有更简便的方法吗？答案就是采用SSH代理（ssh-agent），一个用来帮你记住“密码短语”的程序。 ssh-agent是OpenSSH中默认包括的ssh代理程序。<br>登陆管理服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-agent</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class=\"line\">SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class=\"line\">echo Agent pid 2148;</div></pre></td></tr></table></figure></p>\n<p>当你运行ssh-agent，它会打印出来它使用的 ssh 的环境和变量。要使用这些变量，有两种方法，一种是手动进行声明环境变量，另一种是运行eval命令自动声明环境变量。<br>方法一：手动声明环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class=\"line\">[root@server ~]# SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class=\"line\">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class=\"line\">SSH_AGENT_PID=2148</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>\n<p>方法二：运行eval命令自动声明环境变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# eval `ssh-agent`</div><div class=\"line\">Agent pid 2157</div><div class=\"line\">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class=\"line\">SSH_AGENT_PID=2148</div><div class=\"line\">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>\n<p>现在 ssh-agent 已经在运行了，但是 ssh-agent 里面是空白的不会有解密的专用密钥。我们要告诉它我们有私钥和这个私钥在哪儿。这就需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-add ~/.ssh/id_dsa</div><div class=\"line\">Enter passphrase for /home/user/.ssh/id_dsa:     #输入你的密码短语</div><div class=\"line\">Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)</div><div class=\"line\">[root@server ~]# ssh-add -l     #查看 ssh代理的缓存内容</div><div class=\"line\">1024 72:78:5e:6b:16:fd:f2:8c:81:b1:18:e6:9f:77:6e:be /root/.ssh/id_rsa (RSA)</div></pre></td></tr></table></figure></p>\n<p>输入了密码短句，现在好了，你可以登录你的远程服务器而不用输入你的密码短语了，而且你的私钥是密码保护的。试试看是不是很爽！<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">[root@server ~]# ssh peter@192.168.0.2</div><div class=\"line\">Last login: Sun Oct 10 11:32:45 2010 from 192.168.0.1</div><div class=\"line\">[peter@client ~]$</div></pre></td></tr></table></figure></p>\n<p>登陆服务器进行操作结束后，记得还要把 ssh-agent 关掉，不然其他人登陆后也可以远程了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@server ~]# ssh-agent -k</div><div class=\"line\">unset SSH_AUTH_SOCK;</div><div class=\"line\">unset SSH_AGENT_PID;</div><div class=\"line\">echo Agent pid 2148 killed;</div><div class=\"line\">[root@server ~]# ssh-add -l     #查看一下，缓存里已经没有了密钥了</div><div class=\"line\">The agent has no identities.</div></pre></td></tr></table></figure></p>\n<h2 id=\"基于公钥密钥连接：\"><a href=\"#基于公钥密钥连接：\" class=\"headerlink\" title=\"基于公钥密钥连接：\"></a>基于公钥密钥连接：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">private_key = paramiko.RSAKey.from_private_key_file(<span class=\"string\">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 创建SSH对象</span></div><div class=\"line\">ssh = paramiko.SSHClient()</div><div class=\"line\"><span class=\"comment\"># 允许连接不在know_hosts文件中的主机</span></div><div class=\"line\">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class=\"line\"><span class=\"comment\"># 连接服务器</span></div><div class=\"line\">ssh.connect(hostname=<span class=\"string\">'hostname'</span>, port=<span class=\"number\">22</span>, username=<span class=\"string\">'username'</span>,pkey=private_key)</div><div class=\"line\"><span class=\"comment\"># 执行命令</span></div><div class=\"line\">stdin, stdout, stderr = ssh.exec_command(<span class=\"string\">'df'</span>)</div><div class=\"line\"><span class=\"comment\"># 获取命令结果</span></div><div class=\"line\">result = stdout.read()</div><div class=\"line\">print(result.decode())</div><div class=\"line\"><span class=\"comment\"># 关闭连接</span></div><div class=\"line\">ssh.close()</div></pre></td></tr></table></figure>\n<p>结果：<br>文件系统           1K-块    已用      可用 已用% 挂载点<br>udev             1006620       0   1006620    0% /dev<br>tmpfs             204796    5264    199532    3% /run<br>/dev/sda1      136750208 5922700 123857960    5% /<br>tmpfs            1023964     148   1023816    1% /dev/shm<br>tmpfs               5120       0      5120    0% /run/lock<br>tmpfs            1023964       0   1023964    0% /sys/fs/cgroup<br>cgmfs                100       0       100    0% /run/cgmanager/fs<br>tmpfs             204796      28    204768    1% /run/user/119<br>tmpfs             204796       0    204796    0% /run/user/1001</p>\n<h2 id=\"基于公钥密钥上传下载\"><a href=\"#基于公钥密钥上传下载\" class=\"headerlink\" title=\"基于公钥密钥上传下载\"></a>基于公钥密钥上传下载</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> paramiko</div><div class=\"line\"></div><div class=\"line\">private_key = paramiko.RSAKey.from_private_key_file(<span class=\"string\">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class=\"line\"></div><div class=\"line\">transport = paramiko.Transport((<span class=\"string\">'hostname'</span>, <span class=\"number\">22</span>))</div><div class=\"line\">transport.connect(username=<span class=\"string\">'username'</span>, pkey=private_key )</div><div class=\"line\"></div><div class=\"line\">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class=\"line\"><span class=\"comment\"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class=\"line\">sftp.put(<span class=\"string\">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class=\"string\">'/tmp/test.py'</span>)</div><div class=\"line\"><span class=\"comment\"># 将remove_path 下载到本地 local_path</span></div><div class=\"line\"><span class=\"comment\"># sftp.get('remove_path', 'local_path')</span></div><div class=\"line\"></div><div class=\"line\">transport.close()</div></pre></td></tr></table></figure>\n<p>结果：<br><img src=\"/images/python/ssh8.png\" alt=\"Alt text\"></p>\n"},{"title":"python的多继承","date":"2017-04-21T08:35:44.000Z","_content":"# 二义性\npython支持多继承，多继承的语言往往会遇到以下两类二义性的问题：\n有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。\n有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。\nC++也是支持多继承的语言之一\n对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。\n对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。\n## Python中多继承与super()用法\nPython类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。\n\n考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。\n``` python\n# 经典类\nclass A():\n    def __init__(self):\n        print 'A'\n\nclass B(A):\n    def __init__(self):\n        A.__init__(self)\n        print 'B'\n\nclass C(B, A):\n    def __init__(self):\n        A.__init__(self)\n        B.__init__(self)\n        print 'C'\n```\n采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。\n``` python\n# 新式类\nclass A(object):\n    def __init__(self):\n        print 'A'\n\nclass B(A):\n    def __init__(self):\n        super(B, self).__init__()\n        print 'B'\n\nclass C(B, A):\n    def __init__(self):\n        super(C, self).__init__()\n        print 'C'\n```\n采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。\n``` python\n#coding=utf-8\nclass A(object):\n\tname = 'A'\n\tdef __init__(self):\n\t\tprint 'This is a A‘s construct'\n\nclass B(A):\n\tname = 'B'\n\tdef __init__(self):\n\t\tsuper(B,self).__init__()\n\t\tprint 'This is a B‘s construct'\nclass C(A,B):\n\tname = 'C'\n\tdef __init__(self):\n\t\tsuper(C, self).__init__()\n\t\t# B.__init__(self)\n\t\tprint 'This is a C‘s construct'\n\nc = C()\n```\n结果:\n![Alt text](/images/result.jpeg)\n仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。\n``` python\n#coding=utf-8\nclass A(object):\n\tpass\n\nclass B(object):\n\tname = 'B'\n\tdef __init__(self):\n\t\tprint('This is a B‘s constructor')\nclass C(A,B):\n\tname = 'C'\n\tdef __init__(self):\n\t\tsuper(C, self).__init__()   # 如果A没有复写构造方法，\n\t\t# super会调用继承顺序从左到右第一个复写构造方法的父类\n\t\t# B.__init__(self)\n\t\tprint('This is a C‘s constructor')\n\nc = C()\n\n```\n### 注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\n\npython中通过C3算法很好的避免了以上两类二义性的情况。\n## 深度优先算法（DFS，Depth-First-Search）\n把根节点压入栈中。\n每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。\n找到所要找的元素时结束程序。\n如果遍历整个树还没有找到，结束程序。\n### 注意\npython2 里如果用的经典类 是使用的 深度优选\npython2 里如果用的新式类 是使用的 广度优选\n## 广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)\n把根节点放到队列的末尾。\n每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。\n找到所要找的元素时结束程序。\n如果遍历整个树还没有找到，结束程序。\n### 注意\npython3中经典类和新式类都是广度优先\n## 拓扑排序：\n对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。\n拓扑排序的实现步骤：\n循环执行以下两步，直到不存在入度为0的顶点为止\n选择一个入度为0的顶点并输出之；\n从网中删除此顶点及所有出边。\n## python中调用父类方法的两种方式：\n``` python\nclass A(object):\n   def __init__(self):\n       self.name = \"A: name\"\n       print \"A:__init__\"\n   def fun(self):\n       print \"A:fun\"\n\nclass B(A):\n   def __init__(self):\n       print \"B:__init__\"\n       A.__init__(self)                # 使用类名直接调用\n       super(B, self).__init__()       # 使用super关键字调用\n   def fun(self):\n       print \"B:fun\"\n       A.fun(self)\n       super(B, self).fun()\n       print self.name\n```\n对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：\n``` python\nclass A(object):\n   def __init__(self):\n       print \"enter A\"\n       print \"leave A\"\n\nclass B(object):\n   def __init__(self):\n       print \"enter B\"\n       print \"leave B\"\n\nclass C(A):\n   def __init__(self):\n       print \"enter C\"\n       super(C, self).__init__()\n       print \"leave C\"\n\nclass D(A):\n   def __init__(self):\n       print \"enter D\"\n       super(D, self).__init__()\n       print \"leave D\"\n\nclass E(B, C):\n   def __init__(self):\n       print \"enter E\"\n       B.__init__(self)\n       C.__init__(self)\n       print \"leave E\"\n\nclass F(E, D):\n   def __init__(self):\n       print \"enter F\"\n       E.__init__(self)\n       D.__init__(self)\n       print \"leave F\"\n\nf = F()\n```\n输出结果：\nenter F\nenter E\nenter B\nleave B\nenter C\nenter D\nenter A\nleave A\nleave D\nleave C\nleave E\nenter D\nenter A\nleave A\nleave D\nleave F\n类的继承关系如下所示：\n   object\n  |       \\\n  |        A\n  |      / |\n  B       C  D\n   \\   /   |\n     E     |\n       \\   |\n         F\n我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).__init__()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！\n## C3算法的演变历史：\n### 经典类（python 2.2之前）：\n在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：\n正常的继承方式：\nA->B->D\nA->C->E\nDFS的遍历顺序为：A->B->D->C->E\n这种情况下，不会产生问题。\n菱形的继承方式\nA->B->D\nA->C->D\nDFS的遍历顺序为：A->B->D->C\n对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。\n### 新式类（python2.2）：\n在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：\n如果是经典类，MRO使用DFS\n如果是新式类，MRO使用BFS\n针对新式类的BFS示例如下（向右是基类方向）：\n正常继承方式：\nA->B->D\nA->C->E\nBFS的遍历顺序为：A->B->C->D->E\nD是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。\n菱形的继承方式\nA->B->D\nA->C->D\nBFS的遍历顺序为：A->B->C->D\nBFS解决了前面提到的子类无法重写基类方法的问题。\n### 经典类和新式类并存（python2.3-python2.7），C3算法产生：\n由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：\n正常继承方式：\nA->B->D\nA->C->E\nC3的遍历顺序为：A->B->D->C->E\n菱形的继承方式\nA->B->D\nA->C->D\nC3的遍历顺序为：A->B->C->D\n看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：\n从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。\n结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：\n![Alt text](/images/object.jpeg)\n首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。\n了解了C3算法，我们前面那个混用的例子中调用super(C,self).__init__()会去调用D构造函数的原因也就显而易见了。\n在python中提供了__mro__内置属性来查看类的MRO，例如：\n``` python\nclass D(object):\n   pass\n\nclass E(object):\n   pass\n\nclass F(object):\n   pass\n\nclass C(D, F):\n   pass\n\nclass B(E, D):\n   pass\n\nclass A(B, C):\n   pass\n\nprint A.__mro__\n\n#输出：(<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.D'>, <class '__main__.F'>, <type 'object'>)\n\n```\n","source":"_posts/python/inherit.md","raw":"---\ntitle: python的多继承\ndate: 2017-04-21 16:35:44\ntags:\ncategories: python\n---\n# 二义性\npython支持多继承，多继承的语言往往会遇到以下两类二义性的问题：\n有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。\n有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。\nC++也是支持多继承的语言之一\n对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。\n对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。\n## Python中多继承与super()用法\nPython类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。\n\n考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。\n``` python\n# 经典类\nclass A():\n    def __init__(self):\n        print 'A'\n\nclass B(A):\n    def __init__(self):\n        A.__init__(self)\n        print 'B'\n\nclass C(B, A):\n    def __init__(self):\n        A.__init__(self)\n        B.__init__(self)\n        print 'C'\n```\n采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。\n``` python\n# 新式类\nclass A(object):\n    def __init__(self):\n        print 'A'\n\nclass B(A):\n    def __init__(self):\n        super(B, self).__init__()\n        print 'B'\n\nclass C(B, A):\n    def __init__(self):\n        super(C, self).__init__()\n        print 'C'\n```\n采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。\n``` python\n#coding=utf-8\nclass A(object):\n\tname = 'A'\n\tdef __init__(self):\n\t\tprint 'This is a A‘s construct'\n\nclass B(A):\n\tname = 'B'\n\tdef __init__(self):\n\t\tsuper(B,self).__init__()\n\t\tprint 'This is a B‘s construct'\nclass C(A,B):\n\tname = 'C'\n\tdef __init__(self):\n\t\tsuper(C, self).__init__()\n\t\t# B.__init__(self)\n\t\tprint 'This is a C‘s construct'\n\nc = C()\n```\n结果:\n![Alt text](/images/result.jpeg)\n仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。\n``` python\n#coding=utf-8\nclass A(object):\n\tpass\n\nclass B(object):\n\tname = 'B'\n\tdef __init__(self):\n\t\tprint('This is a B‘s constructor')\nclass C(A,B):\n\tname = 'C'\n\tdef __init__(self):\n\t\tsuper(C, self).__init__()   # 如果A没有复写构造方法，\n\t\t# super会调用继承顺序从左到右第一个复写构造方法的父类\n\t\t# B.__init__(self)\n\t\tprint('This is a C‘s constructor')\n\nc = C()\n\n```\n### 注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\n\npython中通过C3算法很好的避免了以上两类二义性的情况。\n## 深度优先算法（DFS，Depth-First-Search）\n把根节点压入栈中。\n每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。\n找到所要找的元素时结束程序。\n如果遍历整个树还没有找到，结束程序。\n### 注意\npython2 里如果用的经典类 是使用的 深度优选\npython2 里如果用的新式类 是使用的 广度优选\n## 广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)\n把根节点放到队列的末尾。\n每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。\n找到所要找的元素时结束程序。\n如果遍历整个树还没有找到，结束程序。\n### 注意\npython3中经典类和新式类都是广度优先\n## 拓扑排序：\n对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。\n拓扑排序的实现步骤：\n循环执行以下两步，直到不存在入度为0的顶点为止\n选择一个入度为0的顶点并输出之；\n从网中删除此顶点及所有出边。\n## python中调用父类方法的两种方式：\n``` python\nclass A(object):\n   def __init__(self):\n       self.name = \"A: name\"\n       print \"A:__init__\"\n   def fun(self):\n       print \"A:fun\"\n\nclass B(A):\n   def __init__(self):\n       print \"B:__init__\"\n       A.__init__(self)                # 使用类名直接调用\n       super(B, self).__init__()       # 使用super关键字调用\n   def fun(self):\n       print \"B:fun\"\n       A.fun(self)\n       super(B, self).fun()\n       print self.name\n```\n对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：\n``` python\nclass A(object):\n   def __init__(self):\n       print \"enter A\"\n       print \"leave A\"\n\nclass B(object):\n   def __init__(self):\n       print \"enter B\"\n       print \"leave B\"\n\nclass C(A):\n   def __init__(self):\n       print \"enter C\"\n       super(C, self).__init__()\n       print \"leave C\"\n\nclass D(A):\n   def __init__(self):\n       print \"enter D\"\n       super(D, self).__init__()\n       print \"leave D\"\n\nclass E(B, C):\n   def __init__(self):\n       print \"enter E\"\n       B.__init__(self)\n       C.__init__(self)\n       print \"leave E\"\n\nclass F(E, D):\n   def __init__(self):\n       print \"enter F\"\n       E.__init__(self)\n       D.__init__(self)\n       print \"leave F\"\n\nf = F()\n```\n输出结果：\nenter F\nenter E\nenter B\nleave B\nenter C\nenter D\nenter A\nleave A\nleave D\nleave C\nleave E\nenter D\nenter A\nleave A\nleave D\nleave F\n类的继承关系如下所示：\n   object\n  |       \\\n  |        A\n  |      / |\n  B       C  D\n   \\   /   |\n     E     |\n       \\   |\n         F\n我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).__init__()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！\n## C3算法的演变历史：\n### 经典类（python 2.2之前）：\n在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：\n正常的继承方式：\nA->B->D\nA->C->E\nDFS的遍历顺序为：A->B->D->C->E\n这种情况下，不会产生问题。\n菱形的继承方式\nA->B->D\nA->C->D\nDFS的遍历顺序为：A->B->D->C\n对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。\n### 新式类（python2.2）：\n在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：\n如果是经典类，MRO使用DFS\n如果是新式类，MRO使用BFS\n针对新式类的BFS示例如下（向右是基类方向）：\n正常继承方式：\nA->B->D\nA->C->E\nBFS的遍历顺序为：A->B->C->D->E\nD是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。\n菱形的继承方式\nA->B->D\nA->C->D\nBFS的遍历顺序为：A->B->C->D\nBFS解决了前面提到的子类无法重写基类方法的问题。\n### 经典类和新式类并存（python2.3-python2.7），C3算法产生：\n由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：\n正常继承方式：\nA->B->D\nA->C->E\nC3的遍历顺序为：A->B->D->C->E\n菱形的继承方式\nA->B->D\nA->C->D\nC3的遍历顺序为：A->B->C->D\n看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：\n从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。\n结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：\n![Alt text](/images/object.jpeg)\n首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。\n了解了C3算法，我们前面那个混用的例子中调用super(C,self).__init__()会去调用D构造函数的原因也就显而易见了。\n在python中提供了__mro__内置属性来查看类的MRO，例如：\n``` python\nclass D(object):\n   pass\n\nclass E(object):\n   pass\n\nclass F(object):\n   pass\n\nclass C(D, F):\n   pass\n\nclass B(E, D):\n   pass\n\nclass A(B, C):\n   pass\n\nprint A.__mro__\n\n#输出：(<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.D'>, <class '__main__.F'>, <type 'object'>)\n\n```\n","slug":"python/inherit","published":1,"updated":"2018-02-23T10:18:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdzsd6t70015hhu240v4g3ds","content":"<h1 id=\"二义性\"><a href=\"#二义性\" class=\"headerlink\" title=\"二义性\"></a>二义性</h1><p>python支持多继承，多继承的语言往往会遇到以下两类二义性的问题：<br>有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。<br>有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。<br>C++也是支持多继承的语言之一<br>对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。<br>对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。</p>\n<h2 id=\"Python中多继承与super-用法\"><a href=\"#Python中多继承与super-用法\" class=\"headerlink\" title=\"Python中多继承与super()用法\"></a>Python中多继承与super()用法</h2><p>Python类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。</p>\n<p>考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 经典类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'A'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        A.__init__(self)</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'B'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B, A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        A.__init__(self)</div><div class=\"line\">        B.__init__(self)</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'C'</span></div></pre></td></tr></table></figure></p>\n<p>采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 新式类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'A'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'B'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B, A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(C, self).__init__()</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'C'</span></div></pre></td></tr></table></figure></p>\n<p>采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'A'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a A‘s construct'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'B'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(B,self).__init__()</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a B‘s construct'</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,B)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'C'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(C, self).__init__()</div><div class=\"line\">\t\t<span class=\"comment\"># B.__init__(self)</span></div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a C‘s construct'</span></div><div class=\"line\"></div><div class=\"line\">c = C()</div></pre></td></tr></table></figure></p>\n<p>结果:<br><img src=\"/images/result.jpeg\" alt=\"Alt text\"><br>仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'B'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tprint(<span class=\"string\">'This is a B‘s constructor'</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,B)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'C'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(C, self).__init__()   <span class=\"comment\"># 如果A没有复写构造方法，</span></div><div class=\"line\">\t\t<span class=\"comment\"># super会调用继承顺序从左到右第一个复写构造方法的父类</span></div><div class=\"line\">\t\t<span class=\"comment\"># B.__init__(self)</span></div><div class=\"line\">\t\tprint(<span class=\"string\">'This is a C‘s constructor'</span>)</div><div class=\"line\"></div><div class=\"line\">c = C()</div></pre></td></tr></table></figure></p>\n<h3 id=\"注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\"><a href=\"#注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\" class=\"headerlink\" title=\"注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\"></a>注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数</h3><p>python中通过C3算法很好的避免了以上两类二义性的情况。</p>\n<h2 id=\"深度优先算法（DFS，Depth-First-Search）\"><a href=\"#深度优先算法（DFS，Depth-First-Search）\" class=\"headerlink\" title=\"深度优先算法（DFS，Depth-First-Search）\"></a>深度优先算法（DFS，Depth-First-Search）</h2><p>把根节点压入栈中。<br>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>python2 里如果用的经典类 是使用的 深度优选<br>python2 里如果用的新式类 是使用的 广度优选</p>\n<h2 id=\"广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选\"><a href=\"#广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选\" class=\"headerlink\" title=\"广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)\"></a>广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)</h2><p>把根节点放到队列的末尾。<br>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>python3中经典类和新式类都是广度优先</p>\n<h2 id=\"拓扑排序：\"><a href=\"#拓扑排序：\" class=\"headerlink\" title=\"拓扑排序：\"></a>拓扑排序：</h2><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。<br>拓扑排序的实现步骤：<br>循环执行以下两步，直到不存在入度为0的顶点为止<br>选择一个入度为0的顶点并输出之；<br>从网中删除此顶点及所有出边。</p>\n<h2 id=\"python中调用父类方法的两种方式：\"><a href=\"#python中调用父类方法的两种方式：\" class=\"headerlink\" title=\"python中调用父类方法的两种方式：\"></a>python中调用父类方法的两种方式：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       self.name = <span class=\"string\">\"A: name\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"A:__init__\"</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"A:fun\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"B:__init__\"</span></div><div class=\"line\">       A.__init__(self)                <span class=\"comment\"># 使用类名直接调用</span></div><div class=\"line\">       super(B, self).__init__()       <span class=\"comment\"># 使用super关键字调用</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"B:fun\"</span></div><div class=\"line\">       A.fun(self)</div><div class=\"line\">       super(B, self).fun()</div><div class=\"line\">       <span class=\"keyword\">print</span> self.name</div></pre></td></tr></table></figure>\n<p>对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter A\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave A\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter B\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave B\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter C\"</span></div><div class=\"line\">       super(C, self).__init__()</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave C\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter D\"</span></div><div class=\"line\">       super(D, self).__init__()</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave D\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(B, C)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter E\"</span></div><div class=\"line\">       B.__init__(self)</div><div class=\"line\">       C.__init__(self)</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave E\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(E, D)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter F\"</span></div><div class=\"line\">       E.__init__(self)</div><div class=\"line\">       D.__init__(self)</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave F\"</span></div><div class=\"line\"></div><div class=\"line\">f = F()</div></pre></td></tr></table></figure></p>\n<p>输出结果：<br>enter F<br>enter E<br>enter B<br>leave B<br>enter C<br>enter D<br>enter A<br>leave A<br>leave D<br>leave C<br>leave E<br>enter D<br>enter A<br>leave A<br>leave D<br>leave F<br>类的继承关系如下所示：<br>   object<br>  |       \\<br>  |        A<br>  |      / |<br>  B       C  D<br>   \\   /   |<br>     E     |<br>       \\   |<br>         F<br>我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).<strong>init</strong>()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！</p>\n<h2 id=\"C3算法的演变历史：\"><a href=\"#C3算法的演变历史：\" class=\"headerlink\" title=\"C3算法的演变历史：\"></a>C3算法的演变历史：</h2><h3 id=\"经典类（python-2-2之前）：\"><a href=\"#经典类（python-2-2之前）：\" class=\"headerlink\" title=\"经典类（python 2.2之前）：\"></a>经典类（python 2.2之前）：</h3><p>在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：<br>正常的继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>这种情况下，不会产生问题。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C<br>对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。</p>\n<h3 id=\"新式类（python2-2）：\"><a href=\"#新式类（python2-2）：\" class=\"headerlink\" title=\"新式类（python2.2）：\"></a>新式类（python2.2）：</h3><p>在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：<br>如果是经典类，MRO使用DFS<br>如果是新式类，MRO使用BFS<br>针对新式类的BFS示例如下（向右是基类方向）：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E<br>D是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>BFS解决了前面提到的子类无法重写基类方法的问题。</p>\n<h3 id=\"经典类和新式类并存（python2-3-python2-7），C3算法产生：\"><a href=\"#经典类和新式类并存（python2-3-python2-7），C3算法产生：\" class=\"headerlink\" title=\"经典类和新式类并存（python2.3-python2.7），C3算法产生：\"></a>经典类和新式类并存（python2.3-python2.7），C3算法产生：</h3><p>由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>C3的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>C3的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：<br>从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。<br>结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：<br><img src=\"/images/object.jpeg\" alt=\"Alt text\"><br>首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。<br>了解了C3算法，我们前面那个混用的例子中调用super(C,self).<strong>init</strong>()会去调用D构造函数的原因也就显而易见了。<br>在python中提供了<strong>mro</strong>内置属性来查看类的MRO，例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(D, F)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(E, D)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(B, C)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> A.__mro__</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出：(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;type 'object'&gt;)</span></div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h1 id=\"二义性\"><a href=\"#二义性\" class=\"headerlink\" title=\"二义性\"></a>二义性</h1><p>python支持多继承，多继承的语言往往会遇到以下两类二义性的问题：<br>有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。<br>有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。<br>C++也是支持多继承的语言之一<br>对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。<br>对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。</p>\n<h2 id=\"Python中多继承与super-用法\"><a href=\"#Python中多继承与super-用法\" class=\"headerlink\" title=\"Python中多继承与super()用法\"></a>Python中多继承与super()用法</h2><p>Python类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。</p>\n<p>考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 经典类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'A'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        A.__init__(self)</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'B'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B, A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        A.__init__(self)</div><div class=\"line\">        B.__init__(self)</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'C'</span></div></pre></td></tr></table></figure></p>\n<p>采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># 新式类</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'A'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(B, self).__init__()</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'B'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(B, A)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(C, self).__init__()</div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'C'</span></div></pre></td></tr></table></figure></p>\n<p>采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'A'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a A‘s construct'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'B'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(B,self).__init__()</div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a B‘s construct'</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,B)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'C'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(C, self).__init__()</div><div class=\"line\">\t\t<span class=\"comment\"># B.__init__(self)</span></div><div class=\"line\">\t\t<span class=\"keyword\">print</span> <span class=\"string\">'This is a C‘s construct'</span></div><div class=\"line\"></div><div class=\"line\">c = C()</div></pre></td></tr></table></figure></p>\n<p>结果:<br><img src=\"/images/result.jpeg\" alt=\"Alt text\"><br>仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#coding=utf-8</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\t<span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'B'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tprint(<span class=\"string\">'This is a B‘s constructor'</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A,B)</span>:</span></div><div class=\"line\">\tname = <span class=\"string\">'C'</span></div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">\t\tsuper(C, self).__init__()   <span class=\"comment\"># 如果A没有复写构造方法，</span></div><div class=\"line\">\t\t<span class=\"comment\"># super会调用继承顺序从左到右第一个复写构造方法的父类</span></div><div class=\"line\">\t\t<span class=\"comment\"># B.__init__(self)</span></div><div class=\"line\">\t\tprint(<span class=\"string\">'This is a C‘s constructor'</span>)</div><div class=\"line\"></div><div class=\"line\">c = C()</div></pre></td></tr></table></figure></p>\n<h3 id=\"注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\"><a href=\"#注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\" class=\"headerlink\" title=\"注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数\"></a>注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数</h3><p>python中通过C3算法很好的避免了以上两类二义性的情况。</p>\n<h2 id=\"深度优先算法（DFS，Depth-First-Search）\"><a href=\"#深度优先算法（DFS，Depth-First-Search）\" class=\"headerlink\" title=\"深度优先算法（DFS，Depth-First-Search）\"></a>深度优先算法（DFS，Depth-First-Search）</h2><p>把根节点压入栈中。<br>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>python2 里如果用的经典类 是使用的 深度优选<br>python2 里如果用的新式类 是使用的 广度优选</p>\n<h2 id=\"广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选\"><a href=\"#广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选\" class=\"headerlink\" title=\"广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)\"></a>广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)</h2><p>把根节点放到队列的末尾。<br>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>\n<h3 id=\"注意-1\"><a href=\"#注意-1\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>python3中经典类和新式类都是广度优先</p>\n<h2 id=\"拓扑排序：\"><a href=\"#拓扑排序：\" class=\"headerlink\" title=\"拓扑排序：\"></a>拓扑排序：</h2><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。<br>拓扑排序的实现步骤：<br>循环执行以下两步，直到不存在入度为0的顶点为止<br>选择一个入度为0的顶点并输出之；<br>从网中删除此顶点及所有出边。</p>\n<h2 id=\"python中调用父类方法的两种方式：\"><a href=\"#python中调用父类方法的两种方式：\" class=\"headerlink\" title=\"python中调用父类方法的两种方式：\"></a>python中调用父类方法的两种方式：</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       self.name = <span class=\"string\">\"A: name\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"A:__init__\"</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"A:fun\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"B:__init__\"</span></div><div class=\"line\">       A.__init__(self)                <span class=\"comment\"># 使用类名直接调用</span></div><div class=\"line\">       super(B, self).__init__()       <span class=\"comment\"># 使用super关键字调用</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fun</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"B:fun\"</span></div><div class=\"line\">       A.fun(self)</div><div class=\"line\">       super(B, self).fun()</div><div class=\"line\">       <span class=\"keyword\">print</span> self.name</div></pre></td></tr></table></figure>\n<p>对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter A\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave A\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter B\"</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave B\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter C\"</span></div><div class=\"line\">       super(C, self).__init__()</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave C\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(A)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter D\"</span></div><div class=\"line\">       super(D, self).__init__()</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave D\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(B, C)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter E\"</span></div><div class=\"line\">       B.__init__(self)</div><div class=\"line\">       C.__init__(self)</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave E\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(E, D)</span>:</span></div><div class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"enter F\"</span></div><div class=\"line\">       E.__init__(self)</div><div class=\"line\">       D.__init__(self)</div><div class=\"line\">       <span class=\"keyword\">print</span> <span class=\"string\">\"leave F\"</span></div><div class=\"line\"></div><div class=\"line\">f = F()</div></pre></td></tr></table></figure></p>\n<p>输出结果：<br>enter F<br>enter E<br>enter B<br>leave B<br>enter C<br>enter D<br>enter A<br>leave A<br>leave D<br>leave C<br>leave E<br>enter D<br>enter A<br>leave A<br>leave D<br>leave F<br>类的继承关系如下所示：<br>   object<br>  |       \\<br>  |        A<br>  |      / |<br>  B       C  D<br>   \\   /   |<br>     E     |<br>       \\   |<br>         F<br>我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).<strong>init</strong>()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！</p>\n<h2 id=\"C3算法的演变历史：\"><a href=\"#C3算法的演变历史：\" class=\"headerlink\" title=\"C3算法的演变历史：\"></a>C3算法的演变历史：</h2><h3 id=\"经典类（python-2-2之前）：\"><a href=\"#经典类（python-2-2之前）：\" class=\"headerlink\" title=\"经典类（python 2.2之前）：\"></a>经典类（python 2.2之前）：</h3><p>在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：<br>正常的继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>这种情况下，不会产生问题。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C<br>对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。</p>\n<h3 id=\"新式类（python2-2）：\"><a href=\"#新式类（python2-2）：\" class=\"headerlink\" title=\"新式类（python2.2）：\"></a>新式类（python2.2）：</h3><p>在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：<br>如果是经典类，MRO使用DFS<br>如果是新式类，MRO使用BFS<br>针对新式类的BFS示例如下（向右是基类方向）：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E<br>D是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>BFS解决了前面提到的子类无法重写基类方法的问题。</p>\n<h3 id=\"经典类和新式类并存（python2-3-python2-7），C3算法产生：\"><a href=\"#经典类和新式类并存（python2-3-python2-7），C3算法产生：\" class=\"headerlink\" title=\"经典类和新式类并存（python2.3-python2.7），C3算法产生：\"></a>经典类和新式类并存（python2.3-python2.7），C3算法产生：</h3><p>由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>C3的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>C3的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：<br>从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。<br>结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：<br><img src=\"/images/object.jpeg\" alt=\"Alt text\"><br>首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。<br>了解了C3算法，我们前面那个混用的例子中调用super(C,self).<strong>init</strong>()会去调用D构造函数的原因也就显而易见了。<br>在python中提供了<strong>mro</strong>内置属性来查看类的MRO，例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">E</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">F</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(D, F)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span><span class=\"params\">(E, D)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(B, C)</span>:</span></div><div class=\"line\">   <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">print</span> A.__mro__</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">#输出：(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;type 'object'&gt;)</span></div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdzsd6sh000ghhu2lauaxbyb","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6sr000khhu2ywjl5g6s"},{"post_id":"cjdzsd6s7000chhu2suxwu7pw","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6st000nhhu2jbf3t0qd"},{"post_id":"cjdzsd6si000hhhu2ermwv9ju","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6sw000phhu2yxe9t8ss"},{"post_id":"cjdzsd6sp000jhhu22yvtjzxo","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6sy000shhu277380jlr"},{"post_id":"cjdzsd6s9000dhhu2a1pocz6v","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6sz000uhhu2tcr0e9vx"},{"post_id":"cjdzsd6ss000lhhu2radoxe59","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6t0000whhu2i5vu66qb"},{"post_id":"cjdzsd6sf000fhhu2hemr8rbf","category_id":"cjdzsd6sa000ehhu2rwlyu2qa","_id":"cjdzsd6t2000zhhu2z4b9qypp"},{"post_id":"cjdzsd6sz000vhhu2etrul9b5","category_id":"cjdzsd6sy000rhhu2axb5q3d3","_id":"cjdzsd6t40011hhu29gp0yl81"},{"post_id":"cjdzsd6su000ohhu2dwlcwdof","category_id":"cjdzsd6sy000rhhu2axb5q3d3","_id":"cjdzsd6t70014hhu244h1v61g"},{"post_id":"cjdzsd6t0000xhhu2sjjpje8n","category_id":"cjdzsd6sy000rhhu2axb5q3d3","_id":"cjdzsd6t80016hhu27zkdrouc"},{"post_id":"cjdzsd6sw000qhhu2mk139bp8","category_id":"cjdzsd6sy000rhhu2axb5q3d3","_id":"cjdzsd6t90018hhu24tfy03x1"},{"post_id":"cjdzsd6sy000thhu2te0yuv0i","category_id":"cjdzsd6sy000rhhu2axb5q3d3","_id":"cjdzsd6tb0019hhu2fi61n95y"},{"post_id":"cjdzsd6t30010hhu2pucbwgcx","category_id":"cjdzsd6t90017hhu23dm978o9","_id":"cjdzsd6tc001bhhu2uq8o4wfg"},{"post_id":"cjdzsd6t40012hhu2kcmtti7v","category_id":"cjdzsd6tb001ahhu2zmzslagk","_id":"cjdzsd6td001dhhu2wsg9swun"},{"post_id":"cjdzsd6t70015hhu240v4g3ds","category_id":"cjdzsd6tb001ahhu2zmzslagk","_id":"cjdzsd6td001ehhu24sqeqk03"}],"PostTag":[],"Tag":[]}}