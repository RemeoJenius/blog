<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="主要是学习后端技术，学过Java web、python web等后台技术">
<meta property="og:type" content="website">
<meta property="og:title" content="jeniusLi's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="jeniusLi's blog">
<meta property="og:description" content="主要是学习后端技术，学过Java web、python web等后台技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jeniusLi's blog">
<meta name="twitter:description" content="主要是学习后端技术，学过Java web、python web等后台技术">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> jeniusLi's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jeniusLi's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活、技术个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/17/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-17T13:37:25+08:00">
                2018-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/15/java/第二章创建和销毁对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/15/java/第二章创建和销毁对象/" itemprop="url">
                  第二章创建和销毁对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T18:58:27+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。"><a href="#这段时间打算读java方面经典著作-lt-gt-第2版-虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。" class="headerlink" title="这段时间打算读java方面经典著作&lt;&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。"></a>这段时间打算读java方面经典著作&lt;<effective java="">&gt; 第2版 虽然是09年出的了不过还是读一读，这本书的第一章是引言，第二章才是真正的内容那我们与书中的章节所对应，从第二章开始。</effective></h1><h2 id="第1条：考虑用静态工程方法代替构造器"><a href="#第1条：考虑用静态工程方法代替构造器" class="headerlink" title="第1条：考虑用静态工程方法代替构造器"></a>第1条：考虑用静态工程方法代替构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> String objectId;</div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="title">MyObject</span><span class="params">(String objectId)</span> </span>&#123;<span class="comment">//私有构造器</span></div><div class="line">         <span class="keyword">this</span>.objectId = objectId;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">newInstance</span><span class="params">(String objectId)</span></span>&#123;<span class="comment">//静态工厂方法</span></div><div class="line">         <span class="keyword">return</span> <span class="keyword">new</span> MyObject(objectId);</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最好不用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">       <span class="keyword">private</span> String objectId;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">(String objectId)</span> </span>&#123;<span class="comment">//共有构造器</span></div><div class="line">         <span class="keyword">this</span>.objectId = objectId;</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="静态工厂方法与构造器不同的第一大优势在于，它们有名称。"><a href="#静态工厂方法与构造器不同的第一大优势在于，它们有名称。" class="headerlink" title="静态工厂方法与构造器不同的第一大优势在于，它们有名称。"></a>静态工厂方法与构造器不同的第一大优势在于，它们有名称。</h3><p>构造器只有参数的个数和数目，对于每个构造器的含义模糊不清，使用静态工厂方法可以根据名称更好的确定其含义。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyObject myObject = <span class="keyword">new</span> MyObject();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyObject <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> myObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。"><a href="#静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。" class="headerlink" title="静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。"></a>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象，也就是将有的静态工厂方法可以编程单例模式那样，降低资源损耗，提升性能。</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/31/C++/静态对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/31/C++/静态对象/" itemprop="url">
                  静态对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T18:39:21+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h1><p><img src="/images/C++/static1.png" alt="Alt text"><br>static关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。<br>它的第一层含义是说：存储是持久存储的。<br>第二层含义是说：它的访问性，是受局限的。<br>这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。<br>到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。<br>我们在进一步去理解这两样东西是什么。<br><img src="/images/C++/static2.png" alt="Alt text"><br>我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。<br>static的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。</p>
<h2 id="Static-inside-functions"><a href="#Static-inside-functions" class="headerlink" title="Static inside functions"></a>Static inside functions</h2><ul>
<li>Value is remembered for entire program</li>
<li>Initialization occurs only once<br>其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。<br><img src="/images/C++/static3.png" alt="Alt text"><br>如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。<br>也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。<br>如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。<br>如果你的对象是全局的呢？<br><img src="/images/C++/static4.png" alt="Alt text"><br>它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。<br>这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。<br><img src="/images/C++/static5.png" alt="Alt text"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/25/algorithm/散列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/25/algorithm/散列表/" itemprop="url">
                  散列表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-25T13:04:44+08:00">
                2017-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><p>散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。<br>对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。</p>
<h2 id="5-1散列函数"><a href="#5-1散列函数" class="headerlink" title="5.1散列函数"></a>5.1散列函数</h2><p>散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。<br><img src="/images/algorithm/hash1.png" alt="Alt text"><br>散列函数必须满足一些要求：</p>
<ul>
<li><strong>它必须是一致的。</strong> 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。</li>
<li><strong>它应将不同的输入映射到不同的数字。</strong> 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。</li>
</ul>
<hr>
<p>动手写一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">map = dict() <span class="comment"># 和map = &#123;&#125;等价</span></div><div class="line"></div><div class="line">map[<span class="string">"apple"</span>] = <span class="number">1</span></div><div class="line">map[<span class="string">"pear"</span>] = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> map</div></pre></td></tr></table></figure></p>
<p>结果：<br>{‘pear’: 1, ‘apple’: 1}<br>散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。</p>
<ul>
<li>散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。</li>
<li>散列函数将不同的输入映射到不同的索引。</li>
<li>散列函数知道数组有多大，只返回有效的索引。<br>在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。<h2 id="将散列表用作缓存"><a href="#将散列表用作缓存" class="headerlink" title="将散列表用作缓存"></a>将散列表用作缓存</h2><img src="/images/algorithm/hash2.png" alt="Alt text"><br>将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。<br>大致上说缓存具有以下两个优点：</li>
<li>用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。</li>
<li>Facebook需要做的工作也就更少了。<br>缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>这里总结一下，散列表适合用于：</li>
<li>模仿映射关系</li>
<li>防止重复</li>
<li>缓存/记住数据，以免服务器再通过处理来生成它们。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cache = &#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></div><div class="line">	<span class="keyword">if</span> cahce.get(url):</div><div class="line">		<span class="keyword">return</span> cachae[<span class="string">"url"</span>]</div><div class="line">	<span class="keyword">else</span> :</div><div class="line">		data = get_data_from_server(url)</div><div class="line">		cache[url] = data</div><div class="line">		<span class="keyword">return</span> data</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>冲突：给两个键分配的位置相同。<br>避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。<br>简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。<br><img src="/images/algorithm/hash3.png" alt="Alt text"><br>但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。<br>这里有两个教训:</p>
<ul>
<li><strong>散列函数很重要。</strong> 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。</li>
<li><strong>如果散列表存储的链表很长，散列表的速度将急剧下降。</strong> 然而使用散列函数很好，这些链表就不会很长！<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2>在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。<br><img src="/images/algorithm/hash4.png" alt="Alt text"><br>图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。<br>在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。<br><img src="/images/algorithm/hash5.png" alt="Alt text"><br>在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：</li>
<li>较低的填裝因子；</li>
<li>良好的散列函数。<h2 id="填装因子"><a href="#填装因子" class="headerlink" title="填装因子"></a>填装因子</h2>散列表的填裝因子很容易计算：<br><img src="/images/algorithm/hash6.png" alt="Alt text"><br>散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。<br><img src="/images/algorithm/hash7.png" alt="Alt text"><br>这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。<br>你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。<h2 id="良好的散列函数"><a href="#良好的散列函数" class="headerlink" title="良好的散列函数"></a>良好的散列函数</h2><img src="/images/algorithm/hash8.png" alt="Alt text"></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/22/C++/拷贝构造函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/22/C++/拷贝构造函数/" itemprop="url">
                  拷贝构造函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-22T10:19:08+08:00">
                2017-05-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h1><p>首先分清楚一组词initialization和assignment;<br>initialization：定义一个变量的时候给了它一个值；<br>assignment：已经定义好变量了，你在给它一个值；<br>初始化和赋值在C++是非常不一样的。<br>先看一下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> objectCont = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> HowMany&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		HowMany()&#123;objectCont++;print(<span class="string">"HowMany()"</span>);&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg = <span class="string">""</span> )</span></span>&#123;</div><div class="line">			<span class="keyword">if</span>(msg.size() != <span class="number">0</span>)&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt; msg &lt;&lt;<span class="string">": "</span>;</div><div class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"objectCont = "</span>&lt;&lt;objectCont&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		~HowMany()&#123;</div><div class="line">			objectCont--;</div><div class="line">			print(<span class="string">"~HowMany()"</span>);</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">HowMany <span class="title">f</span><span class="params">(HowMany x)</span></span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"begin of f"</span> &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	x.print(<span class="string">"x argumnet inside f()"</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"end of f"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	HowMany h;</div><div class="line">	h.print(<span class="string">"after construction of h"</span>);</div><div class="line">	HowMany h2 = f(h);</div><div class="line">	h.print(<span class="string">"after call to f()"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>begin of f<br>x argumnet inside f(): objectCont = 1<br>end of f<br>~HowMany(): objectCont = 0<br>after call to f(): objectCont = 0<br>~HowMany(): objectCont = -1<br>~HowMany(): objectCont = -2<br>出现了不平衡，通过某些方法绕过了构造方法，来创建了HowMany的对象。<br>在看一下这个代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> objectCont = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> HowMany&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		HowMany()&#123;objectCont++;print(<span class="string">"HowMany()"</span>);&#125;</div><div class="line">		HowMany(<span class="keyword">int</span> i)&#123;objectCont++;print(<span class="string">"HowMany(int)"</span>);&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg = <span class="string">""</span> )</span></span>&#123;</div><div class="line">			<span class="keyword">if</span>(msg.size() != <span class="number">0</span>)&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt; msg &lt;&lt;<span class="string">": "</span>;</div><div class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"objectCont = "</span>&lt;&lt;objectCont&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		~HowMany()&#123;</div><div class="line">			objectCont--;</div><div class="line">			print(<span class="string">"~HowMany()"</span>);</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">HowMany <span class="title">f</span><span class="params">(HowMany x)</span></span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"begin of f"</span> &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	x.print(<span class="string">"x argumnet inside f()"</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"end of f"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	HowMany h;</div><div class="line">	h.print(<span class="string">"after construction of h"</span>);</div><div class="line">	HowMany h2 = <span class="number">10</span>; <span class="comment">// 跟 HoWMany h2(10); 等价的，</span></div><div class="line">	<span class="comment">// h.print("after call to f()");</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(int): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>如果说，有一个要int类型的构造函数，在创建这个类的对象的时候我们可以写成HowMany h2 = 10，那么有一个要HowMany对象的构造函数呢？我们把之前的都还原，再加上这个构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> objectCont = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> HowMany&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		HowMany()&#123;objectCont++;print(<span class="string">"HowMany()"</span>);&#125;</div><div class="line">		HowMany(<span class="keyword">int</span> i)&#123;objectCont++;print(<span class="string">"HowMany(int)"</span>);&#125;</div><div class="line">		HowMany(<span class="keyword">const</span> HowMany&amp; o)&#123;objectCont++;print(<span class="string">"HowMany(HowMany)"</span>);&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg = <span class="string">""</span> )</span></span>&#123;</div><div class="line">			<span class="keyword">if</span>(msg.size() != <span class="number">0</span>)&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt; msg &lt;&lt;<span class="string">": "</span>;</div><div class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"objectCont = "</span>&lt;&lt;objectCont&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		~HowMany()&#123;</div><div class="line">			objectCont--;</div><div class="line">			print(<span class="string">"~HowMany()"</span>);</div><div class="line">		&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">HowMany <span class="title">f</span><span class="params">(HowMany x)</span></span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"begin of f"</span> &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	x.print(<span class="string">"x argumnet inside f()"</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"end of f"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	HowMany h;</div><div class="line">	h.print(<span class="string">"after construction of h"</span>);</div><div class="line">	HowMany h2 = f(h);</div><div class="line">	h.print(<span class="string">"after call to f()"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>HowMany(): objectCont = 1<br>after construction of h: objectCont = 1<br>HowMany(HowMany): objectCont = 2<br>begin of f<br>x argumnet inside f(): objectCont = 2<br>end of f<br>HowMany(HowMany): objectCont = 3<br>~HowMany(): objectCont = 2<br>after call to f(): objectCont = 2<br>~HowMany(): objectCont = 1<br>~HowMany(): objectCont = 0<br>平衡也都回来了，最大的时候有三个。有三个，一个是f里面的那个x，有一个h，h2是第三个。<br>这说明，如果有一个类的构造函数，这个构造函数它的参数是自己那个类型的const reference，这个构造函数就可以在做这种类型的初始化的时候别调用（初始化这个对象的时候，用另外一个这个类的对象来初始化）。这样的构造函数我们有一个特殊的名字，拷贝构造。<br><img src="/images/C++/copy1.png" alt="Alt text"><br>如果你没有给一个那样的拷贝构造，C++会自动给你一个，当然如果你给了，你就可以通过你给的那个拷贝构造怎么去控制。比方说你有些东西不想拷贝，或者有些东西要做很多的安排。如果你没有那个拷贝构造，编译器会给你一个，那个会拷贝每一个成员变量，它会做成员变量对成员变量的拷贝，这是在成员级别的拷贝，不是字节对字节的拷贝，只不过如果你的member全部都不是对象，那么它的最终结果就是字节对字节的拷贝。如果你的成员中有指针的话，那么拷贝就是指针的拷贝，就是两个指针指向同一片内存。同样的道理如果出现成员变量是reference的话，也会发生reference的拷贝，这两个reference是绑定同一个变量。<br>我们可以试一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		<span class="keyword">int</span> *i;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">		<span class="function"><span class="keyword">int</span>* <span class="title">getI</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> A::setI(<span class="keyword">int</span> i)&#123;</div><div class="line">	<span class="keyword">this</span>-&gt;i = &amp;i;</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">int</span>* A::getI()&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">12</span>;</div><div class="line">	A a;</div><div class="line">	a.i = &amp;i;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;a.i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	A b = a;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;b.i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>0x7fff5089faac<br>0x7fff5089faac<br>地址是一样的，但是我们所希望的是，它们不只想同一块内存。这就需要人为的写出拷贝构造去给那个指针分配空间。<br>一般来说，调用拷贝构造的场景就是初始化的时候，但是初始化又有一些隐藏的场景（调函数的时候）。还有就是我们有一个函数，这个函数会创建一个本定变量（对象）将这个对象return回去，也会发生拷贝构造。<br>initialization指的是只能做一次的，任何对象的初始化只能做一次。做完之后，在对它做任何动作那就是assignment而不是initialization。所以到了C++就不要用char<em>，char</em>是c的字符串，到了C++用string。<br>到了现在我们到了现在，写一个类就应该写三个函数，不管用到没用到，第一个：default constructor；第二个：virtual destructor；第三个：copy constructor；不要依赖于编译器给你的那个。如果不想对象被拷贝，就把拷贝构造函数设置为private的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/17/algorithm/快速排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/17/algorithm/快速排序/" itemprop="url">
                  快速排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-17T15:39:03+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4-1分而治之"><a href="#4-1分而治之" class="headerlink" title="4.1分而治之"></a>4.1分而治之</h1><p>我们将探索分而治之（divide and conquer,D&amp;C）一种的递归式问题解方法。<br>书上介绍了一个土地划分的问题。将一个长方形的土地分为由多个正方形组成的，求这个正方形最大的面积是多少。<br>有兴趣的可以看一下。还介绍了欧几里得算法。<br>现在说一下D&amp;C的工作原理：</p>
<ul>
<li><strong>(1)</strong>:找出简单的基线条件；</li>
<li><strong>(2)</strong>:确定如何缩小问题的规模，使其符合基准条件。<br>D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。我们看一个例子。<br>给定一个数组<br><img src="/images/algorithm/D&amp;R1.png" alt="Alt text"><br>你需要将这些数字想加，并返回结果。使用循环很容易完成这种任务。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></div><div class="line">	s = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> list:</div><div class="line">		s += i</div><div class="line">	<span class="keyword">return</span> s</div><div class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">print</span> sum(list)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>但如何使用递归来完成任务呢？</p>
<ul>
<li><strong>第一步</strong>:找出基线条件。想一下最简单的数组是什么样子的。<br><img src="/images/algorithm/D&amp;R2.png" alt="Alt text"></li>
<li><strong>第二步</strong>:每次递归调用都必须离空数组更近一步。<br><img src="/images/algorithm/D&amp;R3.png" alt="Alt text"><br><img src="/images/algorithm/D&amp;R4.png" alt="Alt text"><br>参考代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list)</span>:</span></div><div class="line">	<span class="keyword">if</span> len(list)==<span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span></div><div class="line">	<span class="keyword">else</span> :</div><div class="line">		<span class="keyword">return</span> list.pop(<span class="number">0</span>) + sum(list)</div><div class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"></div><div class="line"><span class="keyword">print</span> sum(list)</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>提示<br>编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样。</p>
</blockquote>
<p>我们修改成尾递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(list,s=<span class="number">0</span>)</span>:</span></div><div class="line"></div><div class="line">	<span class="keyword">if</span> len(list)==<span class="number">0</span>:</div><div class="line">		<span class="keyword">return</span> s</div><div class="line">	<span class="keyword">else</span> :</div><div class="line">		<span class="keyword">return</span> sum(list,list.pop(<span class="number">0</span>) + sum(list))</div><div class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</div><div class="line"></div><div class="line"><span class="keyword">print</span> sum(list)</div></pre></td></tr></table></figure></p>
<p>注意基准条件！<br><img src="/images/algorithm/D&amp;R5.png" alt="Alt text"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速查找是一种常用的排序算法，比选择排序快得多。例如C语言标准裤中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。<br><img src="/images/algorithm/D&amp;R6.png" alt="Alt text"><br>这被称为分区partitioning（分区）。现在你有：</p>
<ul>
<li><strong>1</strong>:一个由所有小于基准值的数字组成的子数组；</li>
<li><strong>2</strong>:基准值；</li>
<li><strong>3</strong>:一个由所有大于基准值的数组组成的子数组。<br><img src="/images/algorithm/D&amp;R7.png" alt="Alt text"><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quest</span><span class="params">(list)</span>:</span></div><div class="line">	<span class="keyword">if</span> len(list) &lt; <span class="number">2</span> :</div><div class="line">		<span class="keyword">return</span> list</div><div class="line">	<span class="keyword">else</span> :</div><div class="line">		first = list[<span class="number">0</span>]</div><div class="line">		left = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= first]</div><div class="line">		right = [i <span class="keyword">for</span> i <span class="keyword">in</span> list[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; first]</div><div class="line">		<span class="keyword">return</span> quest(left)+[first]+quest(right)</div><div class="line">list = [<span class="number">11</span>,<span class="number">2</span>,<span class="number">55</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">11</span>]</div><div class="line"><span class="keyword">print</span> quest(list)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于像时间复杂度O(n)，其实n的前面有一个固定的时间量C，有的时候可以忽略，例如：<br>二分法查找和简单查找来说，前者是O(logn)后者是O(n)比如二分法查找的固定的时间常量是1秒而简单查找固定的时间量是10毫秒。你可能认为简单查找的常量为10毫秒，而二分查的常量为1秒，因为简单查找的速度要快得多。现在假设你要在包含40亿歌元素的列表中查找：<br>简单查找 10毫秒<em>40亿 ＝ 463天<br>二分查找 1秒</em>32      = 32秒<br>正如你看到的常量没有影响。但是有的时候，常量的影响可能很大。<br>例如：合并排序和快速排序，快速排序最早情况是O(n2)和选择排序是一样的时间复杂度，平均情况是O(nlogn)。而合并排序，平均和最糟都是O(nlogn)。快速排序的时间复杂度跟基准值有关。快速排序最佳情况的时间复杂度是O(logn)（调用栈的高度是O(logn）而每层需要的时间是O(n)所以最佳情况是O(n) <em> O(logn) = O(nlogn)<br>在最糟情况下，有O(n)曾，因此时间复杂度是O(n)</em> O(n) = O(n2)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/algorithm/递归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/algorithm/递归/" itemprop="url">
                  递归
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T20:55:05+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”<br>我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。<br>假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。<br>祖母告诉你,钥匙很可能在下面这个盒子里。<br><img src="/images/algorithm/recursive1.png" alt="Alt text"><br>这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。<br>下面是一种方法。<br><img src="/images/algorithm/recursive2.png" alt="Alt text"><br>(1) 创建一个要查找的盒子堆。<br>(2) 从盒子堆取出一个盒子,在里面找。<br>(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!<br>(5) 回到第二步。<br>下面是另一种方法。<br><img src="/images/algorithm/recursive3.png" alt="Alt text"><br>(1) 检查盒子中的每样东西。<br>(2) 如果是盒子,就回到第一步。<br>(3) 如果是钥匙,就大功告成!<br>在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(main_box)</span>:</span></div><div class="line">    pile = main_box.make_a_pile_to_look_through()</div><div class="line">    <span class="keyword">while</span> pile <span class="keyword">is</span> <span class="keyword">not</span> empty:</div><div class="line">        box = pile.grab_a_box()</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> box:</div><div class="line">            <span class="keyword">if</span> item.is_a_box():</div><div class="line">                pile.append(item)</div><div class="line">            <span class="keyword">elif</span> item.is_a_key():</div><div class="line">                <span class="keyword">print</span> <span class="string">"found the key!"</span></div></pre></td></tr></table></figure></p>
<p>第二种方法使用递归——函数调用自己,这种方法的伪代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(box)</span>:</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> box:</div><div class="line">        <span class="keyword">if</span> item.is_a_box():</div><div class="line">            look_for_key(item) <span class="comment"># 递归</span></div><div class="line">        <span class="keyword">elif</span> item.is_a_key():</div><div class="line">            <span class="keyword">print</span> <span class="string">"found the key!"</span></div></pre></td></tr></table></figure></p>
<p>这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能<br> 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。</p>
<h2 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h2><p> 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。<br> 如下：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">print</span> n</div><div class="line">	recursive(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">recursive(<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p> 会在console上打印：<br> <img src="/images/algorithm/recursive4.png" alt="Alt text"><br> 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。<br> 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。<br> 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。<br> 把上面的代码改一下，来给函数添加基线条件：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">print</span> n</div><div class="line">	<span class="keyword">if</span> n &lt;=<span class="number">0</span> : <span class="comment"># 基线条件</span></div><div class="line">		<span class="keyword">return</span></div><div class="line">	<span class="keyword">else</span> :     <span class="comment"># 递归条件</span></div><div class="line">		recursive(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">recursive(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p> 输出结果：10到0<br><img src="/images/algorithm/recursive5.png" alt="Alt text"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。<br>栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet2</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"how are you, "</span>+name + <span class="string">"!"</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"ok bye!"</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"hello, "</span> + name +<span class="string">"!"</span></div><div class="line">	greet2(name)</div><div class="line">	<span class="keyword">print</span> <span class="string">"getting ready to say bye..."</span></div><div class="line">	bye()</div><div class="line"></div><div class="line">greet(<span class="string">'jenius'</span>)</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>hello, jenius!<br>how are you, jenius!<br>getting ready to say bye…<br>ok bye!<br>这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。</p>
<h2 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h2><p>递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其<br>定义如下:5! = 5 <em> 4 </em> 3 <em> 2 </em> 1。同理,factorial(3)为3 <em> 2 </em> 1。下面是计算阶乘的递归函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></div><div class="line">	<span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> x * fact(x<span class="number">-1</span>)</div><div class="line"><span class="keyword">print</span> fact(<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p><img src="/images/algorithm/recursive6.png" alt="Alt text"><br><img src="/images/algorithm/recursive7.png" alt="Alt text"><br> <strong>注意：</strong> 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。<br>栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。<br><img src="/images/algorithm/recursive8.png" alt="Alt text"><br><img src="/images/algorithm/recursive9.png" alt="Alt text"><br>使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。</p>
<ul>
<li><strong>1</strong> ：重新编写代码,转而使用循环。</li>
<li><strong>2</strong> ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言<br>都支持尾递归。<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2>在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。<br>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：<br><em> <strong>调用自身函数(Self-called)；</strong>
</em> <strong>计算仅占用常量栈空间(Stack Space)。</strong><br>而形式上只要是最后一个return语句返回的是一个完整函数，它就是尾递归。<br>由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的函数帧经过适当的更动以后可以直接当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除(Tail Call Elimination)或尾调用优化(Tail Call Optimization, TCO)。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。<br>一般来说，尾调用消除是可选的。然而，在函数编程语言中，语言标准通常会要求虚拟机实现尾调用消除，这让程序员可以用递归取代循环而不丧失性能。<br>这个是维基百科给的一个定义。<br>我看别人的博客中<br>写到尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span> :</span></div><div class="line">    <span class="keyword">return</span> g(x)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。<br>以下两种情况，都不属于尾调用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 情况一</div><div class="line">def f1(x)&#123;</div><div class="line">  int y = g(x)</div><div class="line">  return y</div><div class="line">&#125;</div><div class="line"># 情况二</div><div class="line">def f2(x)&#123;</div><div class="line">  return g(x) + 1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span> :</span></div><div class="line">  <span class="keyword">if</span> x &gt; <span class="number">0</span> :</div><div class="line">    <span class="keyword">return</span> m(x)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> n(x)</div></pre></td></tr></table></figure></p>
<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。<br>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。<br>我们知道，函数调用会在内存形成一个”调用记录”，又称”调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。等到B运行结束，将结果返回到A，B的调用记录才会消失。如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。所有的调用记录，就形成一个”调用栈”（call stack）。<br>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>虽然说算法图解说尾递归不在讨论范围之内，还是想深究一下。<br>我去知乎看了一下：<br>function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story() // 尾递归，进入下一个函数不再需要上一个函数的环境了，得出结果以后直接返回。}function story() {    从前有座山，山上有座庙，庙里有个老和尚，一天老和尚对小和尚讲故事：story()，小和尚听了，找了块豆腐撞死了 // 非尾递归，下一个函数结束以后此函数还有后续，所以必须保存本身的环境以供处理返回值。}</p>
<p>作者：酿泉<br>链接：<a href="https://www.zhihu.com/question/20761771/answer/23254340" target="_blank" rel="external">https://www.zhihu.com/question/20761771/answer/23254340</a><br>来源：知乎<br>这个是点赞最高的179。<br>这个是第二164<br>参考我在Stackoverflow问的这个问题：Why does C preserves both goto and while, involving tail recursion以及：What is tail-recursion?为什么C语言同时保留‘goto’语句和‘while’，和尾递归有什么关系？尾递归是什么？尾递归和一般的递归不同在对内存的占用，普通递归创建stack累积而后计算收缩，尾递归只会占用恒量的内存（和迭代一样）。SICP中描述了一个内存占用曲线，用以上答案中的Python代码为例（普通递归）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recsum</span><span class="params">(x)</span>:</span></div><div class="line">  <span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">    <span class="keyword">return</span> x</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">return</span> x + recsum(x - <span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>当调用recsum(5)，Python调试器中发生如下状况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">recsum(5)</div><div class="line">5 + recsum(4)</div><div class="line">5 + (4 + recsum(3))</div><div class="line">5 + (4 + (3 + recsum(2)))</div><div class="line">5 + (4 + (3 + (2 + recsum(1))))</div><div class="line">5 + (4 + (3 + (2 + 1)))</div><div class="line">5 + (4 + (3 + 3))</div><div class="line">5 + (4 + 6)</div><div class="line">5 + 10</div><div class="line">15</div></pre></td></tr></table></figure></p>
<h2 id="这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。"><a href="#这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack-space-更新这个栈！而非扩展他-。" class="headerlink" title="这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。"></a>这个曲线就代表内存占用大小的峰值，从左到右，达到顶峰，再从右到左收缩。而我们通常不希望这样的事情发生，所以使用迭代，只占据常量stack space(更新这个栈！而非扩展他)。</h2><p>（一个替代方案：迭代）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">  sum += i</div></pre></td></tr></table></figure></p>
<p>因为Python，Java，Pascal等等无法在语言中实现尾递归优化(Tail Call Optimization, TCO)，所以采用了for, while, goto等特殊结构代替recursive的表述。Scheme则不需要这样曲折地表达，一旦写成尾递归形式，就可以进行尾递归优化。———————Python中可以写（尾递归）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tailrecsum</span><span class="params">(x, running_total=<span class="number">0</span>)</span>:</span></div><div class="line">  <span class="keyword">if</span> x == <span class="number">0</span>:</div><div class="line">    <span class="keyword">return</span> running_total</div><div class="line">  <span class="keyword">else</span>:</div><div class="line">    <span class="keyword">return</span> tailrecsum(x - <span class="number">1</span>, running_total + x)</div></pre></td></tr></table></figure></p>
<p>理论上类似上面：<br>tailrecsum(5, 0)<br>tailrecsum(4, 5)<br>tailrecsum(3, 9)<br>tailrecsum(2, 12)<br>tailrecsum(1, 14)<br>tailrecsum(0, 15)<br>15<br>观察到，tailrecsum(x, y)中形式变量y的实际变量值是不断更新的，对比普通递归就很清楚，后者每个recsum()调用中y值不变，仅在层级上加深。所以，尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> tailrec(x+<span class="number">1</span>);</div></pre></td></tr></table></figure></p>
<p>而<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> tailrec(x+<span class="number">1</span>) + x;</div></pre></td></tr></table></figure></p>
<p>则不可以。因为无法更新tailrec()函数内的实际变量，只是新建一个栈。但Python不能尾递归优化（Java不行，C可以，我不知道为什么），这里是用它做个例子。====================================如何优化尾递归：在编译器处理过程中生成中间代码（通常是三地址代码），用编译器优化<br>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/20761771/answer/19996299" target="_blank" rel="external">https://www.zhihu.com/question/20761771/answer/19996299</a><br>来源：知乎<br>最后对比一下没有用尾递归的阶乘代码和用了尾递归的阶乘代码：<br>用尾递归的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x,y)</span>:</span></div><div class="line">	<span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> y</div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> fact(x<span class="number">-1</span>,x*y)</div><div class="line"><span class="keyword">print</span> fact(<span class="number">5</span>,<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>普通递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></div><div class="line">	<span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> x * fact(x<span class="number">-1</span>)</div><div class="line"><span class="keyword">print</span> fact(<span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。<br>递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生”栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。<br>用普通递归写的那个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。<br>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。<br><img src="/images/algorithm/lyf.png" alt="Alt text"><br>由此可见，”尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署”尾调用优化”。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h2 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h2><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？<br>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">tailFactorial</span><span class="params">(n, total)</span> :</span></div><div class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</div><div class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span> :</span></div><div class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</div><div class="line"></div><div class="line"></div><div class="line">factorial(<span class="number">5</span>) // <span class="number">120</span></div></pre></td></tr></table></figure></p>
<p>第二种方法就简单多了，就是采用函数默认值。(java中没有函数默认值)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n, total = <span class="number">1</span>)</span> :</span></div><div class="line">  <span class="keyword">if</span> n === <span class="number">1</span> :</div><div class="line">      <span class="keyword">return</span> total</div><div class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total)</div><div class="line"></div><div class="line">factorial(<span class="number">5</span>) // <span class="number">120</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/C++/多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/09/C++/多态/" itemprop="url">
                  多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T15:59:21+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Upcatsting"><a href="#Upcatsting" class="headerlink" title="Upcatsting"></a>Upcatsting</h1><p>如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：<br>D-&gt;B  ：一个D的对象可以交给B的变量；<br>D<em>-&gt;B</em>：一个D的指针可以交给B的指针；<br>D&amp;-&gt;B&amp;：一个D的引用可以交给B的引用；<br>可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。<br><img src="/images/C++/多态1.png" alt="Alt text"><br>假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。<br>我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。<br><img src="/images/C++/多态2.png" alt="Alt text"><br>先看一下代码：<br><img src="/images/C++/多态3.png" alt="Alt text"><br>在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。<br>在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。<br><img src="/images/C++/多态4.png" alt="Alt text"><br>我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。<br><img src="/images/C++/多态5.png" alt="Alt text"><br>看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。<br>所以多态建立于两个事情的基础上：<br>第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。<br>第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。<br>    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。<br>    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。<br>这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。<br>然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。</p>
<h1 id="How-virtual-work-in-C"><a href="#How-virtual-work-in-C" class="headerlink" title="How virtual work in C++"></a>How virtual work in C++</h1><p><img src="/images/C++/多态4.png" alt="Alt text"><br>任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br>A::f() 10<br>16<br>238158040<br>它的大小是16<br>如果我们在改一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	p += <span class="number">2</span>; <span class="comment">// p++ 的结果是1</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>A::f() 10<br>16<br>10<br>说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">100</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a,b;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="keyword">int</span>* q = (<span class="keyword">int</span>*)&amp;b;</div><div class="line">    <span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p; <span class="comment">// p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果:<br>A::f() 100<br>16<br>134115552<br>134115552<br>0x7fe70e0<br>x是一个很小的值。<br>我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，<em>p和</em>q是一样的。<br>所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable<br>这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。</p>
<h1 id="Shape-VS-Ellipse"><a href="#Shape-VS-Ellipse" class="headerlink" title="Shape VS Ellipse"></a>Shape VS Ellipse</h1><p><img src="/images/C++/多态7.png" alt="Alt text"><br>我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;<br>再来看Circle<br><img src="/images/C++/多态8.png" alt="Alt text"><br>Circle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构<br>如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir<br><img src="/images/C++/多态9.png" alt="Alt text"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		B():j(<span class="number">20</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	B b;</div><div class="line">	A *p = &amp;b;</div><div class="line">	p-&gt;f(); <span class="comment">// B::f() 10</span></div><div class="line">	a = b;  </div><div class="line">	a.f();	<span class="comment">// A::f() 10</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>B::f() 10<br>A::f() 10<br>我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。<br>我们可以换一下vptr<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		B():j(<span class="number">20</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f() "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	B b;</div><div class="line">	A *p = &amp;a;</div><div class="line">	<span class="keyword">int</span>*r = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="keyword">int</span>*t = (<span class="keyword">int</span>*)&amp;b;</div><div class="line">	*r = *t;</div><div class="line">	p-&gt;f();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>B::f() 0<br>0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0<br>所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。</p>
<h2 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h2><p>在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。<br>注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/C++/reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/09/C++/reference/" itemprop="url">
                  reference
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T08:32:08+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Declaring-references"><a href="#Declaring-references" class="headerlink" title="Declaring references"></a>Declaring references</h1><p>reference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。<br><img src="/images/C++/reference1.png" alt="Alt text"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">	<span class="keyword">char</span>* p = &amp;c;</div><div class="line">	<span class="keyword">char</span>&amp; r =  c;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。<br>如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。<br><img src="/images/C++/reference2.png" alt="Alt text"><br>我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。</p>
<h2 id="Rules-of-references"><a href="#Rules-of-references" class="headerlink" title="Rules of references"></a>Rules of references</h2><p>定义reference的时候必须要初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>;</div><div class="line">f(y);   <span class="comment">// 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，</span></div><div class="line">        <span class="comment">// 因为你调用的时候不知道，传的是那个对象还是reference</span></div></pre></td></tr></table></figure></p>
<p><img src="/images/C++/reference3.png" alt="Alt text"><br>reference需要一个地方去放它，i<em>3有结果但是没有location，没有一个对方去放它。<br><img src="/images/C++/reference4.png" alt="Alt text"><br>References和Pointers做了一对比。<br>实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点</em>，所以做出来reference来。<br>在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个<em>号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个</em>号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/algorithm/选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/algorithm/选择排序/" itemprop="url">
                  选择排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T20:33:45+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序算法的时间复杂度是O(n2)<br>很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">list = [<span class="number">22</span>,<span class="number">12</span>,<span class="number">33</span>,<span class="number">121</span>,<span class="number">1</span>,<span class="number">333</span>,<span class="number">222</span>]</div><div class="line"><span class="comment"># 1.找出当前列表中的最小的数的下标</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinId</span><span class="params">(list)</span>:</span></div><div class="line">	minId  = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">		<span class="keyword">if</span> list[n] &lt; list[minId]:</div><div class="line">			minId = n</div><div class="line"></div><div class="line">	<span class="keyword">return</span> minId</div><div class="line"><span class="comment"># 2. 将最小的放在最前面</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(list)</span>:</span></div><div class="line">	newList = []</div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">		newList.append(list.pop(getMinId(list)))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> newList</div><div class="line"><span class="keyword">print</span> select(list)</div></pre></td></tr></table></figure></p>
<p>这个是我自己写的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">list = [<span class="number">1</span>,<span class="number">85</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">8</span>,<span class="number">64</span>,<span class="number">5</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinId</span><span class="params">(list)</span>:</span></div><div class="line">	minId = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,len(list)):</div><div class="line">		<span class="keyword">if</span>  list[n] &lt; list[minId]:</div><div class="line">			minId = n</div><div class="line">	<span class="keyword">return</span> minId</div><div class="line">newArray = []</div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">	a = getMinId(list)</div><div class="line">	newArray.append(list.pop(a))   <span class="comment"># list.pop[a] 将下标为a的元素从列表中删除</span></div><div class="line">	<span class="comment"># newArray.append(list[a])     # 等同这两行代码</span></div><div class="line">	<span class="comment"># del list[a]</span></div><div class="line"><span class="keyword">print</span> newArray</div></pre></td></tr></table></figure></p>
<p>这个是算法图解书上写的，思想上是一样的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jenius.jpeg"
               alt="Jenius" />
          <p class="site-author-name" itemprop="name">Jenius</p>
           
              <p class="site-description motion-element" itemprop="description">主要是学习后端技术，学过Java web、python web等后台技术</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jenius</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
