<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="主要是学习后端技术，学过Java web、python web等后台技术">
<meta property="og:type" content="website">
<meta property="og:title" content="jeniusLi's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="jeniusLi's blog">
<meta property="og:description" content="主要是学习后端技术，学过Java web、python web等后台技术">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jeniusLi's blog">
<meta name="twitter:description" content="主要是学习后端技术，学过Java web、python web等后台技术">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> jeniusLi's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jeniusLi's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活、技术个人博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/15/algorithm/递归/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/15/algorithm/递归/" itemprop="url">
                  递归
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-15T20:55:05+08:00">
                2017-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>算法图解作者写递归时写道：“我怀着激动的心情编写本章,因为它介绍的是递归——一种优雅的问题解决方法。递归是我 最喜欢的主题之一,它将人分成三个截然不同的阵营:恨它的、爱它的以及恨了几年后又爱上它 的。我本人属于第三个阵营。”<br>我学递归的时候是将递归分为两类；第一类直接递归，也就是自己调用自己。第二种间接递归，自己调用别人，别人在调用自己。<br>假设你在祖母的阁楼中翻箱倒柜,发现了一个上锁的神秘手提箱。<br>祖母告诉你,钥匙很可能在下面这个盒子里。<br><img src="/images/algorithm/recursive1.png" alt="Alt text"><br>这个盒子里有盒子,而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙,你将使 用什么算法?先想想这个问题,再接着往下看。<br>下面是一种方法。<br><img src="/images/algorithm/recursive2.png" alt="Alt text"><br>(1) 创建一个要查找的盒子堆。<br>(2) 从盒子堆取出一个盒子,在里面找。<br>(3) 如果找到的是盒子,就将其加入盒子堆中,以便以后再查找。 (4) 如果找到钥匙,则大功告成!<br>(5) 回到第二步。<br>下面是另一种方法。<br><img src="/images/algorithm/recursive3.png" alt="Alt text"><br>(1) 检查盒子中的每样东西。<br>(2) 如果是盒子,就回到第一步。<br>(3) 如果是钥匙,就大功告成!<br>在你看来,哪种方法更容易呢?第一种方法使用的是while循环:只要盒子堆不空,就从中 取一个盒子,并在其中仔细查找。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(main_box)</span>:</span></div><div class="line">    pile = main_box.make_a_pile_to_look_through()</div><div class="line">    <span class="keyword">while</span> pile <span class="keyword">is</span> <span class="keyword">not</span> empty:</div><div class="line">        box = pile.grab_a_box()</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> box:</div><div class="line">            <span class="keyword">if</span> item.is_a_box():</div><div class="line">                pile.append(item)</div><div class="line">            <span class="keyword">elif</span> item.is_a_key():</div><div class="line">                <span class="keyword">print</span> <span class="string">"found the key!"</span></div></pre></td></tr></table></figure></p>
<p>第二种方法使用递归——函数调用自己,这种方法的伪代码如下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for_key</span><span class="params">(box)</span>:</span></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> box:</div><div class="line">        <span class="keyword">if</span> item.is_a_box():</div><div class="line">            look_for_key(item) <span class="comment"># 递归</span></div><div class="line">        <span class="keyword">elif</span> item.is_a_key():</div><div class="line">            <span class="keyword">print</span> <span class="string">"found the key!"</span></div></pre></td></tr></table></figure></p>
<p>这两种方法的作用相同,但在我看来,第二种方法更清晰。递归只是让解决方案更清晰,并没有性能上的优势。实际上,在有些情况下,使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环,程序的性能可能更高;如果使用递归,程序可能<br> 更容易理解。如何选择要看什么对你来说更重要。”1 很多算法都使用了递归,因此理解这种概念很重要。递归显然是利用了函数，实现的。所以引入函数肯定会有一些overhead存在。这也就是为什么说用递归会比循环的性能要低一些。</p>
<h2 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h2><p> 由于递归函数调用自己,因此编写这样的函数时很容易出错,进而导致无限循环。<br> 如下：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">print</span> n</div><div class="line">	recursive(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">recursive(<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p> 会在console上打印：<br> <img src="/images/algorithm/recursive4.png" alt="Alt text"><br> 最后会退出，并且报错：maximum recursion depth exceeded while calling a Python object。<br> 中文意思大致是：在调用Python对象时，最大递归深度超出了最大递归深度。显然不停的调用函数，系统会给每一个函数都分配内存，如果一个递归没有基线调节，就会无限制的调用函数，就会造成内存溢出。<br> 所以编写递归函数时,必须告诉它何时停止递归。正因为如此,每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己,而基线条件则 指的是函数不再调用自己,从而避免形成无限循环。<br> 把上面的代码改一下，来给函数添加基线条件：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursive</span><span class="params">(n)</span>:</span></div><div class="line">	<span class="keyword">print</span> n</div><div class="line">	<span class="keyword">if</span> n &lt;=<span class="number">0</span> : <span class="comment"># 基线条件</span></div><div class="line">		<span class="keyword">return</span></div><div class="line">	<span class="keyword">else</span> :     <span class="comment"># 递归条件</span></div><div class="line">		recursive(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">recursive(<span class="number">10</span>)</div></pre></td></tr></table></figure></p>
<p> 输出结果：10到0<br><img src="/images/algorithm/recursive5.png" alt="Alt text"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>接下来将介绍重要的编程概念——调用栈(call stack)。调用栈不仅对编程来说很重要,使用递归时也必须理解这个概念。<br>栈简单来说就是先进后出，有两个操作进栈（push）和出栈（pop）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet2</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"how are you, "</span>+name + <span class="string">"!"</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bye</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"ok bye!"</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></div><div class="line">	<span class="keyword">print</span> <span class="string">"hello, "</span> + name +<span class="string">"!"</span></div><div class="line">	greet2(name)</div><div class="line">	<span class="keyword">print</span> <span class="string">"getting ready to say bye..."</span></div><div class="line">	bye()</div><div class="line"></div><div class="line">greet(<span class="string">'jenius'</span>)</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>hello, jenius!<br>how are you, jenius!<br>getting ready to say bye…<br>ok bye!<br>这个例子告诉我们函数的调用在内存中是怎么回事的，没调用一个函数都会压进栈，调用结束后出栈所以这也正好说明了函数中本地变量是没有值的，因为出栈的时候内存里的地址已经没了，因为出栈了，数据也就没有了。这是本节的一个重要概念:调用另一个函数时,当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。</p>
<h2 id="递归调用栈"><a href="#递归调用栈" class="headerlink" title="递归调用栈"></a>递归调用栈</h2><p>递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!,其<br>定义如下:5! = 5 <em> 4 </em> 3 <em> 2 </em> 1。同理,factorial(3)为3 <em> 2 </em> 1。下面是计算阶乘的递归函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></div><div class="line">	<span class="keyword">if</span> x == <span class="number">1</span>:</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span></div><div class="line">	<span class="keyword">else</span>:</div><div class="line">		<span class="keyword">return</span> x * fact(x<span class="number">-1</span>)</div><div class="line"><span class="keyword">print</span> fact(<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p><img src="/images/algorithm/recursive6.png" alt="Alt text"><br><img src="/images/algorithm/recursive7.png" alt="Alt text"><br> <strong>注意：</strong> 每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。<br>栈在递归中扮演着重要角色。在本章开头的示例中,有两种寻找钥匙的方法。下面再次列出 了第一种方法。<br><img src="/images/algorithm/recursive8.png" alt="Alt text"><br><img src="/images/algorithm/recursive9.png" alt="Alt text"><br>使用栈虽然很方便,但是也要付出代价:存储详尽的信息可能占用大量的内存。每个函数调 用都要占用一定的内存,如果栈很高,就意味着计算机存储了大量函数调用的信息。在这种情况 下,你有两种选择。</p>
<ul>
<li><strong>1</strong> ：重新编写代码,转而使用循环。</li>
<li><strong>2</strong> ：使用尾递归。这是一个高级递归主题,不在本书的讨论范围内。另外,并非所有的语言<br>都支持尾递归。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/C++/多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/09/C++/多态/" itemprop="url">
                  多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T15:59:21+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Upcatsting"><a href="#Upcatsting" class="headerlink" title="Upcatsting"></a>Upcatsting</h1><p>如果有两个类D类和B类，D类继承了B类，那么我们可以做出这样的一些类型转换：<br>D-&gt;B  ：一个D的对象可以交给B的变量；<br>D<em>-&gt;B</em>：一个D的指针可以交给B的指针；<br>D&amp;-&gt;B&amp;：一个D的引用可以交给B的引用；<br>可以做这个赋值，如果你有一个子类的对象，我们把它当作父类的对象来看了，那么这件事我们叫做Upcatst（向上造型）。<br><img src="/images/C++/多态1.png" alt="Alt text"><br>假设有一个场景，有长方形、椭圆、正方形、圆形，它们之间可能会有共同的成员变量和成员函数。所以它们会有联系。<br>我们有一个shape类，shape类有自己的center，这个center大家都有都要用到，它们都要继承shape类，所以shape类定义了center之后其他的类就不用定义了。不同的是render，不同的图形的render是不一样的。因此shape的render函数和其他图形的render函数得要有种联系。<br><img src="/images/C++/多态2.png" alt="Alt text"><br>先看一下代码：<br><img src="/images/C++/多态3.png" alt="Alt text"><br>在shape的render函数前面我们加了一个virtual（虚的），这个虚的意思是说将来shape类的所有的子类里面，如果它重新写了render（名称一样参数表也相同）那么这个render和子类里面的render就是有联系的。没有这个virtual这两个函数是没有关系的，有了这个virtual子类和父类同名的函数才有关系。<br>在ellipse里面它也有render，前面也加了virtual，不过这个virtual可加可不加，你不加virtual它也依然是virtual的。只要在它的继承树中间某一个祖先某个函数说是virtual了，以后子子孙孙这个函数都是virtual的，不管你说不说都是virtual的。但是把它放在这里是个好习惯，这样的话别人不用再去看shape了。看到ellipse就知道这个函数是virtual的了。<br><img src="/images/C++/多态4.png" alt="Alt text"><br>我们做这件事是为了这个例子，这个函数是说它要接收一个指针作为输入，然后让这个指针去做render，所以这个函数是通用函数。对任何shape的子类都是使用的，包括shape自己。这也意味这个render函数也适用于将来的新出现的shape的子类的对象。我现在写在这里，我可能还不知道shape有什么样子类，但是这个函数对将来可能出现的shape子类的对象也是适用的。你只要是shape的子类，你就一定会有render函数。<br><img src="/images/C++/多态5.png" alt="Alt text"><br>看一下func函数，我们可以做这样的一个事情，我们有一个ellipse的对象，ell.render()肯定是ellipse在render，然后我们做了一个Circle对象circ，circ.render()肯定是Circle在render，然后我们调用render函数把ellipse对象的地址给它。这个时候发生的是Upcatst向上造型。我们把一个ellipse的对象当作shape对象看待了，然后在那个render函数里面，把指针所指着的那个对象，做render的那个事情，那这个是谁render，是ellipse而不是shape因为这个函数是virtual的。virtual的函数就是在编译器说：对这个函数的调用如果说是通过指针或者引用的话，你就不能相信它一定是什么类型，得要到运行的时候才能确定。这个指针所指着那个对象是什么类型你再调那个类型的函数。这就是virtual的作用。告诉编译器说通过指针或者引用去调这个函数的时候，你不能直接就写进来调哪个函数，而要在运行的时候才能决定。所以你给他一个ellipse的对象它就做ellipse的render。给它一个Circle对象它就做Circle的render这件事就叫做Polymorphism,多态性。什么东西是多态的？p是多态的，因为p里面指着什么对象，通过p做的动作就是那个类型的对象做的，所以p指的是谁，它就指的那个形态，那叫做多态。<br>所以多态建立于两个事情的基础上：<br>第一个就是：Upcatst，向上造型，我们把一个子类当作父类的对象来看待。<br>第二个就是：Dynamic binding，动态绑定，绑定的意思指的是说，当我要去调一个函数的时候，我们究竟该调哪个函数，这叫做绑定。<br>    一种绑定叫做静态绑定，我调的那个函数是确定的，编译的时候就确定的，就知道的。<br>    第二种绑定叫做动态绑定，我要到运行的时候才知道，到底该调用哪个函数，根据我这个指针所指的那个对象来决定。<br>这件事可以这么理解：这个指针p有一个静态类型shape，但是同时它有一个动态类型，它当时指的那个对象的类型是什么。如果render函数是virtual的要看动态绑定，它的动态类型，如果不是virtual那么就是静态绑定，render是virtual的这取决于render而不是取决于p。<br>然后来说，c++的一切都是用c语言实现的，而且不会实现的太复杂。</p>
<h1 id="How-virtual-work-in-C"><a href="#How-virtual-work-in-C" class="headerlink" title="How virtual work in C++"></a>How virtual work in C++</h1><p><img src="/images/C++/多态4.png" alt="Alt text"><br>任何一个类如果有虚函数，只要有一个，这个类的对象就会比正常的大一点。我们先来验证这个事情。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果:<br>A::f() 10<br>16<br>238158040<br>它的大小是16<br>如果我们在改一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	p += <span class="number">2</span>; <span class="comment">// p++ 的结果是1</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>A::f() 10<br>16<br>10<br>说明一个问题，在i前面有一个8个字节的东西，那个东西是vptr，所有有virtual的类的对象里面最头上就会自动加上隐藏的指针，那个指针叫做vptr。它是一个指针它指向一张表叫做vtable，vtable里面是它所有的virtual函数的地址。这张vtable，不是这个对象的，是这个类的。所以这个类所有对象的vptr是应该一样的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">100</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a,b;</div><div class="line">	a.f();</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="keyword">int</span>* q = (<span class="keyword">int</span>*)&amp;b;</div><div class="line">    <span class="keyword">int</span>* x = (<span class="keyword">int</span>*)*p; <span class="comment">// p是一个指针，*p就是这个指针所指的那个地方，*p就是指针的值，然后我在把它当作指针</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果:<br>A::f() 100<br>16<br>134115552<br>134115552<br>0x7fe70e0<br>x是一个很小的值。<br>我们做了两个A的对象，然后取出两个对象第一个整数，发现它们是相同的；p和q是不一样的，<em>p和</em>q是一样的。<br>所以上面的那个Shape类就有了三个函数指针，任何一个Shape对象都会有三个vptr指向vtable<br>这样形成了动态绑定，其实动态绑定还是很快的，它只不过顺着这个vptr找到了vtable，然后找到了这个东西。</p>
<h1 id="Shape-VS-Ellipse"><a href="#Shape-VS-Ellipse" class="headerlink" title="Shape VS Ellipse"></a>Shape VS Ellipse</h1><p><img src="/images/C++/多态7.png" alt="Alt text"><br>我们比较一下Shape的对象有vptr指向自己的vtable，Ellipse的对象有vptr指向自己的vtable;<br>再来看Circle<br><img src="/images/C++/多态8.png" alt="Alt text"><br>Circle中添加了一个virtual函数，所以Circle的vtable大了一项，但是前面三个维持了ellipse一样的结构<br>如果我们创建了一个Ellipse的对象ell 创建Circle的对象cir让rll = cir<br><img src="/images/C++/多态9.png" alt="Alt text"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		B():j(<span class="number">20</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	B b;</div><div class="line">	A *p = &amp;b;</div><div class="line">	p-&gt;f(); <span class="comment">// B::f() 10</span></div><div class="line">	a = b;  </div><div class="line">	a.f();	<span class="comment">// A::f() 10</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>B::f() 10<br>A::f() 10<br>我们再说Polymorphism的时候，你得是通过指针，或者是引用来调用这个virtual函数，他才会是动态绑定，通过.去调用它不会是动态绑定的。<br>我们可以换一下vptr<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">10</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::f() "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B : <span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		B():j(<span class="number">20</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"B::f() "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	A a;</div><div class="line">	B b;</div><div class="line">	A *p = &amp;a;</div><div class="line">	<span class="keyword">int</span>*r = (<span class="keyword">int</span>*)&amp;a;</div><div class="line">	<span class="keyword">int</span>*t = (<span class="keyword">int</span>*)&amp;b;</div><div class="line">	*r = *t;</div><div class="line">	p-&gt;f();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果：<br>B::f() 0<br>0是指j不存在，只是vptr被交换了，a的vptr找到了b的vtable，所以调用的是b的f，但是对象还是a的对象，a里面没有那个j所以默认初始化为0<br>所有的OOP语言默认都是virtual的，也就是说默认是做动态绑定的，只有C++默认是静态绑定，然后才能做成它是静态绑定的。而其他的OOP语言默认是动态绑定的，C++因为效率才会这么干的。因为静态绑定快，虽然我们动态绑定也挺快的，几个指针就过去了，但毕竟是几个指针才过去。静态绑定，是编译时刻就做在那里的，所以静态绑定会快很多。C++追求效率所以默认是静态绑定，那其他语言追求OOP的语义，OOP就应该是动态的。</p>
<h2 id="Overriding"><a href="#Overriding" class="headerlink" title="Overriding"></a>Overriding</h2><p>在C++中子类和父类的一个函数是virtual的，并且函数名称相同，参数也相同，那么它们构成了一种关系叫做Override，Override这个中文可以叫做覆盖或者改写。<br>注意如果Override和overload同时存在，子类必须Override所有父类的虚函数，否则就会发生namehiding。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/C++/reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/09/C++/reference/" itemprop="url">
                  reference
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T08:32:08+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Declaring-references"><a href="#Declaring-references" class="headerlink" title="Declaring references"></a>Declaring references</h1><p>reference中文我们叫做引用，C++复杂就复杂在于，它提供了太多的内存模型。或者说它提供了太多的两种东西，第一种东西是它提供了太多的可以放对象的地方，C++的对象可以放在栈里面，可以放在堆里面，可以放在全局数据区里面，这是第一种复杂。第二种复杂它提供了太多的让你可以访问对象的方式，你可以直接掌握那个对象，也就是说你的变量里面可以放的是对象，你可以通过指针去访问一个对象，你可以通过引用去访问一个对象。所以我们有三种放对象的地方，我们有三种访问对象的方式，把它们乘起来，我们有九种组合。<br><img src="/images/C++/reference1.png" alt="Alt text"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> c;</div><div class="line">	<span class="keyword">char</span>* p = &amp;c;</div><div class="line">	<span class="keyword">char</span>&amp; r =  c;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个时候我们用r也就是在用c，reference也可以叫alias（别名），而现在的r就是c的一个alias别名。<br>如果是在参数表里面或者是作为成员变量，那个时候它才没有后面的那个初始化。<br><img src="/images/C++/reference2.png" alt="Alt text"><br>我们对reference有两种理解，第一种字面上的理解就是这个y就是x的另外一种名字，以后任何地方出现y你都可以将它替换成x，因此当y=18发生的时候，就是说x=18，然后输出x的值，那个值就是18了。</p>
<h2 id="Rules-of-references"><a href="#Rules-of-references" class="headerlink" title="Rules of references"></a>Rules of references</h2><p>定义reference的时候必须要初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; x)</span></span>;</div><div class="line">f(y);   <span class="comment">// 给参数列表初始化，但是如果在f函数中改变了x的值，那么外面的y的值也会改变，这就很邪恶了，</span></div><div class="line">        <span class="comment">// 因为你调用的时候不知道，传的是那个对象还是reference</span></div></pre></td></tr></table></figure></p>
<p><img src="/images/C++/reference3.png" alt="Alt text"><br>reference需要一个地方去放它，i<em>3有结果但是没有location，没有一个对方去放它。<br><img src="/images/C++/reference4.png" alt="Alt text"><br>References和Pointers做了一对比。<br>实际上reference是通过pointer的方式实现的，reference就是const的pointer，当年BS为了让代码少一点</em>，所以做出来reference来。<br>在这里讲一点java，java的内存模型要比C++简单很多。java对象只有一个地方可以放，所有的对象只能放在堆里面，然后只有一种方式可以去访问那个对象，就是通过指针，但是它只有通过指针去访问对象，所以它可以把指针的那个<em>号取消掉，然后它对别人说我这个不叫指针叫做引用。但其实它和C++的引用是不一样的，它更像是C++的指针，因为引用是不能做引用之间的赋值的，java是可以的，所以java尽管它的文献里都叫做引用，但实际上它是指针。但是java的指针和C++的指针区别在哪里。一、外形上没有了那个</em>号；二、那个指针是不能做计算的。C/C++的指针最大的问题是可以做计算的，做完计算之后就不知道在哪了，你就不知道它指的是不是对的，java把这个取消掉了。java就把内存模型做的简单点，事实上内存模型并不需要这么复杂，C++能做的是java也能做，唯一一个说C++能做而java不能做的事情，不是因为复杂的内存模型，而是C++中C的特性，因为它可以直接去访问底层的那些东西。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/algorithm/选择排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/algorithm/选择排序/" itemprop="url">
                  选择排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T20:33:45+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序算法的时间复杂度是O(n2)<br>很显然是两个循环嵌套，大概可以写两个函数，完成两个功能来完成，第一个函数每一次选出一个列表或数组中最小的，第二个函数是将选出来的最小的放到另外一个新新组或列表中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">list = [<span class="number">22</span>,<span class="number">12</span>,<span class="number">33</span>,<span class="number">121</span>,<span class="number">1</span>,<span class="number">333</span>,<span class="number">222</span>]</div><div class="line"><span class="comment"># 1.找出当前列表中的最小的数的下标</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinId</span><span class="params">(list)</span>:</span></div><div class="line">	minId  = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">		<span class="keyword">if</span> list[n] &lt; list[minId]:</div><div class="line">			minId = n</div><div class="line"></div><div class="line">	<span class="keyword">return</span> minId</div><div class="line"><span class="comment"># 2. 将最小的放在最前面</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(list)</span>:</span></div><div class="line">	newList = []</div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">		newList.append(list.pop(getMinId(list)))</div><div class="line"></div><div class="line">	<span class="keyword">return</span> newList</div><div class="line"><span class="keyword">print</span> select(list)</div></pre></td></tr></table></figure></p>
<p>这个是我自己写的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">list = [<span class="number">1</span>,<span class="number">85</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">11</span>,<span class="number">33</span>,<span class="number">55</span>,<span class="number">8</span>,<span class="number">64</span>,<span class="number">5</span>]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">getMinId</span><span class="params">(list)</span>:</span></div><div class="line">	minId = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,len(list)):</div><div class="line">		<span class="keyword">if</span>  list[n] &lt; list[minId]:</div><div class="line">			minId = n</div><div class="line">	<span class="keyword">return</span> minId</div><div class="line">newArray = []</div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(len(list)):</div><div class="line">	a = getMinId(list)</div><div class="line">	newArray.append(list.pop(a))   <span class="comment"># list.pop[a] 将下标为a的元素从列表中删除</span></div><div class="line">	<span class="comment"># newArray.append(list[a])     # 等同这两行代码</span></div><div class="line">	<span class="comment"># del list[a]</span></div><div class="line"><span class="keyword">print</span> newArray</div></pre></td></tr></table></figure></p>
<p>这个是算法图解书上写的，思想上是一样的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/05/C++/Const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/05/C++/Const/" itemprop="url">
                  Const
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T12:50:51+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h1><p>在C语言当中的，这个变量加上一个Const关键字之后，这个变量被初始化之后呢，就不能赋值。<br><img src="/images/C++/const1.png" alt="Alt text"><br>但是由于指针的存在，就出现一个问题，就是这个const是修饰谁的，比如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	*p = <span class="number">2</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会在第9行报错，error: read-only variable is not assignable<br>说这个变量是只读的，变量是不能被赋值的。<br>说明这个指针所指的这个对象是const的是不能被修改的，但是指针变量还是可以修改的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	p++;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没有报错。我们再看两个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">	<span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	*p = <span class="number">2</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个没有报错，输出是：<br>10<br>2<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">	<span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	p++;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个报错了，error: cannot assign to variable ‘p’ with const-qualified type ‘int <em>const’<br>说不能对变量p赋值，因为这个指针p是被const修饰的，是类型’int </em>const’<br>这个指针p所指向的那个变量的值被修改了，但是p不能被修改，说明这个const修饰的是指针变量p，所以指针变量p不能被修改。<br>这就有一个问题了，怎么区分呢？其实有一个小技巧<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">// 看这个*号，const在星号左边说明是指针所指的那个变量是const的</span></div><div class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i; <span class="comment">// const在星号右边说明这个指针p是const的</span></div></pre></td></tr></table></figure></p>
<p>当然你可以都让它们是const的，让指针是const的同时，让指针所指的那个变量（内存空间）也都是const<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;</div><div class="line">	p++;  <span class="comment">// 这里会有错，error: cannot assign to variable 'p' with const-qualified type 'int *const'</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	*p = <span class="number">2</span>; <span class="comment">// 这里会有错，error: read-only variable is not assignable</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样两个变量都是const的了<br>接下来再试一件事情<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">char</span> *s = <span class="string">"hello world"</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	s[<span class="number">0</span>] = <span class="string">'B'</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我 g++ 了一下，有一个warning:<br><img src="/images/C++/const2.png" alt="Alt text"><br>如果我先无视这个warning ./a.out 一下<br><img src="/images/C++/const3.png" alt="Alt text"><br>它输出了这个 hello world 之后程序异常终止了。<br>前面的那个warning 的意思是说：conversion from string literal to ‘char <em>‘ is deprecated<br>说这事已经过时了，这个意思是说你想将”hello world”这个字符串交给char </em>是不对的，做了修改之后程序就崩溃了。<br>实际上事情是这样的，s在栈里面，因为是本地变量（本地变量和函数的参数列表的变量都在栈里面）s是一个指针，它指向了一块内存，也就是说”hello world”是一块内存，内存又分为三种不同的地方，本地变量是放在，栈里面，new出来的东西是放在堆里面，然后全局变量在一个全局数据区里面。而全局变量里面的这种常量，是在代码段里的，因为”hello world”是一个常量，所以尽管我们没有在s前面加上const，实际上它是const的。它被放在了代码段里面，而代码段是不可写的。现在说有的操作系统，都是葱花1970年代出得那个Unix，现代操作系统的基本理论是从那里来的，所以不管外表是什么样，里面东西是一样的。你的程序运行起来之后，你的程序会从操作系统得到一块内存，这块内存当然是虚拟的，但是这块内存是独立的，每个进程，每个程序都有独立的内存。每块内存从0开始，在计算机的内部有一个计算机的硬件，MMU内存管理单元。由它来管这件事情，它会划分，从0开始到0x000xxx是代码段，如果你去试图去写这个代码段，就会有错：Bus error，实际上是MMU的地方出了错。<br>这是这件事情，假如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// char *s = "hello world";</span></div><div class="line">	<span class="keyword">char</span> s[] = <span class="string">"hello world"</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	s[<span class="number">0</span>] = <span class="string">'B'</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br>hello world<br>Bello world<br>没有warning、没有error<br>说明了 char[] s = “hello world”;<br>做了一件事，将代码段里的”hello world” 复制到栈里面了，存在本地变量里面。<br>可以写一个程序来验证。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *s1 = <span class="string">"hello world"</span>;</div><div class="line">	<span class="keyword">char</span> s2[] = <span class="string">"hello world"</span>;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"s1  =%p\n"</span>,s1);</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"s2  =%p\n"</span>,s2);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"main=%p\n"</span>,main;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>之后我们编译运行一下输出：<br><img src="/images/C++/const4.png" alt="Alt text"><br>明显地址是不同的，char *s1 是比较靠前的地址，所以它在代码段里的<br>同时也看了main函数的地址，也是比较靠前的</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/algorithm/算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/01/algorithm/算法/" itemprop="url">
                  二分法查询
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T15:50:51+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h1><p>最近在学python学完之后，想做点东西巩固一下python的语法，无意间在知乎上看到有人推荐算法图解这本书，讲了一些算法关键我是看到它的代码使用python写的，正好在巩固python的语法的同时将算法好好学一下。</p>
<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>下面的示例说明了二分查找的工作原理。我随便想一个1~100的数字。<br>你的目标是以最小的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。<br>假设你从1开始依次网上猜，猜测过程会是这样。<br>也就是我们所说的遍历，这是简单查找，更准确的说法是傻栈。每猜测都只能排除一个数字。如果我想的数字是99，你得猜99次才能猜到！</p>
<h3 id="更佳的查找方法"><a href="#更佳的查找方法" class="headerlink" title="更佳的查找方法"></a>更佳的查找方法</h3><p>下面是一种更佳的猜法。从50开始。<br><img src="/images/algorithm/1.png" alt="Alt text"><br><img src="/images/algorithm/2.png" alt="Alt text"><br>因此,使用二分查找只需18步——少多了!一般而言,对于包含n个元素的列表,用二分查<br>找最多需要log2n步,而简单查找最多需要n步。<br><img src="/images/algorithm/3.png" alt="Alt text"><br>下面是我自己写的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">list = []</div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>) : <span class="comment"># 先给这个列表赋值，1到100</span></div><div class="line">	list.append(n)</div><div class="line">left = <span class="number">0</span>  <span class="comment"># 第一个节点</span></div><div class="line">right = len(list)<span class="number">-1</span> <span class="comment"># 最后一个节点</span></div><div class="line">mid = int((left + right) / <span class="number">2</span>) <span class="comment"># 中间节点</span></div><div class="line">number = input(<span class="string">'plase input a number:\n'</span>) <span class="comment"># 这要注意一点python2 当中 input 输入的数字就是数字而python3 中输入数字会变成字符串</span></div><div class="line">number = int(number)</div><div class="line"><span class="keyword">while</span> list[mid] != number <span class="keyword">and</span> left &lt; right: <span class="comment"># 如果输入的数字不是中间节点，并且整个列表没有查询完进入循环</span></div><div class="line">	<span class="keyword">if</span> number&gt;list[mid]:    <span class="comment"># 如果数字大于中间节点，我们就把中间节点之前的所有都丢弃（不在前半部分）</span></div><div class="line">		left = mid +<span class="number">1</span>	    <span class="comment"># 让最左节点成为原来节点的后继节点</span></div><div class="line">	<span class="keyword">elif</span>  number&lt;list[mid]: <span class="comment"># 如果数字小于中间节点，我们就把中间节点之后的所有都丢弃（不在后半部分）</span></div><div class="line">		right = mid - <span class="number">1</span>		<span class="comment"># 让最右节点成为原来节点的前驱节点</span></div><div class="line">	mid = int((left + right) / <span class="number">2</span>) <span class="comment"># 每一次循环将mid重新赋值</span></div><div class="line">	print(<span class="string">'left= %d'</span>%left)</div><div class="line">	print(<span class="string">'right= %d'</span>%right)</div><div class="line"><span class="keyword">if</span> list[mid] == number:</div><div class="line">	print(<span class="string">'找到了 是第%d个元素。'</span>%(mid+<span class="number">1</span>))</div><div class="line"><span class="keyword">else</span>  :</div><div class="line">	print(<span class="string">'没找到'</span>)</div></pre></td></tr></table></figure></p>
<p>下面是书上的的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">list = []</div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>) :</div><div class="line">	list.append(n)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(list,item)</span>:</span></div><div class="line">		low = <span class="number">0</span></div><div class="line">		high = len(list) - <span class="number">1</span></div><div class="line"></div><div class="line">		<span class="keyword">while</span> low &lt;= high:</div><div class="line">			mid =  (low + high) / <span class="number">2</span></div><div class="line">			guess = list[mid]</div><div class="line">			<span class="keyword">if</span> guess == item :</div><div class="line">				<span class="keyword">return</span> mid</div><div class="line">			<span class="keyword">if</span> guess &gt; item:</div><div class="line">				high = mid <span class="number">-1</span></div><div class="line">			<span class="keyword">else</span> :</div><div class="line">				low = mid + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> binary_search(list,<span class="number">11</span>) != <span class="keyword">None</span> :</div><div class="line">	print(list[binary_search(list,<span class="number">11</span>)])</div></pre></td></tr></table></figure></p>
<p><img src="/images/algorithm/4.png" alt="Alt text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/C++/C++内联函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/25/C++/C++内联函数/" itemprop="url">
                  C++内联函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-25T12:47:36+08:00">
                2017-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Overhead-for-a-function-call"><a href="#Overhead-for-a-function-call" class="headerlink" title="Overhead for a function call"></a>Overhead for a function call</h1><ul>
<li><p><strong>the processing time required by a device prior to the execution of a command</strong>:</p>
<ul>
<li><p><strong>Push parameters</strong>: 将函数的参数推到栈里面去</p>
</li>
<li><p><strong>Push return address</strong>:把返回地址推到栈里面去</p>
</li>
<li><strong>Prepare return values</strong>:准备返回的值</li>
<li><strong>Pop all pushed</strong>:把所有推进栈里面的东西都赶出来<h1 id="inline-Function"><a href="#inline-Function" class="headerlink" title="inline Function"></a>inline Function</h1>上述这么多额外的事情，可以用一个手段来避免产生这些额外的开销<br>C++给我们提供了一种方式，就是内联函数。内联函数我们在调用它的时候，并不是会产生那些动作（push,pop,return,call），<br>而是把那个函数的代码嵌入到那个地方去，但是仍然保持函数的独立性（函数独有的空间，对参数类型的检查等）。<br>当然，如果你的函数是inline的，这个函数就不会出现在最终的可执行代码里面。它只会出现在编译器里面。<br>如果你想写函数是inline的话，在.h和.cpp必须都要在函数前面写上inline。实际上.h和.cpp是写给不同人看的，<br>.cpp是用来产生那个函数的，.h是用来给调用这个函数的地方看的。.cpp里面有没有inline是让编译器生成不生成这个函数的，有inline就不生成这个函数。头文件里面的inline是告诉，这个地方你不能生成调用它的那个代码，要把函数体拆进来。<h2 id="代码-main-cpp"><a href="#代码-main-cpp" class="headerlink" title="代码 main.cpp"></a>代码 main.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">	f(<span class="number">10</span>,<span class="number">10</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="代码-a-cpp"><a href="#代码-a-cpp" class="headerlink" title="代码 a.cpp"></a>代码 a.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="代码-a-h"><a href="#代码-a-h" class="headerlink" title="代码 a.h"></a>代码 a.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</div></pre></td></tr></table></figure>
<p>出错信息：<br><img src="/images/C++/inline1.png" alt="Alt text"><br>这个warning说这个函数是inline的但是却没有定义。linker说main.cpp要用的这个f函数不存在。<br>我们可以cpp main.cpp 看一下。cpp 这个命令是编译预处理器。<br><img src="/images/C++/inline2.png" alt="Alt text"><br>编译器在编译的时候是按照，每一个编译单元去编译的，也就是每一个文件去编译。<br>通过cpp可以看到并没有定义函数体，所以是没有办法插进去的。所以只能放弃将f函数做内联。<br>而a.o中没有产生任何代码因为它是inline的，所以a.o中没有f函数的痕迹在的，当link的时候就出现问题了<br>main.cpp说我要个f函数，然后a.cpp里又没有f函数。所以我们应该把f函数的body放在a.h里面去。</p>
<h2 id="代码-a-h-1"><a href="#代码-a-h-1" class="headerlink" title="代码 a.h"></a>代码 a.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"  "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译过了，运行也正常了<br>所以这是一种权衡（tradeoff）<br>有inline之后，对于之前的用法就会不一样，之前的用法是说你的每一个类应该会有对应的.cpp和对应的一个.h，.h里面放的是声明，而.cpp里放的是定义。<br>而inline函数这种函数的定义就不再是个定义，而是个声明，因此它不能放.cpp，只放在.h就够了。所以对应上面的代码来说，不需要有a.cpp有a.h就够了.h把所有inline的函数的body都放进去，就可以了。<br>对于inline函数而言，用inline函数就意味着，在这个函数被调用的时候，函数的代码会被插入到被调用的地方，这也意味着你的代码会变长程序会变大，因此它会牺牲代码的空间但是它会降低调用函数的overhead（额外的开销），这是典型的以空间换时间的策略。<br>这种方式比C的宏要好，C的宏不会进行类型检查，而inline会进行类型检查，所以inline比宏要好要安全。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>但是编译器也会做一个这样的事情，它如果发现你的inline函数过于巨大它可能会拒绝这个inline函数作为inline（inline函数内部做了很复杂的循环或者内部做了递归）<br>如果是成员函数<br>例如这个<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"f()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>f函数体直接写在后面了，这样就不用在写.cpp了只要写一个.h就可以了<br>放在头文件里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> A::f()&#123;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"f()"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以加了inline这个函数就不是定义而是声明，然后他不在class里面，而在class外面。<br>这样做的好处是，class会很清爽。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/24/python/SSHClient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/24/python/SSHClient/" itemprop="url">
                  SSHClient
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-24T18:56:22+08:00">
                2017-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SSHClient"><a href="#SSHClient" class="headerlink" title="SSHClient"></a>SSHClient</h1><p>用于连接远程服务器并执行基本命令</p>
<h2 id="基于用户名密码连接："><a href="#基于用户名密码连接：" class="headerlink" title="基于用户名密码连接："></a>基于用户名密码连接：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> paramiko</div><div class="line"></div><div class="line"><span class="comment"># 创建SSH对象</span></div><div class="line">ssh = paramiko.SSHClient()</div><div class="line"><span class="comment"># 允许连接不在know_hosts文件中的主机</span></div><div class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class="line"><span class="comment"># 连接服务器</span></div><div class="line">ssh.connect(hostname=<span class="string">'10.10.39.213'</span>, port=<span class="number">22</span>, username=<span class="string">'username'</span>, password=<span class="string">'password'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 执行命令</span></div><div class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">'ls ./aa'</span>)</div><div class="line"><span class="comment"># 获取命令结果</span></div><div class="line">result = stdout.read()</div><div class="line">print(result)</div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">ssh.close()</div></pre></td></tr></table></figure>
<p>输出结果：<br>b’redis-3.2.8\nredis-3.2.8.tar.gz\n’<br>我用的是我们实验室里面的一台主机，\n是换行。</p>
<h2 id="Linux中ssh-第一次登陆某台主机的时候会出现："><a href="#Linux中ssh-第一次登陆某台主机的时候会出现：" class="headerlink" title="Linux中ssh 第一次登陆某台主机的时候会出现："></a>Linux中ssh 第一次登陆某台主机的时候会出现：</h2><p><img src="/images/python/ssh6.png" alt="Alt text"><br>如果输入yes就会在,该用户的根目录下.ssh/known_hosts，这个文件中多了一条<br><img src="/images/python/ssh7.png" alt="Alt text"><br>所以<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div></pre></td></tr></table></figure></p>
<p> 这句话就是相当于把那个密钥加到.ssh/known_hosts 这里面<br>顺便Linux之间可以用scp这个命令来上传下载文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -rp ssh.py ssh_oj@10.10.39.213:/tmp/</div></pre></td></tr></table></figure></p>
<p>上面是带两个参数，第一个参数r，是指目录，就是它是个目录也可以copy。<br>第二个参数是p，p是权限。就是说copy到另外一台主机之后，这个文件也会拥有在本机相同的权限。<br>ssh_oj指的是用户名，10.10.39.213是指主机的ip地址<br>/tmp/ 是将文件copy到那个目录。<br>结果:<br><img src="/images/python/ssh1.png" alt="Alt text"><br>在登上该主机：<br><img src="/images/python/ssh2.png" alt="Alt text"><br>有了这个文件<br>如果ssh的默认端口号不是22，可以改端口号通过-P<br><img src="/images/python/ssh3.png" alt="Alt text"><br>上面的端口是52113</p>
<h2 id="在SSHClient实现文件上长传下载"><a href="#在SSHClient实现文件上长传下载" class="headerlink" title="在SSHClient实现文件上长传下载"></a>在SSHClient实现文件上长传下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> paramiko</div><div class="line"></div><div class="line">transport = paramiko.Transport((<span class="string">'hostname'</span>,<span class="number">22</span>))</div><div class="line">transport.connect(username=<span class="string">'username'</span>,password=<span class="string">'password'</span>)</div><div class="line"></div><div class="line">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class="line"><span class="comment"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class="line">sftp.put(<span class="string">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class="string">'/tmp/ssh.py'</span>)</div><div class="line"><span class="comment"># 将remove_path 下载到本地 local_path</span></div><div class="line">sftp.get(<span class="string">'remove_path'</span>, <span class="string">'local_path'</span>)</div><div class="line"></div><div class="line">transport.close()</div></pre></td></tr></table></figure>
<p>结果：<br><img src="/images/python/ssh4.png" alt="Alt text"></p>
<h2 id="使用ssh公钥密钥自动登陆linux服务器"><a href="#使用ssh公钥密钥自动登陆linux服务器" class="headerlink" title="使用ssh公钥密钥自动登陆linux服务器"></a>使用ssh公钥密钥自动登陆linux服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# ssh-keygen -b 1024 -t rsa</div><div class="line">Generating public/private rsa key pair.     #提示正在生成rsa密钥对</div><div class="line">Enter file in which to save the key (/home/usrname/.ssh/id_dsa):     #询问公钥和私钥存放的位置，回车用默认位置即可</div><div class="line">Enter passphrase (empty for no passphrase):     #询问输入私钥密语，输入密语</div><div class="line">Enter same passphrase again:     #再次提示输入密语确认</div><div class="line">Your identification has been saved in /home/usrname/.ssh/id_dsa.     #提示公钥和私钥已经存放在/root/.ssh/目录下</div><div class="line">Your public key has been saved in /home/usrname/.ssh/id_dsa.pub.</div><div class="line">The key fingerprint is:</div><div class="line">x6:68:xx:93:98:8x:87:95:7x:2x:4x:x9:81:xx:56:94 root@server     #提示key的指纹</div></pre></td></tr></table></figure>
<p>简单说明一下：<br>-b 1024　采用长度为1024字节的公钥/私钥对，最长4096字节，一般1024或2048就足够满足安全需要了，太长的话加密解密需要的时间也增长。<br>-t rsa　 采用rsa加密方式的公钥/私钥对，除了rsa还有dsa方式，rsa方式最短不能小于768字节长度。<br>如果还需要使用更多其他参数请参考man ssh-keygen。<br>         在生成密钥对的过程中你被询问：输入密码短句 Enter passphrase (empty for no passphrase) ，密码短句（passphrase）是你使用一个短语或者一句话作为密码输入，再由系统内部的加密或是散列算法生成虚拟密码后，进行下一步的认证。好处是增强了安全性不易被破解。看过很多文章，里面都把这个短句输入为空，也就是代表不使用密码短句。在这里我强烈要求你输入密码短句。有人会说使用密码短句后，登陆还要输入密码短句这样使用没有比使用用户名和密码登陆方便多少，我说请你不要急，接着看我的文章。</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>如果你生成密钥对而不设置密码短语，那么如果你的私钥丢失了，那么就你的麻烦可能会比丢失用户名密码还严重。<br>第二步：拷贝你的公钥到被管理的服务器上<br>在你的管理服务器上把你的公钥拷贝到被管理服务器上要进行自动登陆的用户目录下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# scp .ssh/id_dsa.pub remote_usrname@192.168.0.2:      #比如你想使用用户peter登陆，则remote_usrname请以peter代替</div></pre></td></tr></table></figure></p>
<p>改名和进行权限设置<br>    登陆被管理的服务器，进入需要远程登陆的用户目录，把公钥放到用户目录的 .ssh 这个目录下（如果目录不存在，需要创建~/.ssh目录，并把目录权限设置为700），把公钥改名为authorized_keys2，并且把它的用户权限设成600。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">[peter@client ~]$ ls</div><div class="line">id_rsa.pub</div><div class="line">[peter@client ~]$ mkdir ~/.ssh     #如果当前用户目录下没有 .ssh 目录，请先创建目录</div><div class="line">[peter@client ~]$ chmod 700 ~/.ssh</div><div class="line">[peter@client ~]$ mv id_rsa.pub ~/.ssh</div><div class="line">[peter@client ~]$ cd ~/.ssh</div><div class="line">[peter@client ~]$ cat id_rsa.pub &gt;&gt; authorized_keys2</div><div class="line">[peter@client ~]$ rm -f id_rsa.pub</div><div class="line">[peter@client ~]$ chmod 600 authorized_keys2</div><div class="line">[peter@client ~]$ ls -l</div><div class="line">total 4</div><div class="line">-rw-------  1 peter peter 225 Oct 10 11:28 authorized_keys2</div><div class="line">```    </div><div class="line">测试使用密钥对进行远程登陆</div><div class="line">```Linux</div><div class="line">[root@server ~]# ssh peter@192.168.0.2</div><div class="line">Enter passphrase for key &apos;/root/.ssh/id_rsa&apos;:      #提示输入密码短语，请输入刚才设置的密码短语</div><div class="line">Last login: Sun Oct 10 11:32:14 2010 from 192.168.0.1</div><div class="line">[peter@client ~]$</div></pre></td></tr></table></figure></p>
<p>如果你不能用正确的登录，应该重新检查一下你的authorized_keys2的权限。也可能要检查.ssh目录的权限。<br>使用 ssh-agent（ssh代理）自动输入密码短语<br>牢记你的“密码短句”，现在你可以用你的密钥而不是密码来登录你的服务器了，但是这样仍然没有省什么事，你还是要输入密钥的“密码短语”。有更简便的方法吗？答案就是采用SSH代理（ssh-agent），一个用来帮你记住“密码短语”的程序。 ssh-agent是OpenSSH中默认包括的ssh代理程序。<br>登陆管理服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# ssh-agent</div><div class="line">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class="line">SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class="line">echo Agent pid 2148;</div></pre></td></tr></table></figure></p>
<p>当你运行ssh-agent，它会打印出来它使用的 ssh 的环境和变量。要使用这些变量，有两种方法，一种是手动进行声明环境变量，另一种是运行eval命令自动声明环境变量。<br>方法一：手动声明环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147; export SSH_AUTH_SOCK;</div><div class="line">[root@server ~]# SSH_AGENT_PID=2148; export SSH_AGENT_PID;</div><div class="line">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class="line">SSH_AGENT_PID=2148</div><div class="line">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>
<p>方法二：运行eval命令自动声明环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# eval `ssh-agent`</div><div class="line">Agent pid 2157</div><div class="line">[root@server ~]# printenv | grep SSH     #检查 ssh 环境变量是否已经加入当前会话的环境变量</div><div class="line">SSH_AGENT_PID=2148</div><div class="line">SSH_AUTH_SOCK=/tmp/ssh-vEGjCM2147/agent.2147</div></pre></td></tr></table></figure></p>
<p>现在 ssh-agent 已经在运行了，但是 ssh-agent 里面是空白的不会有解密的专用密钥。我们要告诉它我们有私钥和这个私钥在哪儿。这就需要使用 ssh-add 命令把我们的专用密钥添加到 ssh-agent 的高速缓存中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# ssh-add ~/.ssh/id_dsa</div><div class="line">Enter passphrase for /home/user/.ssh/id_dsa:     #输入你的密码短语</div><div class="line">Identity added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa)</div><div class="line">[root@server ~]# ssh-add -l     #查看 ssh代理的缓存内容</div><div class="line">1024 72:78:5e:6b:16:fd:f2:8c:81:b1:18:e6:9f:77:6e:be /root/.ssh/id_rsa (RSA)</div></pre></td></tr></table></figure></p>
<p>输入了密码短句，现在好了，你可以登录你的远程服务器而不用输入你的密码短语了，而且你的私钥是密码保护的。试试看是不是很爽！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[root@server ~]# ssh peter@192.168.0.2</div><div class="line">Last login: Sun Oct 10 11:32:45 2010 from 192.168.0.1</div><div class="line">[peter@client ~]$</div></pre></td></tr></table></figure></p>
<p>登陆服务器进行操作结束后，记得还要把 ssh-agent 关掉，不然其他人登陆后也可以远程了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@server ~]# ssh-agent -k</div><div class="line">unset SSH_AUTH_SOCK;</div><div class="line">unset SSH_AGENT_PID;</div><div class="line">echo Agent pid 2148 killed;</div><div class="line">[root@server ~]# ssh-add -l     #查看一下，缓存里已经没有了密钥了</div><div class="line">The agent has no identities.</div></pre></td></tr></table></figure></p>
<h2 id="基于公钥密钥连接："><a href="#基于公钥密钥连接：" class="headerlink" title="基于公钥密钥连接："></a>基于公钥密钥连接：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> paramiko</div><div class="line"></div><div class="line">private_key = paramiko.RSAKey.from_private_key_file(<span class="string">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 创建SSH对象</span></div><div class="line">ssh = paramiko.SSHClient()</div><div class="line"><span class="comment"># 允许连接不在know_hosts文件中的主机</span></div><div class="line">ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())</div><div class="line"><span class="comment"># 连接服务器</span></div><div class="line">ssh.connect(hostname=<span class="string">'hostname'</span>, port=<span class="number">22</span>, username=<span class="string">'username'</span>,pkey=private_key)</div><div class="line"><span class="comment"># 执行命令</span></div><div class="line">stdin, stdout, stderr = ssh.exec_command(<span class="string">'df'</span>)</div><div class="line"><span class="comment"># 获取命令结果</span></div><div class="line">result = stdout.read()</div><div class="line">print(result.decode())</div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">ssh.close()</div></pre></td></tr></table></figure>
<p>结果：<br>文件系统           1K-块    已用      可用 已用% 挂载点<br>udev             1006620       0   1006620    0% /dev<br>tmpfs             204796    5264    199532    3% /run<br>/dev/sda1      136750208 5922700 123857960    5% /<br>tmpfs            1023964     148   1023816    1% /dev/shm<br>tmpfs               5120       0      5120    0% /run/lock<br>tmpfs            1023964       0   1023964    0% /sys/fs/cgroup<br>cgmfs                100       0       100    0% /run/cgmanager/fs<br>tmpfs             204796      28    204768    1% /run/user/119<br>tmpfs             204796       0    204796    0% /run/user/1001</p>
<h2 id="基于公钥密钥上传下载"><a href="#基于公钥密钥上传下载" class="headerlink" title="基于公钥密钥上传下载"></a>基于公钥密钥上传下载</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> paramiko</div><div class="line"></div><div class="line">private_key = paramiko.RSAKey.from_private_key_file(<span class="string">'/Users/liyongjun/.ssh/id_rsa'</span>)</div><div class="line"></div><div class="line">transport = paramiko.Transport((<span class="string">'hostname'</span>, <span class="number">22</span>))</div><div class="line">transport.connect(username=<span class="string">'username'</span>, pkey=private_key )</div><div class="line"></div><div class="line">sftp = paramiko.SFTPClient.from_transport(transport)</div><div class="line"><span class="comment"># 将location.py 上传至服务器 /tmp/test.py</span></div><div class="line">sftp.put(<span class="string">'/Volumes/ziyan/pythonworkspace/ssh.py'</span>, <span class="string">'/tmp/test.py'</span>)</div><div class="line"><span class="comment"># 将remove_path 下载到本地 local_path</span></div><div class="line"><span class="comment"># sftp.get('remove_path', 'local_path')</span></div><div class="line"></div><div class="line">transport.close()</div></pre></td></tr></table></figure>
<p>结果：<br><img src="/images/python/ssh8.png" alt="Alt text"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/23/C++/inherit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/23/C++/inherit/" itemprop="url">
                  C++继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T13:35:44+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="name-hiding"><a href="#name-hiding" class="headerlink" title="name hiding"></a>name hiding</h1><p>先看一下例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">private</span> :</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		 A():i(<span class="number">10</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;&#125;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> i;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">20</span>;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	B b;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果输出：<br>A::A()<br>20<br>这个理解上没有什么问题，这个所有的OOP的语言都有，这个叫做override，函数的重写或者叫函数的复写。<br>接下来再看一个例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">private</span> :</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		 A():i(<span class="number">10</span>)&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"A::A()"</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;i;&#125;</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="keyword">return</span> i;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">class</span> B:<span class="keyword">public</span> A&#123;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">20</span>;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	B b;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;b.getI()&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;b.getI(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>报错：<br><img src="/images/namehiding.png" alt="Alt text"><br>意思大概是说，函数中的参数过多，应该是0个，但是现在有一个参数，你可能想调用的是那个无参数的函数<br>相当于类B中没有带一个参数的getI函数。不是说B类继承A类，之后就是把所有的A类当中，不管是private的还是public的都继承过来了嘛，为什么A类有带一个参数getI但是对B类的对象调用会报错。这个是因为C++所特有的，除了C++其他的OOP语言都不是这么干的，这叫name hiding。对于C++来说，如果父类当中有overload的函数，在子类当中你出现和父类相同的函数（名字，参数列表都一样）那么子类当中就只有那一个函数了，父类的那些就都被隐藏掉了。这是因为在C++，B类中的getI函数和A类中的getI函数是没有任何关系的，其他的OOP语言会构成一种关系，叫override</p>
<h1 id="Function-overloading"><a href="#Function-overloading" class="headerlink" title="Function overloading"></a>Function overloading</h1><p>overload 是指的我的一些函数可以有相同的函数名，然后他们有不同的参数列表（这个是参数列表的个数和类型会不一样）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">private</span> :</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">0</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> i)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	A a;</div><div class="line">	a.print();</div><div class="line">	a.print(<span class="number">155L</span>);</div><div class="line">	a.print(<span class="number">15</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是overload（重载）<br>当然，如果一个函数的名称相同，参数表相同而返回值类型不同，构不构成overload呢？<br>这个显然不行的，因为这样编译器无从分辨，你到底要调用哪个函数。<br>有的人会说我可以这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = f();</div><div class="line"><span class="keyword">double</span> a = f();</div></pre></td></tr></table></figure></p>
<p>通过返回值要交给哪个类型的变量来让编译器来判断，我要调那个函数。<br>但是问题在于你还可以这样写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f();</div></pre></td></tr></table></figure></p>
<p>这样写编译器就不会知道。</p>
<h1 id="default-value"><a href="#default-value" class="headerlink" title="default value"></a>default value</h1><p>很多编程语言都支持default value<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">private</span> :</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> :</div><div class="line">		A():i(<span class="number">0</span>)&#123;&#125;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i=<span class="number">10</span>)</span></span>&#123;<span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	A a;</div><div class="line">	a.print();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过在这里的忠告是，尽量不用default value ，当然用default value在一些情况下你可以少打一些字。<br>但是对软件工程来说，一般情况下凡事让你少打字的情况都是不好的。因为default value会造成你阅读上的困难。<br>当你看到我在调用print的函数的时候你会以为他只是一个没有参数的函数，但是你找不到。而且default value很不安全，它不一定是设计者的意图。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/21/python/inherit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jenius">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/jenius.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeniusLi's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/21/python/inherit/" itemprop="url">
                  python的多继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-21T16:35:44+08:00">
                2017-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h1><p>python支持多继承，多继承的语言往往会遇到以下两类二义性的问题：<br>有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。<br>有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。<br>C++也是支持多继承的语言之一<br>对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。<br>对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。</p>
<h2 id="Python中多继承与super-用法"><a href="#Python中多继承与super-用法" class="headerlink" title="Python中多继承与super()用法"></a>Python中多继承与super()用法</h2><p>Python类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。</p>
<p>考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 经典类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'A'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line">        <span class="keyword">print</span> <span class="string">'B'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B, A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line">        B.__init__(self)</div><div class="line">        <span class="keyword">print</span> <span class="string">'C'</span></div></pre></td></tr></table></figure></p>
<p>采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新式类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'A'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(B, self).__init__()</div><div class="line">        <span class="keyword">print</span> <span class="string">'B'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B, A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(C, self).__init__()</div><div class="line">        <span class="keyword">print</span> <span class="string">'C'</span></div></pre></td></tr></table></figure></p>
<p>采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">	name = <span class="string">'A'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a A‘s construct'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">	name = <span class="string">'B'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(B,self).__init__()</div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a B‘s construct'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></div><div class="line">	name = <span class="string">'C'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(C, self).__init__()</div><div class="line">		<span class="comment"># B.__init__(self)</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a C‘s construct'</span></div><div class="line"></div><div class="line">c = C()</div></pre></td></tr></table></figure></p>
<p>结果:<br><img src="/images/result.jpeg" alt="Alt text"><br>仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">	name = <span class="string">'B'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'This is a B‘s constructor'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></div><div class="line">	name = <span class="string">'C'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(C, self).__init__()   <span class="comment"># 如果A没有复写构造方法，</span></div><div class="line">		<span class="comment"># super会调用继承顺序从左到右第一个复写构造方法的父类</span></div><div class="line">		<span class="comment"># B.__init__(self)</span></div><div class="line">		print(<span class="string">'This is a C‘s constructor'</span>)</div><div class="line"></div><div class="line">c = C()</div></pre></td></tr></table></figure></p>
<h3 id="注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数"><a href="#注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数" class="headerlink" title="注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数"></a>注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数</h3><p>python中通过C3算法很好的避免了以上两类二义性的情况。</p>
<h2 id="深度优先算法（DFS，Depth-First-Search）"><a href="#深度优先算法（DFS，Depth-First-Search）" class="headerlink" title="深度优先算法（DFS，Depth-First-Search）"></a>深度优先算法（DFS，Depth-First-Search）</h2><p>把根节点压入栈中。<br>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>python2 里如果用的经典类 是使用的 深度优选<br>python2 里如果用的新式类 是使用的 广度优选</p>
<h2 id="广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选"><a href="#广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选" class="headerlink" title="广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)"></a>广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)</h2><p>把根节点放到队列的末尾。<br>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>python3中经典类和新式类都是广度优先</p>
<h2 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h2><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。<br>拓扑排序的实现步骤：<br>循环执行以下两步，直到不存在入度为0的顶点为止<br>选择一个入度为0的顶点并输出之；<br>从网中删除此顶点及所有出边。</p>
<h2 id="python中调用父类方法的两种方式："><a href="#python中调用父类方法的两种方式：" class="headerlink" title="python中调用父类方法的两种方式："></a>python中调用父类方法的两种方式：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       self.name = <span class="string">"A: name"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"A:__init__"</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"A:fun"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"B:__init__"</span></div><div class="line">       A.__init__(self)                <span class="comment"># 使用类名直接调用</span></div><div class="line">       super(B, self).__init__()       <span class="comment"># 使用super关键字调用</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"B:fun"</span></div><div class="line">       A.fun(self)</div><div class="line">       super(B, self).fun()</div><div class="line">       <span class="keyword">print</span> self.name</div></pre></td></tr></table></figure>
<p>对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter A"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"leave A"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter B"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"leave B"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter C"</span></div><div class="line">       super(C, self).__init__()</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave C"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter D"</span></div><div class="line">       super(D, self).__init__()</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave D"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(B, C)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter E"</span></div><div class="line">       B.__init__(self)</div><div class="line">       C.__init__(self)</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave E"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(E, D)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter F"</span></div><div class="line">       E.__init__(self)</div><div class="line">       D.__init__(self)</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave F"</span></div><div class="line"></div><div class="line">f = F()</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>enter F<br>enter E<br>enter B<br>leave B<br>enter C<br>enter D<br>enter A<br>leave A<br>leave D<br>leave C<br>leave E<br>enter D<br>enter A<br>leave A<br>leave D<br>leave F<br>类的继承关系如下所示：<br>   object<br>  |       \<br>  |        A<br>  |      / |<br>  B       C  D<br>   \   /   |<br>     E     |<br>       \   |<br>         F<br>我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).<strong>init</strong>()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！</p>
<h2 id="C3算法的演变历史："><a href="#C3算法的演变历史：" class="headerlink" title="C3算法的演变历史："></a>C3算法的演变历史：</h2><h3 id="经典类（python-2-2之前）："><a href="#经典类（python-2-2之前）：" class="headerlink" title="经典类（python 2.2之前）："></a>经典类（python 2.2之前）：</h3><p>在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：<br>正常的继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>这种情况下，不会产生问题。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C<br>对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。</p>
<h3 id="新式类（python2-2）："><a href="#新式类（python2-2）：" class="headerlink" title="新式类（python2.2）："></a>新式类（python2.2）：</h3><p>在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：<br>如果是经典类，MRO使用DFS<br>如果是新式类，MRO使用BFS<br>针对新式类的BFS示例如下（向右是基类方向）：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E<br>D是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>BFS解决了前面提到的子类无法重写基类方法的问题。</p>
<h3 id="经典类和新式类并存（python2-3-python2-7），C3算法产生："><a href="#经典类和新式类并存（python2-3-python2-7），C3算法产生：" class="headerlink" title="经典类和新式类并存（python2.3-python2.7），C3算法产生："></a>经典类和新式类并存（python2.3-python2.7），C3算法产生：</h3><p>由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>C3的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>C3的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：<br>从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。<br>结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：<br><img src="/images/object.jpeg" alt="Alt text"><br>首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。<br>了解了C3算法，我们前面那个混用的例子中调用super(C,self).<strong>init</strong>()会去调用D构造函数的原因也就显而易见了。<br>在python中提供了<strong>mro</strong>内置属性来查看类的MRO，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(E, D)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> A.__mro__</div><div class="line"></div><div class="line"><span class="comment">#输出：(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;type 'object'&gt;)</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/jenius.jpeg"
               alt="Jenius" />
          <p class="site-author-name" itemprop="name">Jenius</p>
           
              <p class="site-description motion-element" itemprop="description">主要是学习后端技术，学过Java web、python web等后台技术</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jenius</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
