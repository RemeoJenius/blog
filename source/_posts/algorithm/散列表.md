---
title: 散列表
date: 2017-05-25 13:04:44
tags:
categories: 算法
---
# 散列表
散列（哈希）表是一种数据结构。想象一下一种列表，这个列表有两个内容：key，value这种键值对的形式。
对于一对一的查找，散列函数就有用武之地了，并且它的时间复杂度是O(1)。
## 5.1散列函数
散列函数是这样的一个函数，即无论你给它什么数据它都还你一个数字。
![Alt text](/images/algorithm/hash1.png)
散列函数必须满足一些要求：
- **它必须是一致的。** 例如，假如你输入apple时得到4，那么每次输入apple时，得到的必须是4。如果不是这样，散列表将毫无用处。
- **它应将不同的输入映射到不同的数字。** 例如，如果一个散列函数不管输入什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。

-------------------
动手写一个例子:
``` python
map = dict() # 和map = {}等价

map["apple"] = 1
map["pear"] = 1

print map
```
结果：
{'pear': 1, 'apple': 1}
散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这个，具体原因如下。
- 散列函数总是将同样的输入映射到相同的索引。每次你输入apple，得到的都是同一个数字。因此，你可优先使用它来确定将苹果的价格存储在什么地方，并在以后使用它来确定苹果的价格存储在什么地方。
- 散列函数将不同的输入映射到不同的索引。
- 散列函数知道数组有多大，只返回有效的索引。
在将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。
## 将散列表用作缓存
![Alt text](/images/algorithm/hash2.png)
将一些常用的页面直接缓存带你计算机本地，比如上图的登录页面，先判断你的状态（是否登录）之后，如果登录了再去请求服务器，然后等到服务器的响应生成页面。如果没登录，寻找本地的登录页面。
大致上说缓存具有以下两个优点：
- 用户能够更快地看到页面，就像你记住了一个知识点，以后你妹妹问你这个知识点可以立刻回答她，不用再google了。
- Facebook需要做的工作也就更少了。
缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在散列表中！BTW，java web中现在常用redis做缓存的数据库，这个数据库也是这种散列表形式的。
## 小结
这里总结一下，散列表适合用于：
- 模仿映射关系
- 防止重复
- 缓存/记住数据，以免服务器再通过处理来生成它们。
### 代码
``` python
cache = {}

def get_page(url):
	if cahce.get(url):
		return cachae["url"]
	else :
		data = get_data_from_server(url)
		cache[url] = data
		return data
```
# 冲突
冲突：给两个键分配的位置相同。
避免的方法，就是当同一个键分配给两个或者两个以上的值，该位置就需要用列表，形成多个。
简单说：如果两个键映射到了同一个位置，就在这个位置存储一个链表。
![Alt text](/images/algorithm/hash3.png)
但是有一个问题，就是上图中除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟：散列表的速度会很慢。
这里有两个教训:
- **散列函数很重要。** 前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将均匀地映射到散列表的不同位置。
- **如果散列表存储的链表很长，散列表的速度将急剧下降。** 然而使用散列函数很好，这些链表就不会很长！
## 性能
在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。
![Alt text](/images/algorithm/hash4.png)
图像上看，一个散列表不管包含多少个元素，丛中获取的数据所需的时间都相同。
在最遭情况下，散列表所有操作的晕眩时间都为O(n)——线性时间，这真的是很慢。我们来讲散列表同数组和链表比较一下。
![Alt text](/images/algorithm/hash5.png)
在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者有点！但是最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟的情况至关重要。因此需要避免冲突。而要避免冲突，需要有：
- 较低的填裝因子；
- 良好的散列函数。
## 填装因子
散列表的填裝因子很容易计算：
![Alt text](/images/algorithm/hash6.png)
散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如想，下列散列表的填装因子为2/5，即0.4。
![Alt text](/images/algorithm/hash7.png)
这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验的规则是：一旦填装因子大于0.7，就调整散列表的长度。
你可能在想，调整散列表长度的工作需要很长时间！你说的没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即使考虑到调整长度所需的时间，散列表操作所需要的时间为O(1)。
## 良好的散列函数
![Alt text](/images/algorithm/hash8.png)
