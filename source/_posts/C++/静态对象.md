---
title: 静态对象
date: 2017-05-31 18:39:21
tags:
categories: C++
---
# 静态对象
![Alt text](/images/C++/static1.png)
static关键字从c开始就被赋予了两种完全不同的职责，对c来说static就是两义的。它出现在不同的地方，它代表的完全不同的含义。
它的第一层含义是说：存储是持久存储的。
第二层含义是说：它的访问性，是受局限的。
这是完全不同的两个事情。一个是说你在哪里，一个是说谁能看到你。你在哪里不一定代表谁能看到你。它们两个可以是不一样的。但是c得static，同时要去表达这两种东西。
到了C++这件事情就更复杂。是因为我们还有成员变量和成员函数。我们在C的时候，我们的全局变量可以是static的，这个时候这个全局变量只在那个.c文件有效了。我们也可以说一个本地变量是static的，这个时候这个本地变量就可以持久存储了。实际上static的本地变量就是全局变量，它就是放在全局变量那个地方的。我们也有static这个函数，有static这个函数是只有这个.c文件能访问的，在这个.c以外是不能够被访问的。现在到了C++我们还有static的成员变量和static的成员函数。
我们在进一步去理解这两样东西是什么。
![Alt text](/images/C++/static2.png)
我们有static的自由函数，现在它被化了一条删除线说的是deprecated过时的，static global variables也是deprecated的过时了。static local variables 没有过时它代表的是持久存储。static member variables在所有的对象之间共享，static member function 静态的成员函数在所有的对象之间共享。
static的全局变量指的是，这个全局指的是整个程序，但是再在前面加了static那就是说这个变量只能在这个编译单元里访问，就算你在其他的编译单元里说了extern也没用，说了可以骗过编译器但是骗不过linker。当然static free function也是一样的在其他的编译单元中还是不能被访问的，这是C的局面。
## Static inside functions
- Value is remembered for entire program
- Initialization occurs only once
其实static的本地变量就是全局变量，然后它有一个特殊的访问属性，就是只能在那个函数的内部访问。
![Alt text](/images/C++/static3.png)
如果你的一个static的本地变量，它的类型是一个类的话，那会怎么样？我们关心的是两件事情，第一件事情是它在哪里，第二件事情是它什么时候被构造出来。如果你有一个static int 的变量初始化为10，它是在进函数的时候才会被初始化。显然它是static的，这就意味着它的存储是全局的，它的初始化是在第一次进这个函数的时候才会被初始化的。那就会引申出一个问题，你怎么知道这个变量被初始化过了。我们还要分清楚内存和初始化，它在哪里这是内存，它什么时候被初始化这是初始化。首先它在哪里，它在全局数据区，所以它空间就是在编译的时候就已经分配好了，更准确一点linker的时候分配好了。所以它的内存早就有了，当然内存里面的东西，内存里面所有的变量是要在初始化的时候去初始化的。对于java来说，它有种机制来保证没有被初始化的内存是不会被别人得到的,任何内存一定是被初始化之后才会被别人掌握到，那就不需要这个事情了。但是C++的内存模型复杂。
也就是说当一个static的变量并且这个变量的类型是一个类的时候，它肯定也要去遵循static的那些规则，C++一定会保证一个事情就是构造是只发生一次的，有了构造就会有对应的析构，也一定是LIFO的顺序。
如果作为一个全局变量它的析构是在什么时候发生的？作为一个本地变量它的析构是在离开函数的时候发生。如果是new出来的对象是在delete的时候发生的，全局变量是程序结束的时候发生，虽然程序结束了所有的内存都会被操作系统回收的，但是你的析构要去做一些其他的事情，比如说关闭一个网络流呀、显示一些东西出来。所以它还是有意义的。
如果你的对象是全局的呢？
![Alt text](/images/C++/static4.png)
它们的空间在哪，在全局数据区。什么时候分配空间，编译或者说链接的时候。什么时候构造，全局变量的构造它肯定只做一次，在程序运行之前，程序一运行的时候，但是再main函数之前，如果这个变量的类型是一个类也就是说是在main函数之前调用那个类的构造函数。如果C学的好的话，早就知道那个main本来就不是第一个被调用的了，在main之前有编译器给你放进去的启动代码。
这就会有一个问题是说，如果你的程序有多个.cpp文件，每个文件里面都有一个全局变量，这些变量谁先初始化，谁后初始化是没有规矩的，甚至可能同一个编译器这次编译和下次编译都可能不一样，因为没人保证它会是怎么样的，这就有一个问题如果有几个全局变量（对象）是互相依赖的，一个对象的构造要依赖于另一个对象的值，这就必须是先对后面的那个对象初始化，在对前面那个初始化。要解决这个问题这有两种解决方案，第一种你不去用它，像java，java没有全局变量。第二种就是竟=尽可能的比这些有依赖关系的变量写在一个.cpp中。
![Alt text](/images/C++/static5.png)
