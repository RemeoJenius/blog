<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="主要是学习后端技术，学过Java web、python web等后台技术"><title>python的多继承 | jeniusLi's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python的多继承</h1><a id="logo" href="/.">jeniusLi's blog</a><p class="description">生活、技术个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">python的多继承</h1><div class="post-meta">Apr 21, 2017<span> | </span><span class="category"><a href="/categories/python/">python</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/04/21/python/inherit/" href="/2017/04/21/python/inherit/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><h1 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h1><p>python支持多继承，多继承的语言往往会遇到以下两类二义性的问题：<br>有两个基类A和B，A和B都定义了方法f()，C继承A和B，那么调用C的f()方法时会出现不确定。<br>有一个基类A，定义了方法f()，B类和C类继承了A类（的f()方法），D类继承了B和C类，那么出现一个问题，D不知道应该继承B的f()方法还是C的f()方法。<br>C++也是支持多继承的语言之一<br>对于问题1，C++中通过同名覆盖的方式来解决，子类方法和属性会优先调用，如果要在子类中访问被屏蔽的基类成员，应使用基类名来限定（BaseClassName::Func()）。<br>对于问题2，C++中通过虚继承来解决，以virtual关键字修饰共同的直接基类，从而保证不会产生多个基类副本产生歧义。</p>
<h2 id="Python中多继承与super-用法"><a href="#Python中多继承与super-用法" class="headerlink" title="Python中多继承与super()用法"></a>Python中多继承与super()用法</h2><p>Python类分为两种，一种叫经典类，一种叫新式类。两种都支持多继承。</p>
<p>考虑一种情形，B继承于A，C继承于A和B, 但C需要调用父类的init()函数时，前者会导致父类A的init()函数被调用2次，这是不希望看到的。而且子类要显式地指定父类，不符合DRY原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 经典类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'A'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line">        <span class="keyword">print</span> <span class="string">'B'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B, A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        A.__init__(self)</div><div class="line">        B.__init__(self)</div><div class="line">        <span class="keyword">print</span> <span class="string">'C'</span></div></pre></td></tr></table></figure></p>
<p>采用新式类，要求最顶层的父类一定要继承于object，这样就可以利用super()函数来调用父类的init()等函数，每个父类都执行且执行一次，并不会出现重复调用的情况。而且在子类的实现中，不用到处写出所有的父类名字，符合DRY原则。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 新式类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'A'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(B, self).__init__()</div><div class="line">        <span class="keyword">print</span> <span class="string">'B'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B, A)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(C, self).__init__()</div><div class="line">        <span class="keyword">print</span> <span class="string">'C'</span></div></pre></td></tr></table></figure></p>
<p>采用super()方式时，会自动找到第一个多继承中的第一个父类，但是如果还想强制调用其他父类的init()函数或两个父类的同名函数时，就要用老办法了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">	name = <span class="string">'A'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a A‘s construct'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">	name = <span class="string">'B'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(B,self).__init__()</div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a B‘s construct'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></div><div class="line">	name = <span class="string">'C'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(C, self).__init__()</div><div class="line">		<span class="comment"># B.__init__(self)</span></div><div class="line">		<span class="keyword">print</span> <span class="string">'This is a C‘s construct'</span></div><div class="line"></div><div class="line">c = C()</div></pre></td></tr></table></figure></p>
<p>结果:<br><img src="/images/result.jpeg" alt="Alt text"><br>仔细看了一下代码，自从python2.2之后引入了super，这个一方面是解决上面的一个问题，就是以后改父类的的名字，只要改一个地方就可以了，另一方面为了避免重复调用同一个类的构造方法，这个也可以理解，构造函数本来就是为了给属性初始化的，初始化当然做一次也就够了的。仔细看一下代码调用super ，如果是多继承会调用第一个父类的方法，上面从代码上看如果编译通过了，将会调用两次A的构造。现在来说就出现编译错误了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">	name = <span class="string">'B'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		print(<span class="string">'This is a B‘s constructor'</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A,B)</span>:</span></div><div class="line">	name = <span class="string">'C'</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		super(C, self).__init__()   <span class="comment"># 如果A没有复写构造方法，</span></div><div class="line">		<span class="comment"># super会调用继承顺序从左到右第一个复写构造方法的父类</span></div><div class="line">		<span class="comment"># B.__init__(self)</span></div><div class="line">		print(<span class="string">'This is a C‘s constructor'</span>)</div><div class="line"></div><div class="line">c = C()</div></pre></td></tr></table></figure></p>
<h3 id="注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数"><a href="#注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数" class="headerlink" title="注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数"></a>注意python继承，先去执行本类的构造函数，如果本类中没有构造函数，就去执行父类当中的构造函数</h3><p>python中通过C3算法很好的避免了以上两类二义性的情况。</p>
<h2 id="深度优先算法（DFS，Depth-First-Search）"><a href="#深度优先算法（DFS，Depth-First-Search）" class="headerlink" title="深度优先算法（DFS，Depth-First-Search）"></a>深度优先算法（DFS，Depth-First-Search）</h2><p>把根节点压入栈中。<br>每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>python2 里如果用的经典类 是使用的 深度优选<br>python2 里如果用的新式类 是使用的 广度优选</p>
<h2 id="广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选"><a href="#广度优先算法（BFS，Breadth-First-Search）-python3-里全都是广度优选" class="headerlink" title="广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)"></a>广度优先算法（BFS，Breadth-First-Search）(python3 里全都是广度优选)</h2><p>把根节点放到队列的末尾。<br>每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。<br>找到所要找的元素时结束程序。<br>如果遍历整个树还没有找到，结束程序。</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>python3中经典类和新式类都是广度优先</p>
<h2 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h2><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑排序(TopologicalOrder)的序列，简称拓扑序列。<br>拓扑排序的实现步骤：<br>循环执行以下两步，直到不存在入度为0的顶点为止<br>选择一个入度为0的顶点并输出之；<br>从网中删除此顶点及所有出边。</p>
<h2 id="python中调用父类方法的两种方式："><a href="#python中调用父类方法的两种方式：" class="headerlink" title="python中调用父类方法的两种方式："></a>python中调用父类方法的两种方式：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       self.name = <span class="string">"A: name"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"A:__init__"</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"A:fun"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"B:__init__"</span></div><div class="line">       A.__init__(self)                <span class="comment"># 使用类名直接调用</span></div><div class="line">       super(B, self).__init__()       <span class="comment"># 使用super关键字调用</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"B:fun"</span></div><div class="line">       A.fun(self)</div><div class="line">       super(B, self).fun()</div><div class="line">       <span class="keyword">print</span> self.name</div></pre></td></tr></table></figure>
<p>对于单继承来说，上面这两种方式并无本质上的区别，但是当出现多继承的时候，super得到的基类就不一定是我们“认为”的基类了，我们看下面这个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter A"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"leave A"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter B"</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"leave B"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter C"</span></div><div class="line">       super(C, self).__init__()</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave C"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(A)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter D"</span></div><div class="line">       super(D, self).__init__()</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave D"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(B, C)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter E"</span></div><div class="line">       B.__init__(self)</div><div class="line">       C.__init__(self)</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave E"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(E, D)</span>:</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">       <span class="keyword">print</span> <span class="string">"enter F"</span></div><div class="line">       E.__init__(self)</div><div class="line">       D.__init__(self)</div><div class="line">       <span class="keyword">print</span> <span class="string">"leave F"</span></div><div class="line"></div><div class="line">f = F()</div></pre></td></tr></table></figure></p>
<p>输出结果：<br>enter F<br>enter E<br>enter B<br>leave B<br>enter C<br>enter D<br>enter A<br>leave A<br>leave D<br>leave C<br>leave E<br>enter D<br>enter A<br>leave A<br>leave D<br>leave F<br>类的继承关系如下所示：<br>   object<br>  |       \<br>  |        A<br>  |      / |<br>  B       C  D<br>   \   /   |<br>     E     |<br>       \   |<br>         F<br>我们的本意是希望调用构造函数的时候，对于基类的构造方法也进行调用，但是实际结果发现，A和D的构造函数被调用了2次，而且奇怪的是，当调用super(C, self).<strong>init</strong>()的时候，竟然进入D的构造函数，这也是为什么D的构造函数被调用了两次（一次是F调用的，一次是C调用的）！从继承关系上看，C的基类应该是A才对。这就要引出下面要解释的，python中的C3方法。不过针对上面这个例子，修改的思路很简单，要么全部使用类名来调用基类方法，要么全部使用super()来调用，不要混用！</p>
<h2 id="C3算法的演变历史："><a href="#C3算法的演变历史：" class="headerlink" title="C3算法的演变历史："></a>C3算法的演变历史：</h2><h3 id="经典类（python-2-2之前）："><a href="#经典类（python-2-2之前）：" class="headerlink" title="经典类（python 2.2之前）："></a>经典类（python 2.2之前）：</h3><p>在python 2.2之前，python中使用经典类（classicclass），经典类是一种没有继承的类，所有类型都是type类型，如果经典类作为父类，子类调用父类构造函数会报错。当时用作MRO的算法是DFS（深度优先），下面的例子是当时使用DFS算法的示例（向右是基类方向）：<br>正常的继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>这种情况下，不会产生问题。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>DFS的遍历顺序为：A-&gt;B-&gt;D-&gt;C<br>对于这种情况，如果公共父类D中也定义了f()，C中重写了方法f()，那么C中的f()方法永远也访问不到，因为按照遍历的顺序始终先发现D中的f()方法，导致子类无法重写基类方法。</p>
<h3 id="新式类（python2-2）："><a href="#新式类（python2-2）：" class="headerlink" title="新式类（python2.2）："></a>新式类（python2.2）：</h3><p>在python2.2开始，为了使类的内置类型更加统一，引入了新式类（new-style class），新式类每个类都继承自一个基类，默认继承自object，子类可以调用基类的构造函数。由于所有类都有一个公共的祖先类object，所以新式类不能使用DFS作为MRO。在当时有两种MRO并存：<br>如果是经典类，MRO使用DFS<br>如果是新式类，MRO使用BFS<br>针对新式类的BFS示例如下（向右是基类方向）：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D-&gt;E<br>D是B的唯一基类，但是遍历时却先遍历节点C，这种情况下应该先从唯一基类进行查找，这个原则称为单调性。<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>BFS的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>BFS解决了前面提到的子类无法重写基类方法的问题。</p>
<h3 id="经典类和新式类并存（python2-3-python2-7），C3算法产生："><a href="#经典类和新式类并存（python2-3-python2-7），C3算法产生：" class="headerlink" title="经典类和新式类并存（python2.3-python2.7），C3算法产生："></a>经典类和新式类并存（python2.3-python2.7），C3算法产生：</h3><p>由于DFS和BFS针对经典类和新式类都有缺陷，从python2.3开始，引入了C3算法。针对前面两个例子，C3算法的遍历顺序如下：<br>正常继承方式：<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;E<br>C3的遍历顺序为：A-&gt;B-&gt;D-&gt;C-&gt;E<br>菱形的继承方式<br>A-&gt;B-&gt;D<br>A-&gt;C-&gt;D<br>C3的遍历顺序为：A-&gt;B-&gt;C-&gt;D<br>看起来是DFS和BFS的综合，但是并非如此，下面的例子说明了C3算法的具体实现：<br>从前面拓扑排序的定义可知，将有向无环图进行拓扑排序后，按照得到的拓扑序列遍历即可满足单调性，原因是由根到叶即是子类到基类的方向，当基类的入度为0是，它就是子类的唯一基类，此时会优先遍历此基类，符合单调性。而子类无法重写方法的问题也可以得到解决，因为当多个子类继承自同一个基类时，该基类的入度不会先于子类减为0，所以可以保证优先遍历入度减为0的子类。<br>结合下面这张图的例子来说明C3算法的执行步骤（图中箭头由子类指向父类）：<br><img src="/images/object.jpeg" alt="Alt text"><br>首先找入度为0的点，只有A，把A取出，把A相关的边去掉，再找下一个入度为0的点，B和C满足条件，从左侧开始取，取出B，这时顺序是AB，然后去掉B相关的边，这时候入度为0的点有E和C，依然取左边的E，这时候顺序为ABE，接着去掉E相关的边，这时只有一个点入度为0，那就是C，取C，顺序为ABEC。去掉C的边得到两个入度为0的点D和F，取出D，顺序为ABECD，然后去掉D相关的边，那么下一个入度为0的就是F，然后是object。所以最后的排序就为ABECDFobject。<br>了解了C3算法，我们前面那个混用的例子中调用super(C,self).<strong>init</strong>()会去调用D构造函数的原因也就显而易见了。<br>在python中提供了<strong>mro</strong>内置属性来查看类的MRO，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span><span class="params">(object)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(D, F)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(E, D)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(B, C)</span>:</span></div><div class="line">   <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> A.__mro__</div><div class="line"></div><div class="line"><span class="comment">#输出：(&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.F'&gt;, &lt;type 'object'&gt;)</span></div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/04/21/python/inherit/" data-id="cj3i9tmd90013z1u2ybzt3jn8" class="article-share-link">Share</a><div class="tags"></div><div class="post-nav"><a href="/2017/04/23/C++/inherit/" class="pre">C++继承</a><a href="/2017/04/10/测试驱动开发/" class="next">测试驱动开发</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'jenius';
var disqus_identifier = '2017/04/21/python/inherit/';
var disqus_title = 'python的多继承';
var disqus_url = 'http://yoursite.com/2017/04/21/python/inherit/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//jenius.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/31/C++/静态对象/">静态对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/25/algorithm/散列表/">散列表</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/22/C++/拷贝构造函数/">拷贝构造函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/17/algorithm/快速排序/">快速排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/15/algorithm/递归/">递归</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/09/C++/多态/">多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/09/C++/reference/">reference</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/algorithm/选择排序/">选择排序</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/05/C++/Const/">Const</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/01/algorithm/算法/">二分法查询</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> Recent Comments</i></div><script type="text/javascript" src="//jenius.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">jeniusLi's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>